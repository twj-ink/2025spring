# å›æ–‡å­ä¸²ä¸å›æ–‡å­åºåˆ—


âœ”ï¸ **å›æ–‡å­ä¸²ä¸å›æ–‡å­åºåˆ—**
1. ğŸš€**å›æ–‡å­ä¸²**
   1. [LeetCode: 5. æœ€é•¿å›æ–‡å­ä¸²](#leetcode5æœ€é•¿å›æ–‡å­ä¸²)
      1. [åŒºé—´dp](#1åŒºé—´dp)
      2. [Manacherç®—æ³•](#2manacherç®—æ³•)
   2. [LeetCode: 131. åˆ†å‰²å›æ–‡ä¸²](#leetcode131åˆ†å‰²å›æ–‡ä¸²)
   3. [OpenJudge: 01159. Palindrome](#openjudge01159palindrome)
   4. [LeetCode: 214.æœ€çŸ­å›æ–‡ä¸²](#leetcode214æœ€çŸ­å›æ–‡ä¸²)

2. ğŸš€**å›æ–‡å­åºåˆ—**
   1. [LeetCode: 516. æœ€é•¿å›æ–‡å­åºåˆ—](#leetcode516æœ€é•¿å›æ–‡å­åºåˆ—)
      1. [åŒºé—´dp](#1åŒºé—´dp-1)
      2. [é€’å½’](#2é€’å½’)
   2. [LeetCode: 3472. è‡³å¤šKæ¬¡æ“ä½œåçš„æœ€é•¿å›æ–‡å­åºåˆ—](#leetcode3472è‡³å¤škæ¬¡æ“ä½œåçš„æœ€é•¿å›æ–‡å­åºåˆ—)
      1. [åŒºé—´dp](#1åŒºé—´dp-2)
      2. [é€’å½’](#2é€’å½’-1)


## ä¸€ã€å›æ–‡å­ä¸²
**å­å­—ç¬¦ä¸²** æ˜¯å­—ç¬¦ä¸²ä¸­ **è¿ç»­** çš„éç©ºå­—ç¬¦åºåˆ—ã€‚
æˆ–è€…è¯´æ˜¯ä»å‰ç«¯æˆ–è€…åç«¯åˆ é™¤è‹¥å¹²ä¸ªæˆ–0ä¸ªå½¢æˆçš„æ–°å­—ç¬¦ä¸²ã€‚

### LeetCode:5.æœ€é•¿å›æ–‡å­ä¸²
> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„ **å›æ–‡å­ä¸²**ã€‚
> >ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šs = "babad"
è¾“å‡ºï¼š"bab"
è§£é‡Šï¼š"aba" åŒæ ·æ˜¯ç¬¦åˆé¢˜æ„çš„ç­”æ¡ˆã€‚
> 
> >ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šs = "cbbd"
è¾“å‡ºï¼š"bb"
> 
> æç¤ºï¼š
1 <= s.length <= 1000
s ä»…ç”±æ•°å­—å’Œè‹±æ–‡å­—æ¯ç»„æˆ

#### 1.åŒºé—´dp
ç”¨å¸ƒå°”äºŒç»´æ•°ç»„dpæ¥è¡¨ç¤ºæŸä¸ªåŒºé—´æ˜¯å¦æ˜¯å›æ–‡ä¸²ã€‚
`dp[i][j]==True`è¡¨ç¤ºä»`s[i]`åˆ°`s[j]`æ˜¯ä¸€ä¸ªå›æ–‡ä¸²ï¼Œé‚£ä¹ˆå½“`i==j`æ—¶`dp[i][j]=True`;å½“`i>j`æ—¶`dp[i][j]=False`;
å½“`i<j`æ—¶ï¼Œä¸€æ—¦`s[i]!=s[j]`åˆ™ç›´æ¥ä¸ºFalseï¼›å¦åˆ™è¿˜è¦å¯¹åŒºé—´é•¿åº¦æ˜¯å¦ä¸º2åˆ¤æ–­ä¸€ä¸‹ï¼Œ`dp[i][j] = dp[i+1][j-1] & (s[i]==s[j])`ã€‚
ç”±äºdpçš„é¡ºåºæ˜¯ä»å°å­ä¸²åˆ°å¤§å­ä¸²ï¼Œæ‰€ä»¥åº”å½“å¯¹åŒºé—´é•¿åº¦Lè¿›è¡Œéå†ï¼ŒåŒæ—¶åˆå§‹åŒ–é•¿åº¦ä¸º1æ—¶éƒ½ä¸ºTrueï¼Œå¹¶ç»´æŠ¤`maxl`å’Œ`begin`æ¥åˆ†åˆ«è®°å½•æœ€é•¿é•¿åº¦å’Œèµ·å§‹ä½ç½®ã€‚
```python
def longestPalindrome(s: str) -> str:
    maxl,begin,n=1,0,len(s)
    dp=[[False]*n for _ in range(n)]
    
    #å•ä¸ªå­—ç¬¦æ˜¯å›æ–‡çš„
    for i in range(n):
        dp[i][i]=True
    
    #æšä¸¾å­ä¸²å¯èƒ½çš„æ‰€æœ‰é•¿åº¦
    for L in range(2,n+1):
        for i in range(n):
            j=L+i-1
            if j>=n:
                break
            
            if s[i]!=s[j]:
                dp[i][j]=False
            else:
                if L==2:
                    dp[i][j]=True
                else:
                    dp[i][j]=dp[i+1][j-1]
                    
            #æ›´æ–°maxlå’Œbegin
            if dp[i][j] and L>maxl:
                maxl=L
                begin=i
    
    return s[begin:begin+maxl]
```
æˆ–è€…ç”¨éå†å³è¾¹ç•Œï¼Œå†åå‘éå†å·¦è¾¹ç•Œçš„å†™æ³•ï¼š
```python
def longestPalindrome(self, s: str) -> str:
    #dp[i][j] è¡¨ç¤ºä»iåˆ°jæ˜¯å›æ–‡çš„
    #dp[i][j]=dp[i+1][j-1] and (s[i]==s[j])
    n=len(s)
    maxl=1;begin=0
    dp=[[False]*n for _ in range(n)]

    for j in range(n):
        for i in range(j,-1,-1):
            L=j-i+1
            if L==1:
                dp[i][j]=True
            elif L==2 and s[i]==s[j]:
                dp[i][j]=True
            elif L>=3 and s[i]==s[j] and dp[i+1][j-1]:
                dp[i][j]=True

            if dp[i][j] and L>maxl:
                maxl=L
                begin=i
    return s[begin:begin+maxl]
```

è¿™é‡ŒæŸ¥çœ‹é¢˜è§£å‘ç°æ›´ç®€æ´çš„å†™æ³•ï¼šåˆå§‹åŒ–éƒ½è®¾ç½®ä¸ºTrueï¼Œç„¶ååˆ©ç”¨`dp[i][j]=(dp[i+1][j-1] and s[i]==s[j])`æ¥ä¸æ–­æ›´æ–°
```python
def longestPalindrome(self, s: str) -> str:
    #dp[i][j] è¡¨ç¤ºä»iåˆ°jæ˜¯å›æ–‡çš„
    #dp[i][j]=dp[i+1][j-1] and (s[i]==s[j])
    n=len(s)
    maxl=1;begin=0
    dp=[[True]*n for _ in range(n)]

    for j in range(n):
        for i in range(j-1,-1,-1):
            L=j-i+1
            # if L==1:
            #     dp[i][j]=True
            # elif L==2 and s[i]==s[j]:
            #     dp[i][j]=True
            # elif L>=3 and s[i]==s[j] and dp[i+1][j-1]:
            #     dp[i][j]=True
            dp[i][j]=(dp[i+1][j-1] and s[i]==s[j])

            if dp[i][j] and L>maxl:
                maxl=L
                begin=i
    return s[begin:begin+maxl]
```

äº‹å®ä¸Šï¼Œå¦‚æœåªéœ€è¦é¢„å¤„ç†å‡ºæŸä¸ªå­—ç¬¦ä¸²çš„å„ä¸ªåŒºé—´æ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼ˆä»¥æ–¹ä¾¿åç»­ä»¥O(1)çš„å¤æ‚åº¦åˆ¤æ–­ï¼‰ï¼Œåªéœ€è¦å‡ è¡Œä»£ç ï¼š
```python
def process(s):
    n=len(s)
    dp=[[True]*n for _ in range(n)]
    for j in range(n):
        for i in range(j-1,-1,-1):
            dp[i][j]=(dp[i+1][j-1] and s[i]==s[j])
```
è¿™æ ·ï¼Œå¦‚æœæƒ³çŸ¥é“`s[i:j+1]`æ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼Œåªéœ€è¦åˆ¤æ–­`dp[i][j]==True`å³å¯ã€‚

#### 2.Manacherç®—æ³•
åˆ©ç”¨äº† **å¯¹ç§°æ€§ä¼˜åŒ–** ï¼Œå®é™…ä¸Šæ˜¯å¯¹æ¯ä¸ªä½ç½®çš„åˆå§‹åŒ–è¿›è¡Œä¼˜åŒ–ï¼š
>å›æ–‡å¯¹ç§°æ€§è§‚å¯Ÿï¼š 
> å‡è®¾æˆ‘ä»¬åœ¨ä½ç½® i å¤„æ‰©å±•å¾—åˆ°äº†å›æ–‡ä¸²ï¼Œå¹¶ä¸”è¿™ä¸ªå›æ–‡ä¸²çš„åŠå¾„æ˜¯ P[i]ï¼Œä¹Ÿå°±æ˜¯è¯´ä½ç½® i çš„å›æ–‡ä¸²åœ¨å·¦å³å„æœ‰ P[i] ä¸ªå­—ç¬¦ã€‚
ç”±äºå›æ–‡çš„å¯¹ç§°æ€§ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“å›æ–‡ä¸²çš„å¯¹ç§°ä½ç½®ä¹Ÿæœ‰ç›¸åŒé•¿åº¦çš„å›æ–‡ä¸²ã€‚
åˆ©ç”¨å¯¹ç§°æ€§æ¨æµ‹ï¼š å¦‚æœæˆ‘ä»¬çŸ¥é“å½“å‰å›æ–‡ä¸²çš„ä¸­å¿ƒæ˜¯ Cï¼Œå³è¾¹ç•Œæ˜¯ Rï¼Œå¹¶ä¸” i åœ¨è¿™ä¸ªå›æ–‡ä¸²çš„å³è¾¹ç•Œå†…ï¼ˆå³ i < Rï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ i çš„å¯¹ç§°ä½ç½®æ¥æ¨æµ‹ P[i]ã€‚
P[mirr]ï¼šmirr æ˜¯ i ç›¸å¯¹äºä¸­å¿ƒ C çš„å¯¹ç§°ä½ç½®ã€‚å¯ä»¥é€šè¿‡å…¬å¼ mirr = 2 * C - i è®¡ç®—å¾—åˆ°ã€‚
å› ä¸º i å’Œ mirr çš„ä½ç½®å¯¹ç§°ï¼Œå®ƒä»¬çš„å›æ–‡ä¸²çš„åŠå¾„åº”è¯¥ç›¸åŒã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœ i çš„å›æ–‡åŠå¾„ P[i] æ²¡æœ‰è¶…å‡ºå³è¾¹ç•Œ Rï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åˆå§‹åŒ– P[i] = P[mirr]ã€‚è¿™æ ·å°±é¿å…äº†é‡æ–°è®¡ç®— i ä½ç½®çš„å›æ–‡ä¸²ï¼Œè€Œæ˜¯ç›´æ¥åˆ©ç”¨å¯¹ç§°çš„ mirr ä½ç½®ã€‚

```python
def ManacherPalindrome(s: str) -> str:
    t='#'+'#'.join(s)+'#'
    n=len(t)
    P=[0]*n
    C,R=0,0
    for i in range(n):
        # æ‰¾å¯¹ç§°ä½ç½®å¹¶åˆ¤æ–­æ˜¯å¦å¯ä»¥åˆå§‹åŒ–ä¸ºå¯¹ç§°ä½ç½®çš„åŠå¾„
        mirr=2*C-i
        if i<R:
            P[i]=min(P[mirr],R-i)
        
        # æ‹“å±•è¯¥ä½ç½®çš„åŠå¾„
        while i+P[i]+1<n and i-P[i]-1>=0 and t[i+P[i]+1]==t[i-P[i]-1]:
            P[i]+=1
        
        # æ‹“å±•åçš„å›æ–‡ä¸²å¦‚æœè¶…å‡ºäº†å³è¾¹ç•Œï¼Œæ›´æ–°
        if i+P[i]>R:
            C,R=i,i+P[i]
            
    max_len,center_idx=max((n,i) for i, n in enumerate(P))
    begin=(center_idx-max_len)//2
    return s[begin:begin+max_len]
```

### LeetCode:131.åˆ†å‰²å›æ–‡ä¸²

>ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¯·ä½ å°† s åˆ†å‰²æˆä¸€äº› å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ å›æ–‡ä¸² ã€‚è¿”å› s æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚
>
> >ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šs = "aab"
è¾“å‡ºï¼š[["a","a","b"],["aa","b"]]
>
> >ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šs = "a"
è¾“å‡ºï¼š[["a"]]
>
>æç¤ºï¼š
1 <= s.length <= 16
s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

è¯¥é¢˜åªéœ€è¦ä½¿ç”¨æ¨¡æ¿å¤„ç†å‡ºå›æ–‡å­åºåˆ—çš„å¸ƒå°”dpæ•°ç»„ï¼Œç„¶åå°±æ˜¯dfsæ¥æ‰¾åˆ°æ‰€æœ‰å›æ–‡ä¸²äº†ã€‚
æ­¤é¢˜æ˜¯ **å›æ–‡å­ä¸²** å’Œ **dfsçš„å›æº¯** ç»“åˆçš„é¢˜ç›®ã€‚ï¼ˆä½†æ˜¯éš¾åº¦å±…ç„¶åªæ˜¯ä¸­ç­‰ï¼Ÿï¼‰

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n=len(s)
        dp=[[True]*n for _ in range(n)]

        for j in range(n):
            for i in range(j-1,-1,-1):
                dp[i][j]=(dp[i+1][j-1] and s[i]==s[j])

        ans=[]
        #ä»0ä½ç½®è¿›å…¥ï¼Œè®©jå‘å³éå†ï¼Œæ¯æ‰¾åˆ°ä¸€ä¸ªå›æ–‡ä¸²å°±ä»j+1çš„ä½ç½®è¿›ä¸€æ­¥dfs
        def dfs(i,curr):
            if i==n:
                ans.append(curr[:])
                return 
            for j in range(i,n):
                if dp[i][j]:
                    curr.append(s[i:j+1])
                    dfs(j+1,curr)
                    curr.pop()
        
        dfs(0,[])
        
        return ans
```

### OpenJudge:01159.Palindrome

http://cs101.openjudge.cn/2025sp_routine/01159/

ä¹Ÿæ¶‰åŠåˆ°äº†å›æ–‡ä¸²ï¼Œé‡ç‚¹æ˜¯æ‰¾åˆ°é€’æ¨å…¬å¼ï¼Œå­¦ä¹ dpçš„ä¼˜åŒ–ç©ºé—´å†™æ³•ï¼ˆæ‰¾çŠ¶æ€è½¬ç§»éœ€è¦ç”¨åˆ°å“ªäº›å†å²çŠ¶æ€ï¼‰ã€‚

```python
# è¶…å†…å­˜

'''
n=int(input())
s=input()
dp=[[0]*n for _ in range(n)]
for j in range(n):
    for i in range(j,-1,-1):
        if i>=j: continue
        if s[i]==s[j]:
            dp[i][j]=dp[i+1][j-1]
        else:
            dp[i][j]=min(dp[i+1][j]+1, dp[i][j-1]+1, dp[i+1][j-1]+2)

print(dp[0][-1])
'''

# currå­˜çš„æ˜¯dp[0..n][j]è¿™ä¸€å½“å‰åˆ—ï¼Œ
# prevå­˜çš„æ˜¯dp[0..n][j-1]è¿™ä¸€å…ˆå‰åˆ—ï¼Œ
# æ¯æ¬¡ç”¨åˆ°çš„å°±åªæœ‰å½“å‰æ ¼å­çš„å·¦è¾¹ã€ä¸‹è¾¹ã€å·¦ä¸‹è¾¹ä¸‰ä¸ªä½ç½®ï¼Œå³
# dp[i][j-1]   ->  prev[i]
# dp[i+1][j]   ->  curr[i+1]
# dp[i+1][j-1] ->  prev[i+1]

#ä¹Ÿå°±æ˜¯è¯´ï¼šå–jçš„æ—¶å€™å°±æ˜¯currï¼Œå–j-1çš„æ—¶å€™å°±æ˜¯prevï¼Œiçš„å€¼ä¿æŒä¸å˜

n = int(input())
s = input()

prev = [0] * n  
curr = [0] * n  

for j in range(1, n):  # å³ç«¯ç‚¹ j ä» 1 åˆ° n-1
    for i in range(j - 1, -1, -1):  # å·¦ç«¯ç‚¹ i é€†åºéå†
        if s[i] == s[j]:
            curr[i] = prev[i + 1] if i + 1 <= j - 1 else 0
        else:
            curr[i] = min(prev[i] + 1, curr[i + 1] + 1, prev[i + 1] + 2 if i + 1 <= j - 1 else float('inf'))

    prev, curr = curr, [0]*n  

print(prev[0])  # æœ€ç»ˆç­”æ¡ˆå­˜å‚¨åœ¨ prev[0] -> dp[0][j-1] -> dp[0][n-1]
```

### LeetCode:214.æœ€çŸ­å›æ–‡ä¸²

https://leetcode.cn/problems/shortest-palindrome/

> ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œä½ å¯ä»¥é€šè¿‡åœ¨å­—ç¬¦ä¸²å‰é¢æ·»åŠ å­—ç¬¦å°†å…¶è½¬æ¢ä¸ºå›æ–‡ä¸²ã€‚æ‰¾åˆ°å¹¶è¿”å›å¯ä»¥ç”¨è¿™ç§æ–¹å¼è½¬æ¢çš„æœ€çŸ­å›æ–‡ä¸²ã€‚
>
> ç¤ºä¾‹ 1ï¼š

>> è¾“å…¥ï¼šs = "aacecaaa"
>> è¾“å‡ºï¼š"aaacecaaa"

>ç¤ºä¾‹ 2ï¼š

>>è¾“å…¥ï¼šs = "abcd"
>>è¾“å‡ºï¼š"dcbabcd"
>
>æç¤ºï¼š
0 <= s.length <= 5 * 104
s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

æ³¨æ„æ•°æ®é‡ï¼Œé‡‡ç”¨dpæ¥é¢„å¤„ç†æ‰€æœ‰å­ä¸²æ˜¯å¦å›æ–‡ï¼Œç„¶åå†é€†å‘éå†jæ‰¾åˆ°ç¬¬ä¸€ä¸ª`s[0..j]`ä¸ºå›æ–‡å­ä¸²ï¼Œå°†åç¼€åè½¬åŠ åˆ°å‰æ–¹çš„æ€è·¯ä¼šè¶…æ—¶ï¼ˆåšäº†ç©ºé—´ä¼˜åŒ–è¿˜æ˜¯è¶…æ—¶ï¼‰

è¯¥é¢˜çš„å·§å¦™åšæ³•æ˜¯ï¼š

$$ æ‰¾å‡ºsçš„æœ€é•¿å›æ–‡å‰ç¼€å­ä¸² \rightarrow æ‰¾å‡ºs+reversed(s) çš„æœ€é•¿å…¬å…±å‰åç¼€ $$

æ­¤æ—¶å¯ä»¥é‡‡ç”¨KMPç®—æ³•ï¼Œæœ‰æ•ˆé™ä½äº†æ—¶é—´å¤æ‚åº¦ã€‚

```python
class Solution:
    def shortestPalindrome(self, s: str) -> str:
        ### KMPç®—æ³•ï¼ˆå®é™…ä¸Šåªç”¨åˆ°äº†get_nextå‡½æ•°ï¼‰
        def get_next(s):
            n=len(s)
            next=[-1]*n
            j=-1
            for i in range(1,n):
                while j!=-1 and s[i]!=s[j+1]:
                    j=next[j]
                if s[i]==s[j+1]:
                    j+=1
                next[i]=j
            return next
        
        s_rev=s+'#'+s[::-1]
        next=get_next(s_rev)
        length=next[-1]+1
        suf=s[length:]
        return suf[::-1]+s

        ### ä¼˜åŒ–ç©ºé—´çš„dpï¼ˆå‹ç¼©ä¸ºä¸¤ä¸ªdpæ»šåŠ¨æ•°ç»„ï¼‰
        # n=len(s)
        # pre, cur=[True]*n, [True]*n
        # first=[True]
        # for j in range(1,n):
        #     for i in range(j-1,-1,-1):
        #         cur[i]=pre[i+1] and s[i]==s[j]
        #     first.append(cur[0])
        #     pre,cur=cur,[True]*n
        # for j in range(n-1,-1,-1):
        #     if first[j]:
        #         return s[j+1:][::-1]+s
        # return ''
        
        ### æœªç©ºé—´ä¼˜åŒ–çš„dp
        # dp=[[True]*n for _ in range(n)]
        # for j in range(1,n):
        #     for i in range(j-1,-1,-1):
        #         dp[i][j]=dp[i+1][j-1] and s[i]==s[j]
        # # for i in dp:print(*i)
        # for j in range(n-1,-1,-1):
        #     if dp[0][j]:
        #         add=s[j+1:][::-1]
        #         s=add+s
        #         return s
        # return ''

```

## äºŒã€å›æ–‡å­åºåˆ—
**å­åºåˆ—** æ˜¯ä¸æ”¹å˜å‰©ä½™å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤æŸäº›å­—ç¬¦æˆ–è€…ä¸åˆ é™¤ä»»ä½•å­—ç¬¦å½¢æˆçš„ä¸€ä¸ªåºåˆ—ã€‚

### LeetCode:516.æœ€é•¿å›æ–‡å­åºåˆ—
> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€é•¿çš„å›æ–‡å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ã€‚
> >ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šs = "bbbab"
è¾“å‡ºï¼š4
è§£é‡Šï¼šä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º "bbbb" ã€‚
> 
> >ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šs = "cbbd"
è¾“å‡ºï¼š2
è§£é‡Šï¼šä¸€ä¸ªå¯èƒ½çš„æœ€é•¿å›æ–‡å­åºåˆ—ä¸º "bb" ã€‚
> 
> æç¤ºï¼š
1 <= s.length <= 1000
s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

#### 1.åŒºé—´dp
ç”¨æ•°å€¼äºŒç»´æ•°ç»„dpæ¥è¡¨ç¤ºæŸä¸ªåŒºé—´å†…æœ€é•¿çš„å›æ–‡å­åºåˆ—çš„é•¿åº¦ã€‚
`dp[i][j]`è¡¨ç¤ºä»`s[i]`åˆ°`s[j]`åŒºé—´èŒƒå›´å†…çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦ï¼Œé‚£ä¹ˆå½“`i>j`æ—¶`dp[i][j]=0`ï¼› å½“`i==j`æ—¶`dp[i][j]=1`ï¼›
å½“`i<j`æ—¶ï¼Œè€ƒè™‘åŒºé—´ä¸¤ç«¯ç‚¹ï¼šå¦‚æœ`s[i]==s[j]`ï¼Œé‚£ä¹ˆå°±å…¨éƒ¨è€ƒè™‘ï¼Œ`dp[i][j]=2+dp[i+1][j-1]`ï¼›åä¹‹åˆ™æŠ›å¼ƒä¸€ä¸ªç«¯ç‚¹ï¼Œ`dp[i][j]=max(dp[i+1][j],dp[i][j-1])`
è¿™é‡Œä»ç„¶é‡‡ç”¨ **éå†åŒºé—´é•¿åº¦Lå’Œå·¦ç«¯ç‚¹i** å’Œ **éå†å³ç«¯ç‚¹jå’Œåå‘å·¦ç«¯ç‚¹i** ä¸¤ç§æ–¹æ³•ã€‚
```python
def longestPalindromeSubseq(s: str) -> int:
    n=len(s)
    dp=[[0]*n for _ in range(n)]
    for i in range(n):
        dp[i][i]=1
    
    for L in range(2,n+1):
        for i in range(n):
            j=i+L-1
            if j>=n:
                break
                
            if s[i]==s[j]:
                dp[i][j]=2+dp[i+1][j-1]
            else:
                dp[i][j]=max(dp[i][j-1], dp[i+1][j])
        
    return dp[0][-1]
```
è¿™æ˜¯æ­£å‘jåå‘içš„æ–¹æ³•ã€‚
```python
def longestPalindromeSubseq(s: str) -> int:
    n=len(s)
    dp=[[0]*n for _ in range(n)]
    for j in range(n):
        for i in range(j,-1,-1):
            if i==j:
                dp[i][j]=1
            elif i>j:
                dp[i][j]=0
            elif i<j:
                if s[i]==s[j]:
                    dp[i][j]=2+dp[i+1][j-1]
                else:
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1])
    return dp[0][-1]
```

#### 2.é€’å½’
åŒæ ·ï¼Œæˆ‘ä»¬å–çš„ç»“æœæ˜¯`dp[0][-1]`ï¼Œæ•´ä½“æ€è·¯æ˜¯ä»å°åŒºé—´åˆ°å¤§åŒºé—´ï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥é‡‡ç”¨é€’å½’çš„æ–¹å¼ï¼š
```python
from functools import lru_cache
def longestPalindromeSubseq(s: str) -> int:
    @lru_cache(maxsize=None)
    def dfs(i,j):
        if i>j:
            return 0
        if i==j:
            return 1
        if s[i]==s[j]:
            return 2+dfs(i+1,j-1)
        return max(dfs(i+1,j), dfs(i,j-1))
    return dfs(0,len(s)-1)
```

### LeetCode:3472.è‡³å¤šKæ¬¡æ“ä½œåçš„æœ€é•¿å›æ–‡å­åºåˆ—
> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ•´æ•° kã€‚
åœ¨ä¸€æ¬¡æ“ä½œä¸­ï¼Œä½ å¯ä»¥å°†ä»»æ„ä½ç½®çš„å­—ç¬¦æ›¿æ¢ä¸ºå­—æ¯è¡¨ä¸­ç›¸é‚»çš„å­—ç¬¦ï¼ˆå­—æ¯è¡¨æ˜¯å¾ªç¯çš„ï¼Œå› æ­¤ 'z' çš„ä¸‹ä¸€ä¸ªå­—æ¯æ˜¯ 'a'ï¼‰ã€‚ä¾‹å¦‚ï¼Œå°† 'a' æ›¿æ¢ä¸ºä¸‹ä¸€ä¸ªå­—æ¯ç»“æœæ˜¯ 'b'ï¼Œå°† 'a' æ›¿æ¢ä¸ºä¸Šä¸€ä¸ªå­—æ¯ç»“æœæ˜¯ 'z'ï¼›åŒæ ·ï¼Œå°† 'z' æ›¿æ¢ä¸ºä¸‹ä¸€ä¸ªå­—æ¯ç»“æœæ˜¯ 'a'ï¼Œæ›¿æ¢ä¸ºä¸Šä¸€ä¸ªå­—æ¯ç»“æœæ˜¯ 'y'ã€‚
è¿”å›åœ¨è¿›è¡Œ **æœ€å¤š k æ¬¡æ“ä½œ** åï¼Œs çš„ **æœ€é•¿å›æ–‡å­åºåˆ—** çš„é•¿åº¦ã€‚
**å­åºåˆ—** æ˜¯ä¸€ä¸ª **éç©º** å­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡ **åˆ é™¤åŸå­—ç¬¦ä¸²ä¸­çš„æŸäº›å­—ç¬¦ï¼ˆæˆ–ä¸åˆ é™¤ä»»ä½•å­—ç¬¦ï¼‰å¹¶ä¿æŒå‰©ä½™å­—ç¬¦çš„ç›¸å¯¹é¡ºåº** å¾—åˆ°ã€‚
**å›æ–‡** æ˜¯æ­£ç€è¯»å’Œåç€è¯»éƒ½ç›¸åŒçš„å­—ç¬¦ä¸²ã€‚
> 
> >ç¤ºä¾‹ 1ï¼š
è¾“å…¥: s = "abced", k = 2
è¾“å‡º: 3
è§£é‡Š:
å°† s[1] æ›¿æ¢ä¸ºä¸‹ä¸€ä¸ªå­—æ¯ï¼Œå¾—åˆ° "acced"ã€‚
å°† s[4] æ›¿æ¢ä¸ºä¸Šä¸€ä¸ªå­—æ¯ï¼Œå¾—åˆ° "accec"ã€‚
å­åºåˆ— "ccc" å½¢æˆä¸€ä¸ªé•¿åº¦ä¸º 3 çš„å›æ–‡ï¼Œè¿™æ˜¯æœ€é•¿çš„å›æ–‡å­åºåˆ—ã€‚
>
> >ç¤ºä¾‹ 2ï¼š
è¾“å…¥: s = "aaazzz", k = 4
è¾“å‡º: 6
è§£é‡Š:
å°† s[0] æ›¿æ¢ä¸ºä¸Šä¸€ä¸ªå­—æ¯ï¼Œå¾—åˆ° "zaazzz"ã€‚
å°† s[4] æ›¿æ¢ä¸ºä¸‹ä¸€ä¸ªå­—æ¯ï¼Œå¾—åˆ° "zaazaz"ã€‚
å°† s[3] æ›¿æ¢ä¸ºä¸‹ä¸€ä¸ªå­—æ¯ï¼Œå¾—åˆ° "zaaaaz"ã€‚
æ•´ä¸ªå­—ç¬¦ä¸²å½¢æˆä¸€ä¸ªé•¿åº¦ä¸º 6 çš„å›æ–‡ã€‚
>
>æç¤º:
1 <= s.length <= 200
1 <= k <= 200
s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆã€‚

#### 1.åŒºé—´dp
è¿™é‡Œå¤šäº†ä¸€ä¸ªå˜é‡K,åœ¨dpä¸­æ–°æ·»ä¸€ç»´ä½œä¸ºkçš„dp.
```python
def longestPalindromicSubsequence(self, s: str, K: int) -> int:
    def min_steps(c1, c2):
        """
        è®¡ç®—å°†å­—ç¬¦c1å˜ä¸ºc2æ‰€éœ€çš„æœ€å°æ­¥æ•°ï¼Œè€ƒè™‘å­—æ¯è¡¨æ˜¯å¾ªç¯çš„ã€‚
        """
        diff = abs(ord(c1) - ord(c2))
        return min(diff, 26 - diff)

    def longestPalindromeSubseq(s):
        n = len(s)
        
        # dp[k][i][j]è¡¨ç¤ºåœ¨æœ€å¤šæ“ä½œkæ­¥çš„å‰æä¸‹ï¼Œs[i..j]çš„æœ€é•¿å›æ–‡å­åºåˆ—é•¿åº¦
        # æ³¨æ„ç¬¬ä¸€ä½çš„é•¿åº¦æ˜¯K+1ï¼Œå› ä¸ºè¦è€ƒè™‘æ“ä½œæ•°æ°å¥½æ˜¯Kçš„æƒ…å†µ
        dp = [[[0] * n for _ in range(n)] for _ in range(K+1)]
        
        # å¡«å……dpè¡¨
        for k in range(K+1):
            for j in range(n):
                for i in range(j,-1,-1):
                    if i==j:
                        dp[k][i][j]=1
                    else:
                        if s[i]==s[j]:
                            dp[k][i][j]=2+dp[k][i+1][j-1]
                        else:
                            cost=min_steps(s[i],s[j])
                            if cost<=k:
                                dp[k][i][j]=2+dp[k-cost][i+1][j-1]
                            dp[k][i][j]=max(dp[k][i][j],dp[k][i+1][j],dp[k][i][j-1])
        return dp[K][0][-1]
    return longestPalindromeSubseq(s)
```
#### 2.é€’å½’
```python
from functools import lru_cache
def longestPalindromicSubsequence(self, s: str, K: int) -> int:
    def min_steps(c1, c2):
        """
        è®¡ç®—å°†å­—ç¬¦c1å˜ä¸ºc2æ‰€éœ€çš„æœ€å°æ­¥æ•°ï¼Œè€ƒè™‘å­—æ¯è¡¨æ˜¯å¾ªç¯çš„ã€‚
        """
        diff = abs(ord(c1) - ord(c2))
        return min(diff, 26 - diff)

    @lru_cache(maxsize=None)
    def dfs(k,i,j):
        if i>j:
            return 0
        if i==j:
            return 1
        if s[i]==s[j]:
            return 2+dfs(k,i+1,j-1)
        cost=min_steps(s[i],s[j])
        if cost<=k:
            return max(2+dfs(k-cost,i+1,j-1), dfs(k,i+1,j), dfs(k,i,j-1))
        return max(dfs(k,i+1,j), dfs(k,i,j-1))
    
    n=len(s)
    ans=dfs(K,0,n-1)
    dfs.cache_clear() # é˜²æ­¢è¶…å†…å­˜
    return ans
```
