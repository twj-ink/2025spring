UltiCloud, you are the first one made me feel the magic of being loved.. and being cared. Please don't leave me alone...

You can't hear me, also, I have no rights or 'privileges' to force you to love me...I hope you can enjoy your EVERYDAY's life...

Love you.

Hope you can kiss me for real and I can lie in your warm hug. I am crying...

INK.(Black-Dirt(?))


Skip to content
Navigation Menu
bhrigu123
huffman-coding

Type / to search
Code
Issues
1
Pull requests
2
Actions
Projects
Security
Insights
Owner avatar
huffman-coding
Public
bhrigu123/huffman-coding
Go to file
t
Name		
bhrigu123
bhrigu123
Update README.md
e65c799
 Â· 
5 months ago
.gitignore
initial commit
9 years ago
README.md
Update README.md
5 months ago
huffman.py
minor changes and readme update
5 years ago
sample.txt
initial commit
9 years ago
useHuffman.py
readme update, path variable update
9 years ago
Repository files navigation
README
Python Implementaion of Huffman Coding
Explanation on YouTube video https://youtu.be/JCOph23TQTY. Was originally posted in blog article at https://www.bhrigu.dev/blog/huffman-coding-python-implementation

Consists compress and decompress function.

Testing / Running the program
Save / Clone the above repository
The repository consists of a sample text file of size 715kB
Run the python code useHuffman.py to compress & decompress the given sample file. For eg. open terminal and run python3 useHuffman.py
The above command will perform compression and decompression on the sample.txt file present here. Both the compressed and decompressed file will be present at the same location.
To run the code for compression of any other text file, edit the path variable in the useHuffman.py file.

For now, the decompress() function is to be called from the same object from which the compress() function was called. (as the encoding information is stored in the data members of the object only)

License
MIT License

Feel free to use this as per your needs. I'd really appreciate if you:

Cite the article in your published papers (eg as Srivastava, Bhrigu. 2017. Huffman coding Python implementation.)
Drop a note to captain.bhrigu@gmail.com
About
Python Implementaion of Huffman Coding - compression and decompression

Resources
 Readme
 Activity
Stars
 119 stars
Watchers
 7 watching
Forks
 67 forks
Report repository
Releases
No releases published
Packages
No packages published
Languages
Python
100.0%
Footer
Â© 2025 GitHub, Inc.
Footer navigation
Terms
Privacy
Security
Status
Docs
Contact
Manage cookies
Do not share my personal information
Repository search results



Skip to content
Navigation Menu
bhrigu123
huffman-coding

Type / to search
Code
Issues
1
Pull requests
2
Actions
Projects
Security
Insights
Owner avatar
huffman-coding
Public
bhrigu123/huffman-coding
Go to file
t
Name		
bhrigu123
bhrigu123
Update README.md
e65c799
 Â· 
5 months ago
.gitignore
initial commit
9 years ago
README.md
Update README.md
5 months ago
huffman.py
minor changes and readme update
5 years ago
sample.txt
initial commit
9 years ago
useHuffman.py
readme update, path variable update
9 years ago
Repository files navigation
README
Python Implementaion of Huffman Coding
Explanation on YouTube video https://youtu.be/JCOph23TQTY. Was originally posted in blog article at https://www.bhrigu.dev/blog/huffman-coding-python-implementation

Consists compress and decompress function.

Testing / Running the program
Save / Clone the above repository
The repository consists of a sample text file of size 715kB
Run the python code useHuffman.py to compress & decompress the given sample file. For eg. open terminal and run python3 useHuffman.py
The above command will perform compression and decompression on the sample.txt file present here. Both the compressed and decompressed file will be present at the same location.
To run the code for compression of any other text file, edit the path variable in the useHuffman.py file.

For now, the decompress() function is to be called from the same object from which the compress() function was called. (as the encoding information is stored in the data members of the object only)

License
MIT License

Feel free to use this as per your needs. I'd really appreciate if you:

Cite the article in your published papers (eg as Srivastava, Bhrigu. 2017. Huffman coding Python implementation.)
Drop a note to captain.bhrigu@gmail.com
About
Python Implementaion of Huffman Coding - compression and decompression

Resources
 Readme
 Activity
Stars
 119 stars
Watchers
 7 watching
Forks
 67 forks
Report repository
Releases
No releases published
Packages
No packages published
Languages
Python
100.0%
Footer
Â© 2025 GitHub, Inc.
Footer navigation
Terms
Privacy
Security
Status
Docs
Contact
Manage cookies
Do not share my personal information
Repository search results


# Week6~8 ğŸŒ²ç®—

Updated 1428 GMT+8 Apr 8, 2025

2025 spring, Complied by Hongfei Yan



> è¯´æ˜ï¼š
>
> 20250401 Week7è¯´æ˜ï¼šè¯¾ä»¶ä¸­ç¼–ç¨‹é¢˜ç›®ï¼Œâ€œç¤ºä¾‹ã€‚ã€‚ã€‚â€æ˜¯å­¦ä¹ äº†æ¦‚å¿µï¼Œé¡ºä¾¿çœ‹æ‡‚ç¤ºä¾‹ç¨‹åºã€‚â€œç»ƒä¹ ã€‚ã€‚ã€‚â€æ˜¯å¸Œæœ›å…ˆä¸çœ‹ç­”æ¡ˆï¼Œè‡ªå·±å°è¯•å…ˆå®Œæˆã€‚
>
> 20250326 Week6è¯´æ˜ï¼šä¸æ ‘ç›¸å…³çš„é¢˜ç›®ï¼Œè¿˜æŒºéš¾çš„ï¼Œå› ä¸ºé€šå¸¸æ¶‰åŠåˆ°æŠŠè¾“å…¥å­—ç¬¦ä¸²parse/buildæˆä¸€æ£µæ ‘ï¼Œè¿™ä¸ªè¿‡ç¨‹æ¯”è¾ƒéº»çƒ¦ï¼Œé€šå¸¸ç”¨åˆ°stack+dfsã€‚ç„¶åå†æŒ‰ç…§é¢˜é¢è¦æ±‚è¾“å‡ºã€‚
>
> 1ï¼‰è®¡åˆ’ä¸€è®²åŒ…æ‹¬æ ‘çš„ç›¸å…³æ¦‚å¿µã€è¡¨ç¤ºæ–¹æ³•ï¼›äºŒè®²æ ‘çš„æ„å»º/è§£æã€éå†ã€å“ˆå¤«æ›¼ç®—æ³•ï¼›ä¸‰è®²å †å®ç°ã€AVLå®ç°ã€å¹¶æŸ¥é›†ã€‚
>
> 2ï¼‰mdæ–‡ä»¶æœ‰ç›®å½•ï¼Œå†…å®¹æ¨è¿›æ€è·¯æ˜¯åŸç†å­¦ä¹ +ç¼–ç¨‹é¢˜ç›®å®é™…ã€‚



# å‰è¨€ï¼šæ ‘å½¢ç»“æ„å­¦ä¹ æ–¹æ³•

åœ¨è®¡ç®—æœºç§‘å­¦é¢†åŸŸå†…ï¼Œæ ‘å½¢ç»“æ„æ˜¯æœ€ä¸ºå…³é”®åŒæ—¶ä¹Ÿæ˜¯æŒæ¡éš¾åº¦è¾ƒé«˜çš„æ¦‚å¿µä¹‹ä¸€ã€‚ä¸åŒäºè®¡ç®—æœºæ¦‚è®ºï¼Œæ•°æ®ç»“æ„ä¸ç®—æ³•çš„å­¦ä¹ ä¸ä»…éœ€è¦å€ŸåŠ©é¢å‘å¯¹è±¡ç¼–ç¨‹çš„æŠ½è±¡å’Œå¤ç”¨ç†å¿µï¼Œè¿˜è¦é€šè¿‡<mark>ä½¿ç”¨é“¾è¡¨æ¥è¡¨è¾¾æ ‘ç»“æ„ï¼Œå¹¶é‡‡ç”¨é€’å½’çš„æ–¹æ³•è¿›è¡Œæ ‘çš„éå†</mark>ã€‚åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­ï¼Œç»å…¸ç®—æ³•å’Œç¼–ç¨‹æŠ€å·§çš„åº”ç”¨è‡³å…³é‡è¦ï¼Œè€Œå¯¹äºæ—¶é—´å¤æ‚åº¦çš„ä¼˜åŒ–æŠ€å·§ä¹Ÿæ˜¯å¿…ä¸å¯å°‘çš„ã€‚

å³ä¾¿æ˜¯å‚åŠ è¿‡è®¡ç®—æœºæ¦‚è®ºæé«˜ç­çš„å­¦ç”Ÿï¼Œä¹Ÿå¯èƒ½ä¼šå‘ç°æ ‘ç»“æ„çš„å­¦ä¹ é¢‡å…·æŒ‘æˆ˜ã€‚ä¸€äº›å­¦ç”Ÿå¯èƒ½ä¼šé€šè¿‡ç±»æ¯”å’Œç»¼åˆçš„æ–¹å¼æ¥ä¿ƒè¿›ç†è§£ï¼Œæ¯”å¦‚é€šè¿‡æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰æ¥æ·±å…¥ç†è§£æ ‘çš„å‰åºéå†å’Œååºéå†ï¼›æœ‰çš„å­¦ç”Ÿå¯èƒ½ä¼šé€šè¿‡åŸè¯µè¯—æ­Œæ¥æ¿€åŠ±è‡ªå·±ï¼›è¿˜æœ‰çš„å­¦ç”Ÿåˆ™æŠ•å…¥å¤§é‡æ—¶é—´å¤ç°ç»å…¸ç®—æ³•ï¼Œæˆ–åœ¨é›†æˆå¼€å‘ç¯å¢ƒï¼ˆIDEï¼‰ä¸­æ¢ç´¢å¦‚ä½•è°ƒè¯•é€’å½’ç¨‹åºã€‚

æ•™æä¸­ä¸å…å­˜åœ¨ä¸€äº›å†…å®¹é—æ¼æˆ–é€»è¾‘ä¸è¿è´¯çš„éƒ¨åˆ†ï¼Œå› æ­¤æˆ‘ä»¬åˆ¶ä½œçš„è¯¾ä»¶ä¹Ÿåœ¨æŒç»­æ›´æ–°ä»¥è¡¥å……å’Œå®Œå–„è¿™äº›å†…å®¹ã€‚
é¢„è®¡éœ€è¦è‡³å°‘ä¸‰å‘¨æŒæ¡æ ‘ç»“æ„çš„ç›¸å…³çŸ¥è¯†ã€‚

> ã€ŠPythonæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹ è¿™æœ¬ä¹¦ï¼Œæ ‘è¿™ä¸€ç« æ²¡æœ‰è®²generic treeï¼Œç›´æ¥å°±åˆ°binary treeäº†ã€‚ä¹‹å‰æ„Ÿè§‰å®ƒçš„ ç®—æ³•åˆ†æ é‚£ç« ä¸å¥½ï¼Œç°åœ¨æ„Ÿè§‰æ ‘è¿™ç« ä¹Ÿå·®å¼ºäººæ„ï¼Œå†™çš„æ¯”è¾ƒéšæ„ã€‚æ ‘æœ‰ä¸ªé‡è¦çš„åº”ç”¨ï¼Œæ–‡æœ¬å‹ç¼©â€”â€”å“ˆå¤«æ›¼ç¼–ç ã€‚åœ¨è¯¥ä¹¦ä¸­ï¼Œæœä¸åˆ°â€œå“ˆå¤«æ›¼â€ï¼Œä¹Ÿæœä¸åˆ°"Huffman"ã€‚
>



**Q: æœ‰æ²¡æœ‰ç›´æ¥çš„ç†è§£**ï¼Œå°±æ˜¯æ¯”å¦‚ç»™æˆ‘ä¸€æ£µæ ‘ï¼Œæˆ‘å¯ä»¥ç›´æ¥ç”¨éå†æ–¹æ³•ç»™å‡ºä¸­åºå’Œååº?

> å‰åºéå†å°±æ˜¯dfsåºåˆ—ï¼Œååºçš„ååºæ˜¯ä¸æ˜¯å°±æ˜¯åŸæ ‘ä¼˜å…ˆèµ°å³è¾¹çš„dfsã€‚
>
> ä½ çš„é—®é¢˜æ¶‰åŠåˆ°æ ‘çš„éå†æ–¹æ³•ä»¥åŠå®ƒä»¬ä¹‹é—´çš„å…³ç³»ã€‚æˆ‘ä»¬æ¥é€ä¸€åˆ†æï¼š
>



> **1. æ ‘çš„éå†æ–¹æ³•**
>
> å¯¹äºä¸€æ£µæ ‘ï¼ˆå°¤å…¶æ˜¯äºŒå‰æ ‘ï¼‰ï¼Œå¸¸è§çš„éå†æ–¹æ³•æœ‰ä¸‰ç§ï¼š
>
> - **å‰åºéå†**ï¼ˆPreorderï¼‰ï¼šæ ¹ -> å·¦å­æ ‘ -> å³å­æ ‘
>- **ä¸­åºéå†**ï¼ˆInorderï¼‰ï¼šå·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘
> - **ååºéå†**ï¼ˆPostorderï¼‰ï¼šå·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹
>
> è¿™äº›éå†æ–¹æ³•å¯ä»¥é€šè¿‡é€’å½’æˆ–è¿­ä»£å®ç°ï¼Œæœ¬è´¨ä¸Šæ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰çš„ä¸åŒå˜ä½“ã€‚
>
> ---
>
>**2. å‰åºéå†å’ŒDFSçš„å…³ç³»**
>>
>ä½ æåˆ°â€œå‰åºéå†å°±æ˜¯DFSåºåˆ—â€ï¼Œè¿™æ˜¯æ­£ç¡®çš„ï¼  
> - **å‰åºéå†**çš„é¡ºåºæ­£æ˜¯æ ‡å‡†çš„æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰è®¿é—®èŠ‚ç‚¹çš„é¡ºåºã€‚
> - åœ¨DFSè¿‡ç¨‹ä¸­ï¼Œç¬¬ä¸€æ¬¡è®¿é—®æŸä¸ªèŠ‚ç‚¹æ—¶å°±è®°å½•å®ƒï¼Œè¿™å°±æ˜¯å‰åºéå†çš„ç»“æœã€‚
> 
>ä¾‹å¦‚ï¼Œç»™å®šä»¥ä¸‹äºŒå‰æ ‘ï¼š
> ```
>     A
>    / \
>   B   C
>  / \
>D   E
> ```
> å‰åºéå†ç»“æœæ˜¯ï¼š`A -> B -> D -> E -> C`
> 
>è¿™æ­£æ˜¯DFSä»æ ¹èŠ‚ç‚¹å¼€å§‹è®¿é—®çš„é¡ºåºã€‚
> 
> ---
> 
> **3. ååºéå†çš„ååºä¸DFSçš„å…³ç³»**
> 
> ä½ æåˆ°â€œååºçš„ååºæ˜¯ä¸æ˜¯å°±æ˜¯åŸæ ‘ä¼˜å…ˆèµ°å³è¾¹çš„DFSâ€ï¼Œè¿™ä¸ªè¯´æ³•åœ¨æŸäº›æƒ…å†µä¸‹æ˜¯å¯¹çš„ï¼Œä½†éœ€è¦å…·ä½“åˆ†æã€‚
> 
> **ååºéå†çš„ç‰¹ç‚¹**
> 
>ååºéå†çš„é¡ºåºæ˜¯ï¼šå…ˆè®¿é—®å·¦å­æ ‘ï¼Œå†è®¿é—®å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ã€‚  
> ä»¥ä¸Šé¢çš„æ ‘ä¸ºä¾‹ï¼Œååºéå†ç»“æœæ˜¯ï¼š`D -> E -> B -> C -> A`
>
> **ååºéå†çš„ååº**
>
> å°†ååºéå†ç»“æœåè½¬ï¼Œå¾—åˆ°ï¼š`A -> C -> B -> E -> D`
>
> **ä¼˜å…ˆèµ°å³è¾¹çš„DFS**
>
> å¦‚æœæˆ‘ä»¬åœ¨DFSè¿‡ç¨‹ä¸­ä¼˜å…ˆè®¿é—®å³å­æ ‘ï¼ˆå³å…ˆè®¿é—®å³å­æ ‘å†è®¿é—®å·¦å­æ ‘ï¼‰ï¼Œé‚£ä¹ˆå¾—åˆ°çš„è®¿é—®é¡ºåºæ˜¯ï¼š`A -> C -> B -> E -> D`
>
> å¯ä»¥çœ‹åˆ°ï¼Œååºéå†çš„ååºç¡®å®ç­‰äºä¼˜å…ˆèµ°å³è¾¹çš„DFSçš„é¡ºåºã€‚
> 
>---
> 
>**4. ä¸­åºéå†**
> 
>ä¸­åºéå†çš„é¡ºåºæ˜¯ï¼šå·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘ã€‚  
> ä»¥ä¸Šé¢çš„æ ‘ä¸ºä¾‹ï¼Œä¸­åºéå†ç»“æœæ˜¯ï¼š`D -> B -> E -> A -> C`
>
> ä¸­åºéå†æ²¡æœ‰ç›´æ¥ç­‰ä»·äºæŸç§DFSé¡ºåºï¼Œå› ä¸ºå®ƒçš„é¡ºåºä¾èµ–äºå·¦å­æ ‘ã€æ ¹ã€å³å­æ ‘çš„ç‰¹å®šæ’åˆ—ã€‚
>
> ---
>
> **æ€»ç»“**
>
> - **å‰åºéå†** = æ ‡å‡†DFSè®¿é—®é¡ºåºã€‚
>- **ååºéå†çš„ååº** = ä¼˜å…ˆèµ°å³è¾¹çš„DFSè®¿é—®é¡ºåºã€‚
> - **ä¸­åºéå†** = å·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘ï¼Œæ²¡æœ‰ç›´æ¥ç­‰ä»·äºæŸç§DFSé¡ºåºã€‚
> 



> ã€å¾€å¹´åŒå­¦ä½œä¸šæ€»ç»“ã€‘ï¼š
>
> æ ‘çŠ¶æ•°ç»„æƒ¨é­å†…å­˜è¶…å‡ºï¼Œç°å­¦åˆ†æ²»ä¾æ—§é¥é¥é¢†å…ˆã€‚
>åˆæ³•å‡ºæ ˆåºåˆ—ç®€å•æ¨¡æ‹Ÿï¼Œæ ‘èŠ‚æ— æ ‘æ±‚äºŒå‰æ ‘æ·±åº¦ã€‚
> åŒç«¯é˜Ÿåˆ—è¿˜æ˜¯å®å®å·´å£«ï¼Œæ³¢å…°è¡¨è¾¾å¼ä»æ¸¸åˆƒæœ‰ä½™ã€‚
>ä¸­åºè½¬ååºå†™äº†ä¸¤å°æ—¶ï¼Œæ°´å¹³ä¸å¤Ÿè¿˜å¾—å¤šå®¶ç»ƒä¹ ï¼
> 
>
> 
>æœ¬å‘¨ç®—æ˜¯çœŸæ­£è¿›å…¥äº†æ•°ç®—çš„é‡ç‚¹ç« èŠ‚ï¼Œéš¾åº¦è‚‰çœ¼å¯è§åœ°å¢é•¿ã€‚ç™¾å­—ä»¤ä¸€é¦–ï¼ŒèŠè¡¨æ„Ÿå—ã€‚
> æ ‘
>ä¸ç†Ÿ
>çœŸå¯æ¶
>>æ— èƒ½ç‹‚æ€’
>æ‰¾å¤§ä½¬æ±‚åŠ©
> WAç™¾èˆ¬è‹¦æ¥š
> å¿ƒèŒ«ç„¶æ‹”å‰‘å››é¡¾
> æ ˆä¸é˜Ÿåˆ—å‰åå¼¹å‡º
>å¥½åœ¨å­¦ä¸œè¥¿å¯ä»¥é¡¿æ‚Ÿ
> å„ç§åºè¡¨è¾¾å¼éœ€è¦å…³æ³¨
>é€æ¸è§£å†³äº†æœ¬å‘¨é¢˜ç›®
> å°¤å…¶å†™æ ˆæœ‰å¦‚ç¥åŠ©
>ä½†æ²¡åˆ°ç²¾é€šç¨‹åº¦
> é€’å½’å¾ªç¯æ¬¡æ•°
>ACè¶£å‘³è¶³
> ä¹ä¸æ€èœ€
> åˆšä¸Šè·¯
> åˆ»è‹¦
>èµ´ 





# ä¸€ã€ğŸŒ²çš„æ¦‚å¿µå’Œè¡¨ç¤ºæ–¹æ³•

## 0 Recap 

### 0.1 é€’å½’ & BFS

é‰´äºå„ç­åœ¨ã€Šè®¡ç®—æ¦‚è®ºBã€‹è¯¾ç¨‹ä¸­çš„è¿›åº¦ä¸ä¸€ï¼Œå„ä½è€å¸ˆå¯¹äºã€Šè®¡ç®—æ¦‚è®ºã€‹å’Œã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•ã€‹å†…å®¹çš„è¦†ç›–å’Œç†è§£ä¹Ÿå­˜åœ¨å·®å¼‚ï¼Œæˆ‘ä»¬å»ºè®®å¤ä¹ é€’å½’å’ŒBFSçš„ç›¸å…³å†…å®¹ã€‚

1ï¼‰<mark>**é€’å½’**æ˜¯æ•°ç®—ä¸­ä¸å¯æˆ–ç¼ºçš„æ ¸å¿ƒæŠ€èƒ½</mark>ï¼Œå¼ºçƒˆæ¨èä¼˜å…ˆæŒæ¡ã€‚å¯ä»¥å‚è€ƒ https://github.com/GMyhf/2024fall-cs101/blob/main/20241029_recursion.md

2ï¼‰<mark>**é˜Ÿåˆ—**åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ä¸­æœ‰ç€å¹¿æ³›çš„åº”ç”¨</mark>ã€‚è€ƒè™‘åˆ°å…¶ä»–ç­çº§å¯èƒ½å°šæœªè®²æˆæœç´¢ç®—æ³•ï¼Œæˆ‘ä»¬æä¾›å­¦ä¹ èµ„æºï¼Œhttps://github.com/GMyhf/2024fall-cs101/blob/main/20241119_searching.md



### 0.2ç”¨OOPå†™ç¨‹åº

æ¥ä¸‹æ¥å¼€å§‹å­¦ä¹ æ ‘ï¼Œæœ‰æ—¶ç¨‹åºä¼šç»™å‡ºç±»çš„å®ç°ä»£ç ã€‚å¤ä¹ ä¸€ä¸ªç±»å†™æ³•çš„å°ç¨‹åºï¼Œå¯ä»¥debugæ¨¡å¼è¿è¡Œï¼Œæˆ–è€… https://pythontutor.com å¯è§†åŒ–è¿è¡Œï¼Œè¾…åŠ©ç†è§£ã€‚ç±»å®ç°ç¨‹åºï¼Œè¡¥å……ç¼ºå¤±è¡Œä»£ç ã€‚æ˜¯ç¬”è¯•ä¸­å¿…è€ƒçš„é¢˜ç›®ã€‚

OOP çš„å†™æ³•å±äºè¯­æ³•èŒƒç•´ï¼Œå¯å‚çœ‹ https://www.runoob.com/python3/python3-class.html

æ•°ç®—çš„ç²¾åæ˜¯å¤åˆ¶ï¼ˆç±»çš„ç²¾åæ˜¯å¤åˆ¶ï¼‰ï¼Œä¸éœ€è¦æ·±æ‹·è´ï¼Œ<mark>åªè¦åˆ›å»ºå¤šä¸ªå¯¹è±¡ï¼Œå°±æœ‰å„è‡ªçš„å†…å­˜ç©ºé—´</mark>ã€‚ä¾‹å¦‚ä¸‹é¢å¹¶æŸ¥é›†çš„ä¾‹å­ï¼Œåˆ›å»ºäº†A, Bä¸¤ä¸ªå¯¹è±¡ï¼ŒAçš„ä¿®æ”¹ä¸å½±å“Bçš„ã€‚å¹¶æŸ¥é›†çš„å†…å®¹åœ¨ ä¸‰.7éƒ¨åˆ†ã€‚

```python
class DisjSet:
    def __init__(self, n):
        # Constructor to create and
        # initialize sets of n items
        self.rank = [1] * n
        self.parent = [i for i in range(n)]

    def find(self, x):
        # Find the root of the set in which element x belongs
        if self.parent[x] != x:
            # Path compression: Make the parent of x the root of its set
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        # Perform union of two sets
        x_root = self.find(x)
        y_root = self.find(y)

        if x_root == y_root:
            return

        # Attach smaller rank tree under root of higher rank tree
        if self.rank[x_root] < self.rank[y_root]:
            self.parent[x_root] = y_root
        elif self.rank[x_root] > self.rank[y_root]:
            self.parent[y_root] = x_root
        else:
            self.parent[y_root] = x_root
            self.rank[x_root] += 1


if __name__ == '__main__':
    A = DisjSet(5)
    B = DisjSet(5)

    A.union(0, 1)
    A.union(2, 3)

    print(A.rank)  # Output: [2, 1, 2, 1, 1]
    print(A.parent)  # Output: [0, 0, 2, 2, 4]
    print(B.rank)  # Output: [1, 1, 1, 1, 1]
    print(B.parent)  # Output: [0, 1, 2, 3, 4]

```



## 1 æœ¯è¯­Notations

**Q. è¯·è®²è§£æ•°æ®ç»“æ„ä¸­çš„æ ‘**

> **æ•°æ®ç»“æ„ä¸­çš„æ ‘**
>
> **æ ‘ï¼ˆTreeï¼‰** æ˜¯ä¸€ç§é‡è¦çš„éçº¿æ€§æ•°æ®ç»“æ„ï¼Œå®ƒç”±**èŠ‚ç‚¹ï¼ˆNodeï¼‰** ç»„æˆï¼ŒèŠ‚ç‚¹ä¹‹é—´å…·æœ‰**å±‚çº§å…³ç³»**ã€‚æ ‘ç»“æ„å¹¿æ³›åº”ç”¨äºè®¡ç®—æœºç§‘å­¦é¢†åŸŸï¼Œå¦‚æ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“ç´¢å¼•ã€æœç´¢ç®—æ³•ç­‰ã€‚
>
> ---
>
> **1. æ ‘çš„åŸºæœ¬æ¦‚å¿µ**
>
> **(1) èŠ‚ç‚¹çš„ç»„æˆ**
>
> æ¯ä¸ªèŠ‚ç‚¹é€šå¸¸åŒ…å«ï¼š
> - **å€¼ï¼ˆValueï¼‰**ï¼šå­˜å‚¨çš„æ•°æ®ã€‚
> - **å­èŠ‚ç‚¹ï¼ˆChildrenï¼‰**ï¼šæŒ‡å‘å…¶ä»–èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
> - **çˆ¶èŠ‚ç‚¹ï¼ˆParentï¼‰**ï¼šæŒ‡å‘å…¶ä¸Šçº§èŠ‚ç‚¹çš„æŒ‡é’ˆï¼ˆæ ¹èŠ‚ç‚¹é™¤å¤–ï¼‰ã€‚
> - **åº¦ï¼ˆDegreeï¼‰**ï¼šèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ã€‚
> - **æ·±åº¦ï¼ˆDepthï¼‰**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ã€‚
> - **é«˜åº¦ï¼ˆHeightï¼‰**ï¼šä»å½“å‰èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„é•¿åº¦ã€‚
>
> **(2) æ ‘çš„æœ¯è¯­**
>
> - **æ ¹èŠ‚ç‚¹ï¼ˆRootï¼‰**ï¼šæ ‘çš„èµ·å§‹èŠ‚ç‚¹ï¼Œæ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚
> - **å¶å­èŠ‚ç‚¹ï¼ˆLeafï¼‰**ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
> - **å­æ ‘ï¼ˆSubtreeï¼‰**ï¼šä»¥æŸä¸ªèŠ‚ç‚¹ä¸ºæ ¹çš„éƒ¨åˆ†æ ‘ã€‚
> - **å±‚çº§ï¼ˆLevelï¼‰**ï¼šä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œæ ¹ä¸ºç¬¬ 0 å±‚ï¼Œæ ¹çš„å­èŠ‚ç‚¹ä¸ºç¬¬ 1 å±‚ï¼Œä»¥æ­¤ç±»æ¨ã€‚
> - **èŠ‚ç‚¹é—´å…³ç³»**ï¼šçˆ¶èŠ‚ç‚¹ã€å­èŠ‚ç‚¹ã€å…„å¼ŸèŠ‚ç‚¹ã€ç¥–å…ˆèŠ‚ç‚¹ã€åä»£èŠ‚ç‚¹ç­‰ã€‚
>
> ---
>
> **2. æ ‘çš„åˆ†ç±»**
>
> **(1) æ™®é€šæ ‘**
>
> æ™®é€šæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰ä»»æ„å¤šä¸ªå­èŠ‚ç‚¹ã€‚
>
> **(2) äºŒå‰æ ‘ï¼ˆBinary Treeï¼‰**
>
> äºŒå‰æ ‘æ˜¯æ ‘çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰**ä¸¤ä¸ªå­èŠ‚ç‚¹**ï¼š
> - **æ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰**ï¼šæ‰€æœ‰éå¶å­èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚
> - **å®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰**ï¼šåªæœ‰æœ€åä¸€å±‚å¯ä»¥ä¸æ»¡ï¼Œå¹¶ä¸”èŠ‚ç‚¹ä»å·¦åˆ°å³æ’åˆ—ã€‚
> - **å¹³è¡¡äºŒå‰æ ‘ï¼ˆBalanced Binary Treeï¼‰**ï¼šå·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡ 1ï¼Œå¦‚ AVL æ ‘ã€‚
> - **äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼ŒBSTï¼‰**ï¼šå¯¹äºä»»æ„èŠ‚ç‚¹ï¼Œå·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å°äºè¯¥èŠ‚ç‚¹å€¼ï¼Œå³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å¤§äºè¯¥èŠ‚ç‚¹å€¼ã€‚
>
> **(3) ç‰¹æ®Šæ ‘**
>
> - **å¹³è¡¡æœç´¢æ ‘ï¼ˆBalanced Search Treeï¼‰**ï¼šå¦‚ AVL æ ‘ã€çº¢é»‘æ ‘ï¼ˆRed-Black Treeï¼‰ã€‚
> - **B æ ‘ï¼ˆB-Treeï¼‰** å’Œ **B+ æ ‘ï¼ˆB+ Treeï¼‰**ï¼šç”¨äºæ•°æ®åº“ç´¢å¼•ã€‚
> - **Trie æ ‘ï¼ˆå‰ç¼€æ ‘ï¼‰**ï¼šç”¨äºå­—ç¬¦ä¸²å­˜å‚¨å’Œæœç´¢ã€‚ä¾‹å¦‚ï¼š<mark>OJçš„æŒ‰ç…§æ ‡é¢˜æœç´¢åŠŸèƒ½</mark>
> - **å †ï¼ˆHeapï¼‰**ï¼šå¦‚æœ€å¤§å †ï¼ˆMax Heapï¼‰ã€æœ€å°å †ï¼ˆMin Heapï¼‰ï¼Œç”¨äºä¼˜å…ˆé˜Ÿåˆ—ã€‚
>
> ---
>
> **3. æ ‘çš„åŸºæœ¬æ“ä½œ**
>
> æ ‘çš„å¸¸è§æ“ä½œåŒ…æ‹¬ï¼š
> 1. **æ’å…¥ï¼ˆInsertionï¼‰**
> 2. **åˆ é™¤ï¼ˆDeletionï¼‰**
> 3. **æŸ¥æ‰¾ï¼ˆSearchï¼‰**
> 4. **éå†ï¼ˆTraversalï¼‰**ï¼š
>    - **æ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰**ï¼š
>      - **å‰åºéå†ï¼ˆPreorderï¼‰**ï¼šæ ¹ â†’ å·¦ â†’ å³
>      - **ä¸­åºéå†ï¼ˆInorderï¼‰**ï¼šå·¦ â†’ æ ¹ â†’ å³ï¼ˆBST ä¸­åºéå†ç»“æœä¸ºæœ‰åºæ•°ç»„ï¼‰
>      - **ååºéå†ï¼ˆPostorderï¼‰**ï¼šå·¦ â†’ å³ â†’ æ ¹
>    - **å¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰**ï¼ˆå±‚åºéå†ï¼‰ï¼šæŒ‰å±‚ä»å·¦åˆ°å³ä¾æ¬¡éå†ã€‚
>
> ---
>
> **4. æ ‘çš„åº”ç”¨**
>
> - **æ–‡ä»¶ç³»ç»Ÿ**ï¼ˆç›®å½•ç»“æ„ï¼‰
> - **æ•°æ®åº“ç´¢å¼•**ï¼ˆB æ ‘ã€B+ æ ‘ï¼‰
> - **ç¼–è¯‘å™¨**ï¼ˆè¯­æ³•æ ‘ã€æŠ½è±¡è¯­æ³•æ ‘ ASTï¼‰
> - **ç½‘ç»œè·¯ç”±**ï¼ˆTrie æ ‘ï¼‰
> - **äººå·¥æ™ºèƒ½**ï¼ˆæœç´¢æ ‘ã€å†³ç­–æ ‘ï¼‰
> - **æ•°æ®å‹ç¼©**ï¼ˆHuffman æ ‘ï¼‰
>
> ---
>
> **5. æ ‘çš„ Python å®ç°**
>
> **(1) äºŒå‰æ ‘çš„åŸºæœ¬å®ç°**
>
> ```python
> class TreeNode:
>     def __init__(self, value):
>         self.value = value
>         self.left = None
>         self.right = None
> 
> # åˆ›å»ºäºŒå‰æ ‘
> root = TreeNode(1)
> root.left = TreeNode(2)
> root.right = TreeNode(3)
> root.left.left = TreeNode(4)
> root.left.right = TreeNode(5)
> ```
>
> **(2) äºŒå‰æ ‘çš„éå†**
>
> ```python
> # å‰åºéå†
> def preorder_traversal(node):
>     if node:
>         print(node.value, end=" ")
>         preorder_traversal(node.left)
>         preorder_traversal(node.right)
> 
> # ä¸­åºéå†
> def inorder_traversal(node):
>     if node:
>         inorder_traversal(node.left)
>         print(node.value, end=" ")
>         inorder_traversal(node.right)
> 
> # ååºéå†
> def postorder_traversal(node):
>     if node:
>         postorder_traversal(node.left)
>         postorder_traversal(node.right)
>         print(node.value, end=" ")
> 
> print("å‰åºéå†:")
> preorder_traversal(root)
> print("\nä¸­åºéå†:")
> inorder_traversal(root)
> print("\nååºéå†:")
> postorder_traversal(root)
> ```
>
> ---
>
> **æ€»ç»“**
>
> - **æ ‘æ˜¯ä¸€ç§å±‚çº§ç»“æ„çš„æ•°æ®ç»“æ„ï¼Œé€‚ç”¨äºå¤šç§åº”ç”¨åœºæ™¯ã€‚**
> - **äºŒå‰æ ‘æ˜¯æœ€å¸¸è§çš„æ ‘ç±»å‹ï¼Œå…·æœ‰å¤šç§å˜ä½“ï¼ˆå¦‚ BSTã€AVL æ ‘ã€çº¢é»‘æ ‘ï¼‰ã€‚**
> - **æ ‘çš„éå†æ–¹å¼ä¸»è¦åŒ…æ‹¬ DFSï¼ˆå‰åºã€ä¸­åºã€ååºï¼‰å’Œ BFSï¼ˆå±‚åºéå†ï¼‰ã€‚**
> - **æ ‘åœ¨æ•°æ®åº“ã€ç¼–è¯‘å™¨ã€æœç´¢ç®—æ³•ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚**
>



æ ‘ç®—è¦†ç›–çš„å†…å®¹å’ŒçŸ¥è¯†ç‚¹æ€»ç»“å¦‚ä¸‹ï¼šæ ‘çš„çŸ¥è¯†å›¾è°±ã€‚

```mermaid
mindmap
  root(Generic Tree)
    Notations{{**NOTATIONS**}}
    	Node,Edge
    	Root,Subtree
    	Parent,Children,Sibling,Leaf
    	Path: Level,Height,Depth
      
    Representation{{**REPRESENTATION**}}
      Nested Parentheses
      Node-Based
      Indented Tree
      Adjacency List
      	Disjoint Set
      	Trie
      
    Binary Tree{{**Binary Tree**}}
      Applications
      	Parse Tree
      	Tree Traversals
      	Huffman
      Priority Queues with Binary Heaps
      Binary Search Tree
      AVL Tree
      Segment Tree,BIT
      *KD Tree
```

<center>æ ‘çš„çŸ¥è¯†å›¾è°±</center>



**ğŸŒ²çš„ç¤ºä¾‹**ï¼Œæ ‘é€‚åˆè¡¨ç¤ºå±‚çº§ç»“æ„ï¼Œä¾‹å¦‚ï¼šæˆ‘çš„githubä¸­<mark>æ•°ç®—é¢˜è§£</mark>çš„åˆ†å¸ƒ, https://github.com/GMyhf

```mermaid
graph TD
    A[(GMyhf)]; 
    B[(2020fall-cs101)]; C[(2024spring-cs201)]; D[(2024fall-cs101)]
    
    E(2020fall_cs101.openjudge.cn_problems.md); F(2020fall_Codeforces_problems.md);
    G(2024spring_dsa_problems.md);H(2024fall_LeetCode_problems.md);
    S(sunnywhy_problems.md);

    A --- B; A --- C; A --- D;
    B --- E; B --- F; C --- G; C --- S;D --- H;
    
```



åœ¨çœ‹äº†æ ‘çš„ä¾‹å­ä¹‹åï¼Œç°åœ¨æ¥æ­£å¼åœ°å®šä¹‰æ ‘åŠå…¶æ„æˆã€‚

**èŠ‚ç‚¹ Node**ï¼šèŠ‚ç‚¹æ˜¯æ ‘çš„åŸºç¡€éƒ¨åˆ†ã€‚
æ¯ä¸ªèŠ‚ç‚¹å…·æœ‰åç§°ï¼Œæˆ–â€œé”®å€¼â€ã€‚èŠ‚ç‚¹è¿˜å¯ä»¥ä¿å­˜é¢å¤–æ•°æ®é¡¹ï¼Œæ•°æ®é¡¹æ ¹æ®ä¸åŒçš„åº”ç”¨è€Œå˜ã€‚

**è¾¹ Edge**ï¼šè¾¹æ˜¯ç»„æˆæ ‘çš„å¦ä¸€ä¸ªåŸºç¡€éƒ¨åˆ†ã€‚
æ¯æ¡è¾¹æ°å¥½è¿æ¥ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œè¡¨ç¤ºèŠ‚ç‚¹ä¹‹é—´å…·æœ‰å…³è”ï¼Œè¾¹å…·æœ‰å‡ºå…¥æ–¹å‘ï¼›
æ¯ä¸ªèŠ‚ç‚¹ï¼ˆé™¤æ ¹èŠ‚ç‚¹ï¼‰æ°æœ‰ä¸€æ¡æ¥è‡ªå¦ä¸€èŠ‚ç‚¹çš„å…¥è¾¹ï¼›
æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰é›¶æ¡/ä¸€æ¡/å¤šæ¡è¿åˆ°å…¶å®ƒèŠ‚ç‚¹çš„å‡ºè¾¹ã€‚<u>å¦‚æœåŠ é™åˆ¶ä¸èƒ½æœ‰ â€œå¤šæ¡è¾¹â€ï¼Œè¿™é‡Œæ ‘ç»“æ„å°±ç‰¹æ®ŠåŒ–ä¸ºçº¿æ€§è¡¨</u>

**æ ¹èŠ‚ Root**: æ ‘ä¸­å”¯ä¸€æ²¡æœ‰å…¥è¾¹çš„èŠ‚ç‚¹ã€‚

**è·¯å¾„ Path**ï¼šç”±è¾¹ä¾æ¬¡è¿æ¥åœ¨ä¸€èµ·çš„æœ‰åºèŠ‚ç‚¹åˆ—è¡¨ã€‚æ¯”å¦‚ï¼Œå“ºä¹³çº²â†’é£Ÿè‚‰ç›®â†’çŒ«ç§‘â†’çŒ«å±â†’å®¶çŒ«å°±æ˜¯ä¸€æ¡è·¯å¾„ã€‚

**å­èŠ‚ç‚¹ Children**ï¼šå…¥è¾¹å‡æ¥è‡ªäºåŒä¸€ä¸ªèŠ‚ç‚¹çš„è‹¥å¹²èŠ‚ç‚¹ï¼Œç§°ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€‚

**çˆ¶èŠ‚ç‚¹ Parent**ï¼šä¸€ä¸ªèŠ‚ç‚¹æ˜¯å…¶æ‰€æœ‰å‡ºè¾¹è¿æ¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

**å…„å¼ŸèŠ‚ç‚¹ Sibling**ï¼šå…·æœ‰åŒä¸€çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹ä¹‹é—´ä¸ºå…„å¼ŸèŠ‚ç‚¹ã€‚

**å­æ ‘ Subtree**ï¼šä¸€ä¸ªèŠ‚ç‚¹å’Œå…¶æ‰€æœ‰å­å­™èŠ‚ç‚¹ï¼Œä»¥åŠç›¸å…³è¾¹çš„é›†åˆã€‚

**å¶èŠ‚ç‚¹ Leaf Node**ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ç§°ä¸ºå¶èŠ‚ç‚¹ã€‚

**å±‚çº§ Level**ï¼š
ä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ°è¾¾ä¸€ä¸ªèŠ‚ç‚¹çš„è·¯å¾„ï¼Œ<mark>æ‰€åŒ…å«çš„è¾¹çš„æ•°é‡</mark>ï¼Œç§°ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„å±‚çº§ã€‚
ä¸‹å›¾ä¸­ D çš„å±‚çº§ä¸º 2ï¼Œæ ¹èŠ‚ç‚¹çš„å±‚çº§ä¸º 0ã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240204125813782.png" alt="image-20240204125813782" style="zoom:50%;" />

<center>å›¾ æ ‘çš„å±‚çº§æ˜¾ç¤º</center> 



**é«˜åº¦ Height**ï¼šæ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æœ€å¤§å±‚çº§ç§°ä¸ºæ ‘çš„é«˜åº¦ï¼Œå¦‚å›¾1æ‰€ç¤ºæ ‘çš„é«˜åº¦ä¸º 2ã€‚

å¯¹äºåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ ‘æ¥è¯´ï¼Œé«˜åº¦ä¸º0ï¼Œæ·±åº¦ä¸º0ã€‚å¦‚æœæ˜¯ç©ºæ ‘ï¼Œé«˜åº¦ã€æ·±åº¦éƒ½æ˜¯ -1.

è¿™æ˜¯åˆç†çš„å®šä¹‰æ–¹å¼ï¼Œä½†éœ€è¦âš ï¸ï¼š

é«˜åº¦ï¼šé€šå¸¸å®šä¹‰ä¸ºä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„è¾¹æ•°ã€‚å¯¹äºç©ºæ ‘ï¼Œé«˜åº¦ä¸º -1 æ˜¯ä¸€ç§å¸¸è§çš„çº¦å®šï¼ˆ<mark>ä½†ä¹Ÿæœ‰äººå®šä¹‰ä¸ºç©ºæ ‘çš„é«˜åº¦ä¸º 0</mark>ï¼‰ã€‚
æ·±åº¦ï¼šé€šå¸¸æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æŸä¸ªèŠ‚ç‚¹çš„è¾¹æ•°ã€‚å¯¹äºç©ºæ ‘ï¼Œæ·±åº¦æ²¡æœ‰æ„ä¹‰ï¼Œä¹Ÿå¯ä»¥å®šä¹‰ä¸º -1ã€‚

> **1 æ•™æã€ŠPythonæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æï¼ˆç¬¬2ç‰ˆï¼‰ã€‹ç¬¬å…­ç« **
>
> å±‚çº§ Levelï¼šä»æ ¹èŠ‚ç‚¹å¼€å§‹åˆ°è¾¾ä¸€ä¸ªèŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ‰€åŒ…å«çš„è¾¹çš„æ•°é‡ï¼Œç§°ä¸ºè¿™ä¸ªèŠ‚ç‚¹çš„å±‚çº§ã€‚æ ¹èŠ‚ç‚¹çš„å±‚çº§ä¸º 0ã€‚
>
> é«˜åº¦ Heightï¼šæ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æœ€å¤§å±‚çº§ç§°ä¸ºæ ‘çš„é«˜åº¦ã€‚å› æ­¤ç©ºæ ‘çš„é«˜åº¦æ˜¯-1ã€‚
> 
>
> 
>**2 Tree (graph theory)**
> 
>https://en.wikipedia.org/wiki/Tree_(graph_theory)#:~:text=The%20height%20of%20a%20vertex,its%20root%20(root%20path).
> 
><mark>The *height* of a vertex in a rooted tree is the length of the longest downward path to a leaf</mark> from that vertex. The *height* of the tree is the height of the root. <mark>The *depth* of a vertex is the length of the path to its root (*root path*)</mark>. This is commonly needed in the manipulation of the various self-balancing trees, AVL trees in particular. The root has depth zero, leaves have height zero, and a tree with only a single vertex (hence both a root and leaf) has depth and height zero. 
> 
>Conventionally, an empty tree (a tree with no vertices, if such are allowed) has depth and height âˆ’1.
> 
>
> 
>**3 2013-book-DataStructuresAndAlgorithmsInPython, page 308, Chapter 8. Trees**
> 
>Let p be the position of a node of a tree T . The depth of p is the number of ancestors of p, excluding p itself. Note that this definition implies that the depth of the root of T is 0. The depth of p can also be recursively defined as follows:
> â€¢ If p is the root, then the depth of p is 0.
>â€¢ Otherwise, the depth of p is one plus the depth of the parent of p
> 
>```python
> def depth(self, p):
># Return the number of levels separating Position p from the root.
> if self.is_root(p):
>  return 0
> else:
>   return 1 + self.depth(self.parent(p))
> 
>```
> 
> 
>  
>  Height and Depth of a node in a Binary Tree,  https://www.geeksforgeeks.org/height-and-depth-of-a-node-in-a-binary-tree/   The depth of a node is the number of edges present in path from the root node of a tree to that node.
>    The height of a node is the number of edges present in the longest path connecting that node to a leaf node.
>  



æ ¹æ®å‰å››ä¸ªå‚è€ƒå‡ºå¤„ï¼Œé«˜åº¦ã€æ·±åº¦ï¼Œéƒ½æ˜¯æ•°è¾¹çš„ä¸ªæ•°ã€‚

**4 âš ï¸æœ‰çš„é¢˜ç›®ä¸­å®šä¹‰**ï¼šä¸ä¸Šé¢å¸¸è§çš„æ·±åº¦å®šä¹‰ä¸ä¸€è‡´ã€‚ä¾‹å¦‚ï¼š

> 06646:äºŒå‰æ ‘çš„æ·±åº¦ï¼Œhttp://cs101.openjudge.cn/practice/06646/
>
> äºŒå‰æ ‘æ·±åº¦ï¼šä»æ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„èŠ‚ç‚¹ä¸ªæ•°ä¸ºæ ‘çš„æ·±åº¦ã€‚
>
> 
> 
>LC104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/
> 
>ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ `root` ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚
> 
>äºŒå‰æ ‘çš„ **æœ€å¤§æ·±åº¦** æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚



**æ ‘ Tree**:

å®šä¹‰åŸºæœ¬æœ¯è¯­åï¼Œå°±å¯ä»¥è¿›ä¸€æ­¥ç»™å‡ºæ ‘çš„æ­£å¼å®šä¹‰ã€‚å°†æä¾›ä¸¤ç§å®šä¹‰ï¼Œå…¶ä¸­ä¸€ç§æ¶‰åŠèŠ‚ç‚¹å’Œè¾¹ï¼Œå¦ä¸€ç§æ¶‰åŠé€’å½’ã€‚åœ¨åé¢ä¼šçœ‹åˆ°ï¼Œ<mark>é€’å½’å®šä¹‰å¾ˆæœ‰ç”¨ã€‚</mark>

**å®šä¹‰ä¸€ï¼š**æ ‘ç”±èŠ‚ç‚¹åŠè¿æ¥èŠ‚ç‚¹çš„è¾¹æ„æˆã€‚æ ‘æœ‰ä»¥ä¸‹å±æ€§ï¼š
â æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼›
â é™¤æ ¹èŠ‚ç‚¹å¤–ï¼Œå…¶ä»–æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¸å…¶å”¯ä¸€çš„çˆ¶èŠ‚ç‚¹ç›¸è¿ï¼›
â ä»æ ¹èŠ‚ç‚¹åˆ°å…¶ä»–æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸”ä»…æœ‰ä¸€æ¡è·¯å¾„ï¼›
â å¦‚æœæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°±ç§°è¿™æ ·çš„æ ‘ä¸ºäºŒå‰æ ‘ã€‚
å›¾2å±•ç¤ºäº†ä¸€æ£µç¬¦åˆå®šä¹‰ä¸€çš„æ ‘ã€‚è¾¹çš„ç®­å¤´è¡¨ç¤ºè¿æ¥æ–¹å‘ã€‚



![image](https://raw.githubusercontent.com/GMyhf/img/main/img/treedef1.png)

<center>å›¾2 ç”±èŠ‚ç‚¹å’Œè¾¹æ„æˆçš„æ ‘</center>



**å®šä¹‰äºŒï¼š**ä¸€æ£µæ ‘è¦ä¹ˆä¸ºç©ºï¼Œè¦ä¹ˆç”±ä¸€ä¸ªæ ¹èŠ‚ç‚¹å’Œé›¶æ£µæˆ–å¤šæ£µå­æ ‘æ„æˆï¼Œå­æ ‘æœ¬èº«ä¹Ÿæ˜¯ä¸€æ£µæ ‘ã€‚æ¯æ£µå­æ ‘çš„æ ¹èŠ‚ç‚¹é€šè¿‡ä¸€æ¡è¾¹è¿åˆ°çˆ¶æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚å›¾3å±•ç¤ºäº†æ ‘çš„é€’å½’å®šä¹‰ã€‚ä»æ ‘çš„é€’å½’å®šä¹‰å¯çŸ¥ï¼Œå›¾ä¸­çš„æ ‘è‡³å°‘æœ‰4ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºä¸‰è§’å½¢ä»£è¡¨çš„å­æ ‘å¿…å®šæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ã€‚è¿™æ£µæ ‘æˆ–è®¸æœ‰æ›´å¤šçš„èŠ‚ç‚¹ï¼Œä½†å¿…é¡»æ›´æ·±å…¥åœ°æŸ¥çœ‹å­æ ‘åæ‰èƒ½ç¡®å®šã€‚

![image](https://raw.githubusercontent.com/GMyhf/img/main/img/TreeDefRecursive.png)

<center>å›¾3 æ ‘çš„é€’å½’å®šä¹‰</center>



> Q: æ ‘ç”¨é€’å½’å®ç°æ‰ç®€æ´æ˜“æ‡‚å§ï¼Ÿ
>
> A: æ˜¯çš„ï¼Œé€’å½’å®ç°é€šå¸¸æ›´ç®€æ´æ˜“æ‡‚ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤„ç†æ ‘è¿™ç§é€’å½’ç»“æ„æ—¶ã€‚<mark>é€’å½’çš„æ€æƒ³ä¸æ ‘çš„ç»“æ„è‡ªç„¶å¥‘åˆ</mark>ï¼Œå› ä¸ºæ ‘çš„å®šä¹‰æœ¬èº«å°±æ˜¯é€’å½’çš„ï¼šæ ‘ç”±æ ¹èŠ‚ç‚¹å’Œè‹¥å¹²å­æ ‘ç»„æˆï¼Œæ¯ä¸ªå­æ ‘ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯ä¸€æ£µæ ‘ã€‚
>
> é€’å½’å®ç°çš„ä¼˜ç‚¹åŒ…æ‹¬ï¼š
>
> 1. è‡ªç„¶è€Œç›´è§‚ï¼šé€’å½’å®ç°èƒ½å¤Ÿç›´æ¥æ¨¡æ‹Ÿæ ‘çš„ç»“æ„ï¼Œæ›´ç¬¦åˆæˆ‘ä»¬å¯¹æ ‘çš„ç›´è§‰è®¤çŸ¥ï¼Œä½¿ä»£ç æ›´æ˜“ç†è§£å’Œç¼–å†™ã€‚
>
> 2. ä»£ç ç®€æ´ï¼šé€’å½’å®ç°é€šå¸¸æ¯”è¿­ä»£å®ç°ä»£ç æ›´ä¸ºç®€æ´ï¼Œå› ä¸ºé€’å½’èƒ½å¤Ÿåˆ©ç”¨å‡½æ•°çš„è‡ªèº«è°ƒç”¨æ¥å¤„ç†å­æ ‘ã€‚
>
> 3. é€»è¾‘æ¸…æ™°ï¼šé€’å½’å®ç°èƒ½å¤Ÿæ¸…æ™°åœ°è¡¨è¾¾æ ‘çš„éå†å’Œå¤„ç†é€»è¾‘ï¼Œä½¿ä»£ç æ›´æ˜“è¯»ã€‚
>
> ç„¶è€Œï¼Œé€’å½’å®ç°ä¹Ÿæœ‰ä¸€äº›æ½œåœ¨çš„ç¼ºç‚¹ï¼Œä¾‹å¦‚åœ¨å¤„ç†å¤§è§„æ¨¡çš„æ ‘æ—¶å¯èƒ½å¯¼è‡´æ ˆæº¢å‡ºï¼ˆStack Overflowï¼‰çš„é—®é¢˜ã€‚æ­¤å¤–ï¼Œé€’å½’å®ç°æœ‰æ—¶å¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½è¾ƒå·®ï¼Œå› ä¸ºåœ¨é€’å½’è¿‡ç¨‹ä¸­å¯èƒ½ä¼šè¿›è¡Œé‡å¤çš„è®¡ç®—ã€‚
>
> 
>
> Q: æ ‘çš„è§„æ¨¡è¾ƒå°ï¼Œè¾ƒå¤§ï¼Œå…·ä½“å¤§æ¦‚æŒ‡å¤šå°‘ä¸ªèŠ‚ç‚¹å‘¢ï¼Ÿ
>
> A: ä¸€èˆ¬æ¥è¯´ï¼Œæ ‘çš„è§„æ¨¡è¾ƒå°å’Œè¾ƒå¤§æ˜¯ç›¸å¯¹çš„æ¦‚å¿µï¼Œå…·ä½“çš„èŠ‚ç‚¹æ•°é‡å–å†³äºé—®é¢˜çš„ä¸Šä¸‹æ–‡å’Œå®é™…éœ€æ±‚ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„èŠ‚ç‚¹æ•°é‡èŒƒå›´ï¼Œå°½ç®¡è¿™åªæ˜¯ä¸€ç§å¸¸è§çš„åˆ’åˆ†ï¼Œå¹¶ä¸æ˜¯ä¸¥æ ¼çš„ç•Œå®šï¼š
>
> 1. å°å‹æ ‘ï¼šé€šå¸¸æŒ‡èŠ‚ç‚¹æ•°é‡åœ¨å‡ ååˆ°å‡ ç™¾ä¸ªä¹‹é—´çš„æ ‘ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé€’å½’å®ç°å¾€å¾€æ˜¯ç®€æ´æ˜“æ‡‚çš„é€‰æ‹©ï¼Œå¹¶ä¸”æ€§èƒ½æ–¹é¢çš„å·®å¼‚å¯èƒ½å¹¶ä¸æ˜æ˜¾ã€‚
>
> 2. ä¸­å‹æ ‘ï¼šé€šå¸¸æŒ‡èŠ‚ç‚¹æ•°é‡åœ¨å‡ ç™¾åˆ°å‡ åƒä¸ªä¹‹é—´çš„æ ‘ã€‚å¯¹äºä¸­å‹æ ‘ï¼Œé€’å½’å®ç°ä»ç„¶å¯ä»¥è€ƒè™‘ä½¿ç”¨ï¼Œä½†åœ¨æ€§èƒ½æ–¹é¢å¯èƒ½éœ€è¦æ›´åŠ è°¨æ…ï¼Œä»¥é¿å…æ½œåœ¨çš„æ ˆæº¢å‡ºé—®é¢˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿­ä»£å®ç°å¯èƒ½æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚
>
> 3. å¤§å‹æ ‘ï¼šé€šå¸¸æŒ‡èŠ‚ç‚¹æ•°é‡åœ¨å‡ åƒåˆ°å‡ ç™¾ä¸‡ï¼ˆç”šè‡³æ›´å¤šï¼‰ä¹‹é—´çš„æ ‘ã€‚å¯¹äºå¤§å‹æ ‘ï¼Œé€’å½’å®ç°å¯èƒ½ä¼šé¢ä¸´æ ˆæº¢å‡ºçš„é£é™©ï¼Œå¹¶ä¸”æ€§èƒ½æ–¹é¢çš„å·®å¼‚å¯èƒ½ä¼šæ›´åŠ æ˜æ˜¾ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿­ä»£å®ç°é€šå¸¸æ˜¯æ›´å¯é å’Œé«˜æ•ˆçš„é€‰æ‹©ã€‚



**Application of Tree Data Structure**

**æ ‘æ•°æ®ç»“æ„çš„åº”ç”¨**

- **æ–‡ä»¶ç³»ç»Ÿ**ï¼šè¿™ä½¿å¾—æ–‡ä»¶çš„å¯¼èˆªå’Œç»„ç»‡æ›´åŠ é«˜æ•ˆã€‚
- **æ•°æ®å‹ç¼©**ï¼š<mark>**éœå¤«æ›¼ç¼–ç ï¼ˆHuffman codingï¼‰**</mark> æ˜¯ä¸€ç§æµè¡Œçš„æ•°æ®å‹ç¼©æŠ€æœ¯ï¼Œå®ƒé€šè¿‡æ„å»ºä¸€æ£µäºŒå‰æ ‘æ¥å®ç°ï¼Œå…¶ä¸­å¶å­èŠ‚ç‚¹è¡¨ç¤ºå­—ç¬¦åŠå…¶å‡ºç°é¢‘ç‡ã€‚ç”Ÿæˆçš„æ ‘ç”¨äºä»¥æœ€å°åŒ–å­˜å‚¨éœ€æ±‚çš„æ–¹å¼å¯¹æ•°æ®è¿›è¡Œç¼–ç ã€‚
- **ç¼–è¯‘å™¨è®¾è®¡**ï¼šåœ¨ç¼–è¯‘å™¨è®¾è®¡ä¸­ï¼Œ<mark>**æŠ½è±¡è¯­æ³•æ ‘ï¼ˆAbstract Syntax Treeï¼‰** </mark>ç”¨äºè¡¨ç¤ºç¨‹åºçš„ç»“æ„ã€‚
- **æ•°æ®åº“ç´¢å¼•**ï¼šB æ ‘å’Œå…¶ä»–æ ‘ç»“æ„è¢«ç”¨äºæ•°æ®åº“ç´¢å¼•ï¼Œä»¥ä¾¿é«˜æ•ˆåœ°æœç´¢å’Œæ£€ç´¢æ•°æ®ã€‚

---

**æ ‘æ•°æ®ç»“æ„çš„ä¼˜ç‚¹**

- æ ‘æä¾›**é«˜æ•ˆçš„æœç´¢**ï¼Œå…·ä½“æ•ˆç‡å–å†³äºæ ‘çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œåƒ AVL æ ‘è¿™æ ·çš„å¹³è¡¡æ ‘ï¼Œå…¶å¹³å‡æœç´¢æ—¶é—´ä¸º O(log n)ã€‚
- æ ‘ä»¥åˆ†å±‚æ–¹å¼è¡¨ç¤ºæ•°æ®ï¼Œä½¿å¤§é‡ä¿¡æ¯çš„**ç»„ç»‡å’Œå¯¼èˆªå˜å¾—ç®€å•**ã€‚
- <mark>æ ‘çš„é€’å½’ç‰¹æ€§ä½¿å…¶èƒ½å¤Ÿé€šè¿‡é€’å½’ç®—æ³•**è½»æ¾éå†å’Œæ“ä½œ**ã€‚</mark>

---

**æ ‘æ•°æ®ç»“æ„çš„ç¼ºç‚¹**

- ä¸å¹³è¡¡çš„æ ‘ä¼šå¯¼è‡´æ ‘çš„é«˜åº¦åå‘ä¸€ä¾§ï¼Œä»è€Œå¯èƒ½å¼•å‘**ä½æ•ˆçš„æœç´¢æ—¶é—´**ã€‚
- æ ‘éœ€è¦**æ›´å¤šçš„å†…å­˜ç©ºé—´**ï¼Œç›¸æ¯”æ•°ç»„å’Œé“¾è¡¨ç­‰å…¶ä»–æ•°æ®ç»“æ„ï¼Œå°¤å…¶æ˜¯åœ¨æ ‘éå¸¸å¤§çš„æƒ…å†µä¸‹ã€‚



> - **File System**: This allows for efficient navigation and organization of files.
> - **Data Compression**: <mark>**Huffman coding**</mark> is a popular technique for data compression that involves constructing a binary tree where the leaves represent characters and their frequency of occurrence. The resulting tree is used to encode the data in a way that minimizes the amount of storage required.
> - **Compiler Design:** In compiler design, a **syntax tree** is used to represent the structure of a program. 
> - **Database Indexing**: B-trees and other tree structures are used in database indexing to efficiently search for and retrieve data. 
>
> 
>
> **Advantages of Tree Data Structure**
>
> - Tree offer **Efficient Searching** depending on the type of tree, with average search times of O(log n) for balanced trees like AVL. 
> - Trees provide a hierarchical representation of data, making it **easy to organize and navigate** large amounts of information.
> - <mark>The recursive nature of trees makes them **easy to traverse and manipulate** using recursive algorithms.</mark>
>
> 
>
> **Disadvantages of Tree Data Structure**
>
> - Unbalanced Trees, meaning that the height of the tree is skewed towards one side, which can lead to **inefficient search times.**
> - Trees demand **more memory space requirements** than some other data structures like arrays and linked lists, especially if the tree is very large.
>



### 1.1 né˜¶å¤šå‰æ ‘ (N-ary Trees)

æ™®é€šæ ‘ï¼ˆGeneric treesï¼‰æ˜¯ç”±è‹¥å¹²èŠ‚ç‚¹ç»„æˆçš„é›†åˆï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ŒåŒ…å«è®°å½•å’Œä¸€ä¸ªæŒ‡å‘å…¶å­èŠ‚ç‚¹çš„å¼•ç”¨åˆ—è¡¨ï¼ˆä¸å…è®¸é‡å¤å¼•ç”¨ï¼‰ã€‚ä¸é“¾è¡¨ä¸åŒï¼Œæ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨äº†å¤šä¸ªèŠ‚ç‚¹çš„åœ°å€ã€‚<mark>æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å…¶å­èŠ‚ç‚¹çš„åœ°å€</mark>ï¼Œè€Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€åˆ™å­˜å‚¨åœ¨ä¸€ä¸ªåä¸º<mark>æ ¹ï¼ˆrootï¼‰</mark>çš„ç‹¬ç«‹æŒ‡é’ˆä¸­ã€‚

æ™®é€šæ ‘æ˜¯ N å‰æ ‘çš„ä¸€ç§ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š

1. æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰å¤šä¸ªå­èŠ‚ç‚¹ã€‚
2. æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡äº‹å…ˆæœªçŸ¥ã€‚

> https://www.geeksforgeeks.org/generic-treesn-array-trees/?ref=outind
>
> Last Updated : 27 Jul, 2024
>
> Generic trees are a collection of nodes where each node is a data structure that consists of records and a list of references to its children (duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes. <mark>Every node stores address of its children</mark> and the very first nodeâ€™s address will be stored in a separate pointer called <mark>root</mark>.
>
> The Generic trees are the N-ary trees which have the following properties: 
>
> â€‹      1. Many children at every node.
>
> â€‹      2. The number of nodes for each node is not known in advance.
>

**Example:** 


 ![img](https://raw.githubusercontent.com/GMyhf/img/main/img/generic-tree_gfg.png)



Generic Tree

ä¸ºäº†è¡¨ç¤ºä¸Šè¿°æ ‘ç»“æ„ï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘æœ€åçš„æƒ…å†µï¼Œå³æ‹¥æœ‰æœ€å¤šå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼ˆåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæœ‰ 6 ä¸ªå­èŠ‚ç‚¹ï¼‰ï¼Œå¹¶ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ†é…ç›¸åº”æ•°é‡çš„æŒ‡é’ˆã€‚  
åŸºäºæ­¤æ–¹æ³•çš„èŠ‚ç‚¹è¡¨ç¤ºå¯ä»¥å†™ä¸ºï¼š

> To represent the above tree, we have to consider the worst case, that is the node with maximum children (in above example, 6 children) and allocate that many pointers for each node.
> The node representation based on this method can be written as:

```python
class Node: 
	def __init__(self, data): 
		self.data = data 
		self.firstchild = None
		self.secondchild = None
		self.thirdchild = None
		self.fourthchild = None
		self.fifthchild = None
		self.sixthchild = None

```



ä¸Šè¿°è¡¨ç¤ºæ–¹æ³•çš„ç¼ºç‚¹æ˜¯ï¼š

1. **å†…å­˜æµªè´¹** â€“ å¹¶éæ‰€æœ‰æƒ…å†µä¸‹éƒ½éœ€è¦ç”¨åˆ°æ‰€æœ‰çš„æŒ‡é’ˆï¼Œå› æ­¤ä¼šé€ æˆå¤§é‡çš„å†…å­˜æµªè´¹ã€‚
2. **å­èŠ‚ç‚¹æ•°é‡æœªçŸ¥** â€“ æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡äº‹å…ˆæ— æ³•ç¡®å®šã€‚



**ç®€å•æ–¹æ³•ï¼š**

<mark>ä¸ºäº†å­˜å‚¨èŠ‚ç‚¹ä¸­å­èŠ‚ç‚¹çš„åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ•°ç»„æˆ–é“¾è¡¨</mark>ã€‚ä½†ä¸¤ç§æ–¹æ³•éƒ½ä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ã€‚

1. åœ¨**é“¾è¡¨**ä¸­ï¼Œæˆ‘ä»¬æ— æ³•éšæœºè®¿é—®ä»»æ„å­èŠ‚ç‚¹çš„åœ°å€ï¼Œå› æ­¤æ•ˆç‡è¾ƒä½ï¼Œæˆæœ¬è¾ƒé«˜ã€‚
2. åœ¨**æ•°ç»„**ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥éšæœºè®¿é—®ä»»æ„å­èŠ‚ç‚¹çš„åœ°å€ï¼Œä½†åªèƒ½å­˜å‚¨å›ºå®šæ•°é‡çš„å­èŠ‚ç‚¹åœ°å€ã€‚



**æ›´å¥½çš„æ–¹æ³•ï¼š**

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨**åŠ¨æ€æ•°ç»„**æ¥å­˜å‚¨å­èŠ‚ç‚¹çš„åœ°å€ã€‚å®ƒæ—¢å¯ä»¥éšæœºè®¿é—®ä»»æ„å­èŠ‚ç‚¹çš„åœ°å€ï¼Œå…¶å¤§å°ï¼ˆå®¹é‡ï¼‰ä¹Ÿæ²¡æœ‰å›ºå®šçš„é™åˆ¶ã€‚

> Disadvantages of the above representation are: 
>
> 1. Memory Wastage â€“ All the pointers are not required in all the cases. Hence, there is lot of memory wastage.
> 2. Unknown number of children â€“ The number of children for each node is not known in advance.
>
> 
>
> Simple Approach: 
>
> <mark>For storing the address of children in a node we can use an array or linked list</mark>. But we will face some issues with both of them.
>
> 1. In **Linked list**, we can not randomly access any childâ€™s address. So it will be expensive.
> 2. In **array**, we can randomly access the address of any child, but we can store only fixed number of childrenâ€™s addresses in it.
>
> 
>
> **Better Approach:**
>
> We can use **Dynamic Arrays** for storing the address of children. We can randomly access any childâ€™s address and the size of the vector is also not fixed.
>

```python
class Node: 
	
	def __init__(self,data): 
		self.data=data 
		self.children=[]

```



#### é«˜æ•ˆæ–¹æ³•ï¼šé•¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•

åœ¨â€œé•¿å­ / ä¸‹ä¸€ä¸ªå…„å¼Ÿâ€è¡¨ç¤ºæ³•ä¸­ï¼Œé‡‡å–çš„æ­¥éª¤å¦‚ä¸‹ï¼š

1. å°†åŒä¸€çˆ¶èŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼ˆå³å…„å¼ŸèŠ‚ç‚¹ï¼‰ä»å·¦åˆ°å³é“¾æ¥èµ·æ¥ã€‚
2. ç§»é™¤çˆ¶èŠ‚ç‚¹åˆ°æ‰€æœ‰å­èŠ‚ç‚¹çš„é“¾æ¥ï¼Œåªä¿ç•™åˆ°ç¬¬ä¸€ä¸ªå­©å­çš„é“¾æ¥ã€‚

ç”±äºå­èŠ‚ç‚¹ä¹‹é—´å·²ç»å»ºç«‹äº†é“¾æ¥ï¼Œå› æ­¤ä¸éœ€è¦ä»çˆ¶èŠ‚ç‚¹åˆ°æ‰€æœ‰å­èŠ‚ç‚¹çš„é¢å¤–é“¾æ¥ã€‚è¿™ç§è¡¨ç¤ºæ³•å…è®¸æˆ‘ä»¬é€šè¿‡ä»çˆ¶èŠ‚ç‚¹çš„ç¬¬ä¸€ä¸ªå­©å­å¼€å§‹ï¼Œéå†æ‰€æœ‰çš„å…ƒç´ ã€‚



> #### Efficient Approach
>
> <mark>First child / Next sibling representation</mark>
>
>  In the first child/next sibling representation, the steps taken are: 
>
> At each node-link the children of the same parent(siblings) from left to right.
>
> - Remove the links from parent to all children except the first child.
>
> Since we have a link between children, we do not need extra links from parents to all the children. This representation allows us to traverse all the elements by starting at the first child of the parent.
>




 <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/generictree_gfg.png" alt="img" style="zoom:67%;" />



FIRST CHILD/NEXT SIBLING REPRESENTATION



The node declaration for first child / next sibling representation can be written as: 

```python
class Node: 
	def __init__(self, data): 
		self.data = data 
		self.firstChild = None
		self.nextSibling = None

		# This code is contributed by aadityamaharshi

```

**ä¼˜ç‚¹ï¼š**

- **å†…å­˜é«˜æ•ˆ** â€“ ä¸éœ€è¦é¢å¤–çš„é“¾æ¥ï¼Œå› æ­¤èŠ‚çœäº†å¤§é‡å†…å­˜ã€‚
- **å¯è§†ä¸ºäºŒå‰æ ‘** â€“ ç”±äºæˆ‘ä»¬èƒ½å¤Ÿå°†ä»»ä½•é€šç”¨æ ‘è½¬æ¢ä¸ºäºŒå‰æ ‘è¡¨ç¤ºå½¢å¼ï¼Œå› æ­¤å¯ä»¥<mark>å°†æ‰€æœ‰ä½¿ç”¨â€œç¬¬ä¸€ä¸ªå­©å­/ä¸‹ä¸€ä¸ªå…„å¼Ÿâ€è¡¨ç¤ºæ³•çš„é€šç”¨æ ‘è§†ä¸ºäºŒå‰æ ‘</mark>ã€‚æˆ‘ä»¬åªéœ€ä½¿ç”¨ `firstChild`ï¼ˆç¬¬ä¸€ä¸ªå­©å­ï¼‰å’Œ `nextSibling`ï¼ˆä¸‹ä¸€ä¸ªå…„å¼Ÿï¼‰ï¼Œè€Œä¸ç”¨ä¼ ç»Ÿçš„å·¦æŒ‡é’ˆå’Œå³æŒ‡é’ˆã€‚
- **ç®—æ³•æ›´æ˜“è¡¨è¾¾** â€“ å› ä¸ºå®ƒæœ¬è´¨ä¸Šæ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œè®¸å¤šç®—æ³•å¯ä»¥æ›´è½»æ¾åœ°å®ç°ã€‚
- **èŠ‚ç‚¹å¤§å°å›ºå®š** â€“ æ¯ä¸ªèŠ‚ç‚¹çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œå› æ­¤ä¸éœ€è¦è¾…åŠ©æ•°ç»„æˆ–å‘é‡æ¥å­˜å‚¨å­èŠ‚ç‚¹ä¿¡æ¯ã€‚

> **Advantages:** 
>
> - Memory efficient â€“ No extra links are required, hence a lot of memory is saved.
> - Treated as binary trees â€“ Since we are able to convert any generic tree to binary representation, we can <mark>treat all generic trees with a first child/next sibling representation as binary trees</mark>. Instead of left and right pointers, we just use firstChild and nextSibling.
> - Many algorithms can be expressed more easily because it is just a binary tree.
> - Each node is of fixed size, so no auxiliary array or vector is required.
>



##### ç¬”è¯•å¡«ç©º@20240618

Q. è®¾æ£®æ—Fä¸­æœ‰4æ£µæ ‘ï¼Œç¬¬1ã€2ã€3ã€4æ£µæ ‘çš„ç»“ç‚¹ä¸ªæ•°åˆ†åˆ«ä¸º10ã€9ã€11ã€7ï¼Œå½“æŠŠæ£®æ—Fè½¬æ¢æˆä¸€æ£µäºŒå‰æ ‘åï¼Œå…¶æ ¹ç»“ç‚¹çš„å³å­æ ‘ä¸­æœ‰å¤šå°‘ä¸ªç»“ç‚¹ï¼Ÿ

> **æ£®æ—è½¬æ¢ä¸ºäºŒå‰æ ‘**
>
> åœ¨æ ‘çš„è½¬æ¢è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ **â€œé•¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•â€**ï¼Œå³ï¼š
> 1. **æ¯æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä¸å˜**ï¼Œå®ƒçš„**ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹**ä½œä¸ºå®ƒçš„**å·¦å­©å­**ã€‚
> 2. **æ¯ä¸ªèŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹**ä½œä¸ºå®ƒçš„**å³å­©å­**ã€‚
>
> **åˆ†æé¢˜ç›®**
>
> æ£®æ— \( F \) ç”± 4 æ£µæ ‘ç»„æˆï¼š
> - **ç¬¬ 1 æ£µæ ‘**ï¼š10 ä¸ªèŠ‚ç‚¹
> - **ç¬¬ 2 æ£µæ ‘**ï¼š9 ä¸ªèŠ‚ç‚¹
> - **ç¬¬ 3 æ£µæ ‘**ï¼š11 ä¸ªèŠ‚ç‚¹
> - **ç¬¬ 4 æ£µæ ‘**ï¼š7 ä¸ªèŠ‚ç‚¹
>
> æ£®æ—è½¬æ¢ä¸ºäºŒå‰æ ‘åï¼š
> - **äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹** æ˜¯ **æ£®æ—çš„ç¬¬ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹**ã€‚
> - **æ ¹èŠ‚ç‚¹çš„å³å­©å­** æ˜¯ **ç¬¬äºŒæ£µæ ‘çš„æ ¹èŠ‚ç‚¹**ï¼Œå®ƒçš„å³å­©å­æ˜¯ **ç¬¬ä¸‰æ£µæ ‘çš„æ ¹èŠ‚ç‚¹**ï¼Œä¾æ¬¡ç±»æ¨ã€‚
> - **æ ¹èŠ‚ç‚¹çš„å³å­æ ‘** åŒ…å« **æ‰€æœ‰å…¶ä»–æ ‘çš„èŠ‚ç‚¹**ï¼Œå³**ç¬¬ 2ã€3ã€4 æ£µæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹**ã€‚
>
> **è®¡ç®—æ ¹èŠ‚ç‚¹å³å­æ ‘çš„èŠ‚ç‚¹æ•°**
>
> æ ¹èŠ‚ç‚¹çš„å³å­æ ‘åŒ…æ‹¬ï¼š
> - ç¬¬ 2 æ£µæ ‘çš„ 9 ä¸ªèŠ‚ç‚¹
> - ç¬¬ 3 æ£µæ ‘çš„ 11 ä¸ªèŠ‚ç‚¹
> - ç¬¬ 4 æ£µæ ‘çš„ 7 ä¸ªèŠ‚ç‚¹
>
> 9 + 11 + 7 = 27



### 1.2 ğŸŒ²çš„é¢˜ç›®é€’å½’å†™æ³•é€šå¸¸æ˜¯é¦–é€‰

æ ‘ç»“æ„çš„é¢˜ç›®éå¸¸é€‚åˆç”¨é€’å½’æ¥è§£å†³ï¼Œå› ä¸ºæ ‘æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€’å½’å®šä¹‰çš„æ•°æ®ç»“æ„â€”â€”æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªåŒ…å«å­èŠ‚ç‚¹çš„å°æ ‘ã€‚ä½¿ç”¨é€’å½’æ–¹æ³•æ¥è§£å†³é—®é¢˜å¯ä»¥ä½¿ä»£ç æ›´ç®€æ´ã€æ˜“è¯»ï¼Œå¹¶ä¸”é€šå¸¸æ›´å®¹æ˜“ç†è§£ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„æ ‘æ“ä½œç¤ºä¾‹ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨é€’å½’<mark>ä¼˜é›…</mark>åœ°å®ç°å®ƒä»¬ã€‚

ä½¿ç”¨ç±»ï¼ˆclassï¼‰æ¥å®šä¹‰æ ‘çš„èŠ‚ç‚¹ã€‚æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸‰ä¸ªå±æ€§ï¼šèŠ‚ç‚¹çš„å€¼ (`val`)ã€æŒ‡å‘å·¦å­èŠ‚ç‚¹çš„å¼•ç”¨ (`left`) å’ŒæŒ‡å‘å³å­èŠ‚ç‚¹çš„å¼•ç”¨ (`right`)ã€‚

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```



#### 1. éå†ï¼ˆTraversalï¼‰

##### å‰åºéå†ï¼ˆPre-order Traversalï¼‰

å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’åœ°å‰åºéå†å·¦å­æ ‘ï¼Œæœ€åé€’å½’åœ°å‰åºéå†å³å­æ ‘ã€‚

```python
def preorder_traversal(root):
    if root:
        print(root.val)  # è®¿é—®æ ¹èŠ‚ç‚¹
        preorder_traversal(root.left)  # é€’å½’éå†å·¦å­æ ‘
        preorder_traversal(root.right)  # é€’å½’éå†å³å­æ ‘
```



##### ä¸­åºéå†ï¼ˆIn-order Traversalï¼‰

å…ˆé€’å½’åœ°ä¸­åºéå†å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åé€’å½’åœ°ä¸­åºéå†å³å­æ ‘ã€‚

```python
def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)  # é€’å½’éå†å·¦å­æ ‘
        print(root.val)  # è®¿é—®æ ¹èŠ‚ç‚¹
        inorder_traversal(root.right)  # é€’å½’éå†å³å­æ ‘
```



###### ç¤ºä¾‹LC94.äºŒå‰æ ‘çš„ä¸­åºéå†

https://leetcode.cn/problems/binary-tree-inorder-traversal/

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å› *å®ƒçš„ **ä¸­åº** éå†* ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img" style="zoom: 50%;" />

```
è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[1,3,2]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 100]` å†…
- `-100 <= Node.val <= 100`



```python
from typing import Optional, List

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        
        def dfs(node: Optional[TreeNode]):
            if not node:
                return
            dfs(node.left)
            result.append(node.val)
            dfs(node.right)
        
        dfs(root)
        return result
```



> ç”¨stackæ¨¡æ‹Ÿçš„â€œ<mark>é¢œè‰²å¡«å……æ³•</mark>â€ï¼Œå’Œé€’å½’çš„æ€è·¯å…¶å®å¾ˆç›¸ä¼¼ã€‚
>
> æ ¸å¿ƒæ€æƒ³å¦‚ä¸‹ï¼š
>
> - ä½¿ç”¨é¢œè‰²æ ‡è®°èŠ‚ç‚¹çš„çŠ¶æ€ï¼Œæ–°èŠ‚ç‚¹ä¸ºç™½è‰²ï¼Œå·²è®¿é—®çš„èŠ‚ç‚¹ä¸ºç°è‰²ã€‚
>- å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸ºç™½è‰²ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºç°è‰²ï¼Œç„¶åå°†å…¶å³å­èŠ‚ç‚¹ã€è‡ªèº«ã€å·¦å­èŠ‚ç‚¹ä¾æ¬¡å…¥æ ˆã€‚
> - å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸ºç°è‰²ï¼Œåˆ™å°†èŠ‚ç‚¹çš„å€¼è¾“å‡ºã€‚
>
> ```python
> # Definition for a binary tree node.
> # class TreeNode:
>#     def __init__(self, val=0, left=None, right=None):
> #         self.val = val
> #         self.left = left
> #         self.right = right
> class Solution:
>     def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
>         white, gray = 0, 1
>         res = []
>         stack = [(white, root)]
>         while stack:
>             color, node = stack.pop()
>             if node is None: continue
>             if color == white:
>                 stack.append((white, node.right))
>                 stack.append((gray, node))
>                 stack.append((white, node.left))
>             else:
>                 res.append(node.val)
>         return res
> ```
> 



##### ååºéå†ï¼ˆPost-order Traversalï¼‰

å…ˆé€’å½’åœ°ååºéå†å·¦å­æ ‘ï¼Œç„¶åé€’å½’åœ°ååºéå†å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ã€‚

```python
def postorder_traversal(root):
    if root:
        postorder_traversal(root.left)  # é€’å½’éå†å·¦å­æ ‘
        postorder_traversal(root.right)  # é€’å½’éå†å³å­æ ‘
        print(root.val)  # è®¿é—®æ ¹èŠ‚ç‚¹
```



##### å±‚åºéå†ï¼šæŒ‰å±‚ä»å·¦åˆ°å³ä¾æ¬¡éå†

###### ç»ƒä¹ LC102.äºŒå‰æ ‘çš„å±‚åºéå†

bfs, https://leetcode.cn/problems/binary-tree-level-order-traversal/

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **å±‚åºéå†** ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" style="zoom:67%;" />

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[9,20],[15,7]]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
- `-1000 <= Node.val <= 1000`





```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            level_size = len(queue)
            level = []

            for _ in range(level_size):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(level)

        return result
        
```





#### 2. æ±‚æ ‘çš„é«˜åº¦/æ·±åº¦

```python
def tree_height(root):
    if not root:  # ç©ºæ ‘çš„é«˜åº¦ä¸º 0
        return 0
    
    left_height = tree_height(root.left)  # å·¦å­æ ‘çš„é«˜åº¦
    right_height = tree_height(root.right)  # å³å­æ ‘çš„é«˜åº¦
    
    return max(left_height, right_height) + 1  # æ ‘çš„é«˜åº¦æ˜¯å·¦å³å­æ ‘æœ€å¤§é«˜åº¦åŠ  1
```



###### ç¤ºä¾‹LC104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

tree, dfs, https://leetcode.cn/problems/maximum-depth-of-binary-tree/

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ `root` ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚

äºŒå‰æ ‘çš„ **æœ€å¤§æ·±åº¦** æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img" style="zoom:50%;" />

 

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š3
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [1,null,2]
è¾“å‡ºï¼š2
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡åœ¨ `[0, 10^4]` åŒºé—´å†…ã€‚
- `-100 <= Node.val <= 100`



å·²çŸ¥æ ‘æ ¹root

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        def tree_depth(node):
            if node is None:
                return 0
            left_depth = tree_depth(node.left)
            right_depth = tree_depth(node.right)
            return max(left_depth, right_depth) + 1
        
        return tree_depth(root)
```



###### ç»ƒä¹ M06646: äºŒå‰æ ‘çš„æ·±åº¦

http://cs101.openjudge.cn/practice/06646/

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ±‚è¯¥äºŒå‰æ ‘çš„æ·±åº¦

äºŒå‰æ ‘**æ·±åº¦**å®šä¹‰ï¼šä»æ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„èŠ‚ç‚¹ä¸ªæ•°ä¸ºæ ‘çš„æ·±åº¦

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºäºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚äºŒå‰æ ‘ç»“ç‚¹ç¼–å·ä»1åˆ°nï¼Œæ ¹ç»“ç‚¹ä¸º1ï¼Œn <= 10
æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œä¾æ¬¡å¯¹åº”äºŒå‰æ ‘çš„nä¸ªèŠ‚ç‚¹ã€‚
æ¯è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„å·¦å„¿å­å’Œå³å„¿å­çš„èŠ‚ç‚¹ç¼–å·ã€‚å¦‚æœç¬¬ä¸€ä¸ªï¼ˆç¬¬äºŒä¸ªï¼‰æ•°ä¸º-1åˆ™è¡¨ç¤ºæ²¡æœ‰å·¦ï¼ˆå³ï¼‰å„¿å­

**è¾“å‡º**

è¾“å‡ºä¸€ä¸ªæ•´å‹æ•°ï¼Œè¡¨ç¤ºæ ‘çš„æ·±åº¦

æ ·ä¾‹è¾“å…¥

```
3
2 3
-1 -1
-1 -1
```

æ ·ä¾‹è¾“å‡º

```
2
```



 æ¨èè¿™ç§ç±»çš„å†™æ³•ï¼Œåœ¨ç¬”è¯•ä¸­ä¹Ÿå¸¸è§ã€‚<mark>æ ¹æ®è¾“å…¥å»ºæ ‘ï¼ŒçŸ¥é“æ ‘æ ¹ä½ç½®</mark>ã€‚

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def build_tree(nodes):
    if not nodes:
        return None

    tree_nodes = [None] * (len(nodes) + 1)
    for i in range(1, len(nodes) + 1):
        tree_nodes[i] = TreeNode(i)

    for i, (left, right) in enumerate(nodes, start=1):
        if left != -1:
            tree_nodes[i].left = tree_nodes[left]
        if right != -1:
            tree_nodes[i].right = tree_nodes[right]

    return tree_nodes[1]


def tree_depth(root):
    if not root:
        return 0
    left_depth = tree_depth(root.left)
    right_depth = tree_depth(root.right)
    return max(left_depth, right_depth) + 1


def main():
    n = int(input())
    nodes = []
    index = 1
    for _ in range(n):
        left, right = map(int, input().split())
        nodes.append((left, right))

    root = build_tree(nodes)
    depth = tree_depth(root)
    print(depth)


if __name__ == "__main__":
    main()

```





###### ç»ƒä¹ M27638: æ±‚äºŒå‰æ ‘çš„é«˜åº¦å’Œå¶å­æ•°ç›®

http://cs101.openjudge.cn/practice/27638/

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ±‚è¯¥äºŒå‰æ ‘çš„é«˜åº¦å’Œå¶å­æ•°ç›®äºŒå‰æ ‘**é«˜åº¦**å®šä¹‰ï¼šä»æ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„ç»“ç‚¹æ•°å‡1ä¸ºæ ‘çš„é«˜åº¦ã€‚åªæœ‰ä¸€ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ï¼Œé«˜åº¦æ˜¯0ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºäºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚äºŒå‰æ ‘ç»“ç‚¹ç¼–å·ä»0åˆ°n-1ï¼Œæ ¹ç»“ç‚¹n <= 100 æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œä¾æ¬¡å¯¹åº”äºŒå‰æ ‘çš„ç¼–å·ä¸º0,1,2....n-1çš„èŠ‚ç‚¹ã€‚ æ¯è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„å·¦å„¿å­å’Œå³å„¿å­çš„ç¼–å·ã€‚å¦‚æœç¬¬ä¸€ä¸ªï¼ˆç¬¬äºŒä¸ªï¼‰æ•°ä¸º-1åˆ™è¡¨ç¤ºæ²¡æœ‰å·¦ï¼ˆå³ï¼‰å„¿å­

**è¾“å‡º**

åœ¨ä¸€è¡Œä¸­è¾“å‡º2ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤ºäºŒå‰æ ‘çš„é«˜åº¦å’Œå¶å­ç»“ç‚¹ä¸ªæ•°

æ ·ä¾‹è¾“å…¥

```
3
-1 -1
0 2
-1 -1
```

æ ·ä¾‹è¾“å‡º

```
1 2
```



æ ¹æ®è¾“å…¥å»ºæ ‘ï¼Œ<mark>æ‰¾åˆ°æ ‘æ ¹</mark>ã€‚

```python
class TreeNode:
    def __init__(self):
        self.left = None
        self.right = None

def tree_height(node):
    if node is None:
        return -1  # æ ¹æ®å®šä¹‰ï¼Œç©ºæ ‘é«˜åº¦ä¸º-1
    return max(tree_height(node.left), tree_height(node.right)) + 1

def count_leaves(node):
    if node is None:
        return 0
    if node.left is None and node.right is None:
        return 1
    return count_leaves(node.left) + count_leaves(node.right)

n = int(input())  # è¯»å–èŠ‚ç‚¹æ•°é‡
nodes = [TreeNode() for _ in range(n)]
has_parent = [False] * n  # ç”¨æ¥æ ‡è®°èŠ‚ç‚¹æ˜¯å¦æœ‰çˆ¶èŠ‚ç‚¹

for i in range(n):
    left_index, right_index = map(int, input().split())
    if left_index != -1:
        nodes[i].left = nodes[left_index]
        has_parent[left_index] = True
    if right_index != -1:
        #print(right_index)
        nodes[i].right = nodes[right_index]
        has_parent[right_index] = True

# å¯»æ‰¾æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹
root_index = has_parent.index(False)
root = nodes[root_index]

# è®¡ç®—é«˜åº¦å’Œå¶å­èŠ‚ç‚¹æ•°
height = tree_height(root)
leaves = count_leaves(root)

print(f"{height} {leaves}")
```






#### 3. åˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒ

```python
def is_same_tree(p, q):
    if not p and not q:
        return True
    if not p or not q:
        return False
    return (p.val == q.val and
            is_same_tree(p.left, q.left) and
            is_same_tree(p.right, q.right))
```



###### ç¤ºä¾‹LC101.å¯¹ç§°äºŒå‰æ ‘

https://leetcode.cn/problems/symmetric-tree/

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3]
è¾“å‡ºï¼štrue
```

**ç¤ºä¾‹ 2ï¼š**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3]
è¾“å‡ºï¼šfalse
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[1, 1000]` å†…
- `-100 <= Node.val <= 100`



```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        def isMirror(left: TreeNode, right: TreeNode) -> bool:
            if not left and not right:
                return True
            if not left or not right:
                return False
            return (left.val == right.val) and isMirror(left.left, right.right) and isMirror(left.right, right.left)

        return isMirror(root.left, root.right)
```



#### 4. ç¿»è½¬äºŒå‰æ ‘

```python
def invert_tree(root):
    if root:
        root.left, root.right = invert_tree(root.right), invert_tree(root.left)
    return root
```



###### ç¤ºä¾‹LC226.ç¿»è½¬äºŒå‰æ ‘

https://leetcode.cn/problems/invert-binary-tree/

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9]
è¾“å‡ºï¼š[4,7,2,9,6,3,1]
```

**ç¤ºä¾‹ 2ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [2,1,3]
è¾“å‡ºï¼š[2,3,1]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

 

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´åœ¨ `[0, 100]` å†…
- `-100 <= Node.val <= 100`



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```





#### 5. å¯»æ‰¾äºŒå‰æœç´¢æ ‘ä¸­çš„æœ€å°å€¼/æœ€å¤§å€¼

å¯¹äºäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ï¼Œæœ€å°å€¼åœ¨æœ€å·¦è¾¹ï¼Œæœ€å¤§å€¼åœ¨æœ€å³è¾¹ã€‚<mark>BSTå„ç§ç¿»è¯‘çš„åå­—éƒ½éœ€è¦è®¤è¯†</mark>ã€‚

| ä¸­æ–‡ç¿»è¯‘   | è‹±æ–‡åŸå           | ä½¿ç”¨åœºæ™¯                 |
| ---------- | ------------------ | ------------------------ |
| äºŒå‰æœç´¢æ ‘ | Binary Search Tree | æœ€å¸¸è§ç¿»è¯‘ï¼Œé€šç”¨æ€§å¼º     |
| äºŒå‰æŸ¥æ‰¾æ ‘ | Binary Search Tree | å¼ºè°ƒæŸ¥æ‰¾åŠŸèƒ½             |
| äºŒå‰æ’åºæ ‘ | Binary Search Tree | å¼ºè°ƒæ’åºç‰¹æ€§             |
| äºŒå‰æ£€ç´¢æ ‘ | Binary Search Tree | å¼ºè°ƒæ£€ç´¢åŠŸèƒ½             |
| æœ‰åºäºŒå‰æ ‘ | Binary Search Tree | å¼ºè°ƒæœ‰åºæ€§               |
| BST        | Binary Search Tree | æŠ€æœ¯æ–‡æ¡£ã€ä»£ç æ³¨é‡Šä¸­å¸¸ç”¨ |

```python
def find_min(root):
    if not root.left:
        return root.val
    return find_min(root.left)

def find_max(root):
    if not root.right:
        return root.val
    return find_max(root.right)
```



###### ç»ƒä¹ LC230.äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 

https://leetcode.cn/problems/kth-smallest-element-in-a-bst/

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œå’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ `k` å°çš„å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [3,1,4,null,2], k = 1
è¾“å‡ºï¼š1
```

**ç¤ºä¾‹ 2ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [5,3,6,2,4,null,null,1], k = 3
è¾“å‡ºï¼š3
```

 

 

**æç¤ºï¼š**

- æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ä¸º `n` ã€‚
- `1 <= k <= n <= 104`
- `0 <= Node.val <= 104`

 

**è¿›é˜¶ï¼š**å¦‚æœäºŒå‰æœç´¢æ ‘ç»å¸¸è¢«ä¿®æ”¹ï¼ˆæ’å…¥/åˆ é™¤æ“ä½œï¼‰å¹¶ä¸”ä½ éœ€è¦é¢‘ç¹åœ°æŸ¥æ‰¾ç¬¬ `k` å°çš„å€¼ï¼Œä½ å°†å¦‚ä½•ä¼˜åŒ–ç®—æ³•ï¼Ÿ



```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def pre_order(node):
            if not node or len(res) == k:
                return
            pre_order(node.left)
            if len(res) == k:
                return
            res.append(node.val)
            if len(res) == k:
                return
            pre_order(node.right)
        
        pre_order(root)
        return res[-1]
        
```



#### 6. åˆ¤æ–­æ˜¯å¦ä¸ºå¹³è¡¡äºŒå‰æ ‘

ä¸€ä¸ªäºŒå‰æ ‘æ˜¯å¹³è¡¡çš„ï¼Œå¦‚æœå®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡1ã€‚

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_balanced(root):
    def check_height(node):
        if not node:
            return 0
        
        left_height = check_height(node.left)
        if left_height == -1:
            return -1  # Left subtree is unbalanced
        
        right_height = check_height(node.right)
        if right_height == -1:
            return -1  # Right subtree is unbalanced
        
        if abs(left_height - right_height) > 1:
            return -1  # Current node is unbalanced
        
        return max(left_height, right_height) + 1
    
    return check_height(root) != -1


# æ„å»ºå¦‚ä¸‹æ‰€ç¤ºçš„å¹³è¡¡äºŒå‰æ ‘ï¼š
#         3
#        / \
#       9  20
#         /  \
#        15   7

root_balanced = TreeNode(3)
root_balanced.left = TreeNode(9)
root_balanced.right = TreeNode(20, TreeNode(15), TreeNode(7))

print("Balanced Tree:", "Yes" if is_balanced(root_balanced) else "No")
# Balanced Tree: Yes

# æ„å»ºå¦‚ä¸‹æ‰€ç¤ºçš„ä¸å¹³è¡¡äºŒå‰æ ‘ï¼š
#         1
#          \
#           2
#            \
#             3
#              \
#               4

root_unbalanced = TreeNode(1)
root_unbalanced.right = TreeNode(2)
root_unbalanced.right.right = TreeNode(3)
root_unbalanced.right.right.right = TreeNode(4)

print("Unbalanced Tree:", "Yes" if is_balanced(root_unbalanced) else "No")
# Unbalanced Tree: No
```

ä»¥ä¸Šè¿™äº›ä¾‹å­å±•ç¤ºäº†å¦‚ä½•é€šè¿‡é€’å½’ä¼˜é›…åœ°è§£å†³ä¸€äº›å¸¸è§çš„æ ‘é—®é¢˜ã€‚é€’å½’è§£æ³•é€šå¸¸èƒ½å¤Ÿæ¸…æ™°åœ°è¡¨è¾¾ç®—æ³•é€»è¾‘ï¼Œä½¿å¾—ä»£ç æ›´åŠ å®¹æ˜“ç†è§£å’Œç»´æŠ¤ã€‚ä¸è¿‡ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œé€’å½’å¯èƒ½ä¼šå¯¼è‡´æ ˆæº¢å‡ºçš„é—®é¢˜ï¼Œå°¤å…¶æ˜¯åœ¨å¤„ç†éå¸¸æ·±çš„æ ‘æ—¶ã€‚ç„¶è€Œï¼Œé€šå¸¸æ ‘çš„é¢˜ç›®ä¸å¡æ—¶é—´ï¼Œå› æ­¤é€’å½’å†™æ³•é€šå¸¸æ˜¯é¦–é€‰</mark>ã€‚



### 1.3 ç¼–ç¨‹é¢˜ç›®more

åŠ›æ‰£çƒ­é¢˜100ä¸­ï¼Œæœ‰15ä¸ªé¢˜ç›®æ˜¯äºŒå‰æ ‘ç›¸å…³ï¼Œæ˜¯æ¯”é‡æœ€å¤§çš„ä¸€ç±»é¢˜ç›®ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250325135922245.png" alt="image-20250325135922245" style="zoom:50%;" />



ã€Šç®—æ³•ç¬”è®°ã€‹é…å¥—æ™´é—®ç½‘ç«™ä¸­ï¼Œæœ‰46ä¸ªé¢˜ç›®æ˜¯æ ‘ç›¸å…³ï¼Œæ˜¯æ¯”é‡æœ€å¤§çš„ä¸€ç±»é¢˜ç›®ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250325140647186.png" alt="image-20250325140647186" style="zoom: 33%;" />





## 2 ğŸŒ²çš„è¡¨ç¤ºæ–¹æ³•Representation

https://blog.csdn.net/qq_41891805/article/details/104473065

2020-02-24

æ ‘æ˜¯n (n>=0) ä¸ªç»“ç‚¹çš„æœ‰é™é›†ã€‚åœ¨ä»»æ„ä¸€æ£µéç©ºæ ‘ä¸­ï¼š
ï¼ˆ1ï¼‰æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæ ¹ç»“ç‚¹ï¼›ï¼ˆ2ï¼‰é™¤æ ¹ç»“ç‚¹å¤–ï¼Œå…¶ä½™çš„ç»“ç‚¹å¯åˆ†ä¸ºm (m>=0) ä¸ªäº’ä¸ç›¸äº¤çš„å­æ ‘ã€‚



**æ ‘çš„è¡¨ç¤ºæ–¹æ³•åŒ…æ‹¬**

### 2.1 åµŒå¥—æ‹¬å·è¡¨ç¤ºæ³• 

Nested parentheses representation æ˜¯ä¸€ç§è¡¨ç¤ºæ ‘ç»“æ„çš„æ–¹æ³•ï¼Œé€šè¿‡æ‹¬å·çš„åµŒå¥—æ¥è¡¨ç¤ºæ ‘çš„å±‚æ¬¡å…³ç³»ã€‚

å…ˆå°†æ ¹ç»“ç‚¹æ”¾å…¥ä¸€å¯¹åœ†æ‹¬å·ä¸­ï¼Œç„¶åæŠŠå®ƒçš„å­æ ‘æŒ‰ç”±å·¦è€Œå³çš„é¡ºåºæ”¾å…¥æ‹¬å·ä¸­ï¼Œè€Œå¯¹å­æ ‘ä¹Ÿé‡‡ç”¨åŒæ ·æ–¹æ³•å¤„ç†ï¼šåŒå±‚å­æ ‘ä¸å®ƒçš„æ ¹ç»“ç‚¹ç”¨åœ†æ‹¬å·æ‹¬èµ·æ¥ï¼ŒåŒå±‚å­æ ‘ä¹‹é—´ç”¨é€—å·éš”å¼€ï¼Œæœ€åç”¨é—­æ‹¬å·æ‹¬èµ·æ¥ã€‚ä¾‹å¦‚ä¸‹å›¾å¯å†™æˆå¦‚ä¸‹å½¢å¼
$(a(b,c,d,e))$
    a
/ | | \
b c d e



#### ç»ƒä¹ T27637:æ‹¬å·åµŒå¥—äºŒå‰æ ‘

dfs, stack, http://cs101.openjudge.cn/practice/27637

å¯ä»¥ç”¨æ‹¬å·åµŒå¥—çš„æ–¹å¼æ¥è¡¨ç¤ºä¸€æ£µäºŒå‰æ ‘ã€‚

æ–¹æ³•å¦‚ä¸‹ï¼š

`*`è¡¨ç¤ºç©ºçš„äºŒå‰æ ‘ã€‚å¦‚æœä¸€æ£µäºŒå‰æ ‘åªæœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œåˆ™è¯¥æ ‘å°±ç”¨ä¸€ä¸ªé`*`å­—ç¬¦è¡¨ç¤ºï¼Œä»£è¡¨å…¶æ ¹ç»“ç‚¹ã€‚

å¦‚æœä¸€æ£µäºŒå‰å·¦å³å­æ ‘éƒ½éç©ºï¼Œåˆ™ç”¨â€œæ ‘æ ¹(å·¦å­æ ‘,å³å­æ ‘)â€çš„å½¢å¼è¡¨ç¤ºã€‚æ ‘æ ¹æ˜¯ä¸€ä¸ªé'*'å­—ç¬¦ï¼Œå·¦å³å­æ ‘ä¹‹é—´ç”¨é€—å·éš”å¼€ï¼Œæ²¡æœ‰ç©ºæ ¼ã€‚å·¦å³å­æ ‘éƒ½ç”¨æ‹¬å·åµŒå¥—æ³•è¡¨ç¤ºã€‚

å¦‚æœå·¦å­æ ‘éç©ºè€Œå³å­æ ‘ä¸ºç©ºï¼Œåˆ™ç”¨`æ ‘æ ¹(å·¦å­æ ‘,*)`å½¢å¼è¡¨ç¤ºï¼›å¦‚æœå·¦å­æ ‘ä¸ºç©ºè€Œå³å­æ ‘éç©ºï¼Œåˆ™ç”¨<mark>`æ ‘æ ¹(*,å³å­æ ‘)`</mark>å½¢å¼è¡¨ç¤ºã€‚

ç»™å‡ºä¸€æ£µæ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼ï¼Œè¯·è¾“å‡ºå…¶å‰åºéå†åºåˆ—ã€ä¸­åºéå†åºåˆ—ã€ååºéå†åºåˆ—ã€‚ä¾‹å¦‚ï¼Œ`A(B(*,C),D(E))`è¡¨ç¤ºçš„äºŒå‰æ ‘å¦‚å›¾æ‰€ç¤º

<img src="http://media.openjudge.cn/images/upload/1636/1707558029.jpg" alt="img" style="zoom:67%;" />

è¾“å…¥

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°nè¡¨ç¤ºæœ‰næ£µäºŒå‰æ ‘(n<100) æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œæ¯è¡Œæ˜¯1æ£µäºŒå‰æ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼

è¾“å‡º

å¯¹æ¯æ£µäºŒå‰æ ‘ï¼Œè¾“å‡ºå…¶å‰åºéå†åºåˆ—å’Œä¸­åºéå†åºåˆ—

æ ·ä¾‹è¾“å…¥

```
2
A
A(B(*,C),D(E,*))
```

æ ·ä¾‹è¾“å‡º

```
A
A
ABCDE
BCAED
```

æ¥æºï¼šæ”¹ç¼–è‡ª http://dsbpython.openjudge.cn/dspythonbook/P0680/



å°†è¾“å…¥çš„æ‹¬å·åµŒå¥—å½¢å¼è½¬æ¢æˆäºŒå‰æ ‘ï¼Œç„¶åå®ç°äº†å‰åºå’Œä¸­åºéå†ã€‚

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None


def parse_tree(s):
    """ è§£ææ‹¬å·åµŒå¥—æ ¼å¼çš„äºŒå‰æ ‘ """
    if s == '*':  # å¤„ç†ç©ºæ ‘
        return None
    if '(' not in s:  # åªæœ‰å•ä¸ªæ ¹èŠ‚ç‚¹
        return TreeNode(s)

    root_value = s[0]  # æ ¹èŠ‚ç‚¹å€¼
    subtrees = s[2:-1]  # å»æ‰æ ¹èŠ‚ç‚¹å’Œå¤–å±‚æ‹¬å·

    # ä½¿ç”¨æ ˆæ‰¾åˆ°é€—å·ä½ç½®
    stack = []
    comma_index = None
    for i, char in enumerate(subtrees):
        if char == '(':
            stack.append(char)
        elif char == ')':
            stack.pop()
        elif char == ',' and not stack:
            comma_index = i
            break

    left_subtree = subtrees[:comma_index] if comma_index is not None else subtrees
    right_subtree = subtrees[comma_index + 1:] if comma_index is not None else None

    root = TreeNode(root_value)
    root.left = parse_tree(left_subtree)  # è§£æå·¦å­æ ‘
    root.right = parse_tree(right_subtree) if right_subtree else None  # è§£æå³å­æ ‘
    return root


def preorder_traversal(root):
    """å‰åºéå†ï¼šæ ¹ -> å·¦ -> å³"""
    return root.value + preorder_traversal(root.left) + preorder_traversal(root.right) if root else ""


def inorder_traversal(root):
    """ä¸­åºéå†ï¼šå·¦ -> æ ¹ -> å³"""
    return inorder_traversal(root.left) + root.value + inorder_traversal(root.right) if root else ""


# è¯»å–è¾“å…¥
n = int(input().strip())  
results = []

for _ in range(n):
    tree_string = input().strip().replace(" ", "")  # å»æ‰å¯èƒ½çš„ç©ºæ ¼
    tree = parse_tree(tree_string)
    results.append(preorder_traversal(tree))
    results.append(inorder_traversal(tree))

print("\n".join(results))  # æŒ‰æ ¼å¼è¾“å‡º

```





### 2.2 æ ‘å½¢è¡¨ç¤º

<mark>Node-Based</mark> or Node-Link structure
In computer science, a general tree is typically represented using this data structure. Each node in the tree contains information and references (links) to its child nodes.

```mermaid
graph TD
    A((A)); 
    B((B)); C((C)); D((D));
    E((E)); F((F)); G((G)); H((H)); I((I)); J((J));
    K((K)); L((L)); M((M))
    A --- B; A --- C; A --- D
    B --- E; B --- F; C --- G; D --- H; D --- I; D --- J;
    E --- K; E --- L; H --- M
```

> å®ƒçš„åµŒå¥—æ‹¬å·è¡¨ç¤ºä¸ºï¼š
>
> $(A(B(E(K,L),F),C(G),D(H(M),I,J))$â€‹
>



#### ç»ƒä¹ M08581: æ‰©å±•äºŒå‰æ ‘

http://cs101.openjudge.cn/practice/08581/

ç”±äºå…ˆåºã€ä¸­åºå’Œååºåºåˆ—ä¸­çš„ä»»ä¸€ä¸ªéƒ½ä¸èƒ½å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ‰€ä»¥å¯¹äºŒå‰æ ‘åšå¦‚ä¸‹å¤„ç†ï¼Œå°†äºŒå‰æ ‘çš„ç©ºç»“ç‚¹ç”¨Â·è¡¥é½ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚æˆ‘ä»¬æŠŠè¿™æ ·å¤„ç†åçš„äºŒå‰æ ‘ç§°ä¸ºåŸäºŒå‰æ ‘çš„æ‰©å±•äºŒå‰æ ‘ï¼Œæ‰©å±•äºŒå‰æ ‘çš„å…ˆåºå’Œååºåºåˆ—èƒ½å”¯ä¸€ç¡®å®šå…¶äºŒå‰æ ‘ã€‚ ç°ç»™å‡ºæ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—ï¼Œè¦æ±‚è¾“å‡ºå…¶ä¸­åºå’Œååºåºåˆ—ã€‚

![img](http://media.openjudge.cn/images/upload/1440300244.png)

**è¾“å…¥**

æ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—ï¼ˆå…¨éƒ¨éƒ½ç”±å¤§å†™å­—æ¯æˆ–è€….ç»„æˆï¼‰

**è¾“å‡º**

ç¬¬ä¸€è¡Œï¼šä¸­åºåºåˆ—
ç¬¬äºŒè¡Œï¼šååºåºåˆ—

æ ·ä¾‹è¾“å…¥

```
ABD..EF..G..C..
```

æ ·ä¾‹è¾“å‡º

```
DBFEGAC
DFGEBCA
```



é€šè¿‡é€’å½’æ–¹æ³•è§£ææ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—ï¼Œå¹¶è¾“å‡ºå…¶ä¸­åºå’Œååºåºåˆ—ï¼š

```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def build_tree(s, index):
    # å¦‚æœå½“å‰å­—ç¬¦ä¸º'.'ï¼Œè¡¨ç¤ºç©ºç»“ç‚¹ï¼Œè¿”å›Noneï¼Œå¹¶å°†ç´¢å¼•åç§»ä¸€ä½
    if s[index] == '.':
        return None, index + 1
    # å¦åˆ™åˆ›å»ºä¸€ä¸ªç»“ç‚¹
    node = Node(s[index])
    index += 1
    # é€’å½’æ„é€ å·¦å­æ ‘
    node.left, index = build_tree(s, index)
    # é€’å½’æ„é€ å³å­æ ‘
    node.right, index = build_tree(s, index)
    return node, index

def inorder(node, res):
    if node is None:
        return
    inorder(node.left, res)
    res.append(node.val)
    inorder(node.right, res)

def postorder(node, res):
    if node is None:
        return
    postorder(node.left, res)
    postorder(node.right, res)
    res.append(node.val)

def main():
    s = input().strip()
    root, _ = build_tree(s, 0)
    
    in_res = []
    inorder(root, in_res)
    
    post_res = []
    postorder(root, post_res)
    
    print("".join(in_res))
    print("".join(post_res))

if __name__ == '__main__':
    main()
```

ä»£ç è¯´æ˜

- **build_tree å‡½æ•°**  
  é€’å½’åœ°æ ¹æ®æ‰©å±•äºŒå‰æ ‘çš„å…ˆåºåºåˆ—æ„é€ äºŒå‰æ ‘ï¼š  
  - å½“é‡åˆ° `'.'` æ—¶è¡¨ç¤ºç©ºç»“ç‚¹ï¼Œç›´æ¥è¿”å› `None`ã€‚  
  - å¦åˆ™ä»¥å½“å‰å­—ç¬¦åˆ›å»ºä¸€ä¸ªç»“ç‚¹ï¼Œç„¶åé€’å½’æ„é€ å…¶å·¦å­æ ‘å’Œå³å­æ ‘ã€‚

- **inorder å’Œ postorder å‡½æ•°**  
  åˆ†åˆ«å®ç°ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰å’Œååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰ã€‚

- **main å‡½æ•°**  
  è¯»å–è¾“å…¥å­—ç¬¦ä¸²ï¼Œæ„é€ æ ‘åè®¡ç®—ä¸­åºå’Œååºéå†ç»“æœï¼Œå¹¶è¾“å‡ºã€‚  





### 2.3 æ–‡æ°å›¾

Venn diagram

Vennå›¾æ˜¯åœ¨æ‰€è°“çš„é›†åˆè®ºï¼ˆæˆ–è€…ç±»çš„ç†è®ºï¼‰æ•°å­¦åˆ†æ”¯ä¸­ï¼Œåœ¨ä¸å¤ªä¸¥æ ¼çš„æ„ä¹‰ä¸‹ç”¨ä»¥è¡¨ç¤ºé›†åˆï¼ˆæˆ–ç±»ï¼‰çš„ä¸€ç§è‰å›¾ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250324204152280.png" alt="image-20250324204152280" style="zoom:67%;" />

### 2.4 å‡¹å…¥è¡¨

Indented Tree Representation

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://raw.githubusercontent.com/GMyhf/img/main/img/20200224102939456.png)



#### ç»ƒä¹ T02775: æ–‡ä»¶ç»“æ„â€œå›¾â€

http://cs101.openjudge.cn/practice/02775/

åœ¨è®¡ç®—æœºä¸Šçœ‹åˆ°æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„é€šå¸¸å¾ˆæœ‰ç”¨ã€‚Microsoft Windowsä¸Šé¢çš„"explorer"ç¨‹åºå°±æ˜¯è¿™æ ·çš„ä¸€ä¸ªä¾‹å­ã€‚ä½†æ˜¯åœ¨æœ‰å›¾å½¢ç•Œé¢ä¹‹å‰ï¼Œæ²¡æœ‰å›¾å½¢åŒ–çš„è¡¨ç¤ºæ–¹æ³•çš„ï¼Œé‚£æ—¶å€™æœ€å¥½çš„æ–¹å¼æ˜¯æŠŠç›®å½•å’Œæ–‡ä»¶çš„ç»“æ„æ˜¾ç¤ºæˆä¸€ä¸ª"å›¾"çš„æ ·å­ï¼Œè€Œä¸”ä½¿ç”¨ç¼©æ’çš„å½¢å¼æ¥è¡¨ç¤ºç›®å½•çš„ç»“æ„ã€‚æ¯”å¦‚ï¼š



```
ROOT
|     dir1
|     file1
|     file2
|     file3
|     dir2
|     dir3
|     file1
file1
file2
```

è¿™ä¸ªå›¾è¯´æ˜ï¼šROOTç›®å½•åŒ…æ‹¬ä¸‰ä¸ªå­ç›®å½•å’Œä¸¤ä¸ªæ–‡ä»¶ã€‚ç¬¬ä¸€ä¸ªå­ç›®å½•åŒ…å«3ä¸ªæ–‡ä»¶ï¼Œç¬¬äºŒä¸ªå­ç›®å½•æ˜¯ç©ºçš„ï¼Œç¬¬ä¸‰ä¸ªå­ç›®å½•åŒ…å«ä¸€ä¸ªæ–‡ä»¶ã€‚

**è¾“å…¥**

ä½ çš„ä»»åŠ¡æ˜¯å†™ä¸€ä¸ªç¨‹åºè¯»å–ä¸€äº›æµ‹è¯•æ•°æ®ã€‚æ¯ç»„æµ‹è¯•æ•°æ®è¡¨ç¤ºä¸€ä¸ªè®¡ç®—æœºçš„æ–‡ä»¶ç»“æ„ã€‚æ¯ç»„æµ‹è¯•æ•°æ®ä»¥`*`ç»“å°¾ï¼Œè€Œæ‰€æœ‰åˆç†çš„è¾“å…¥æ•°æ®ä»¥`#`ç»“å°¾ã€‚ä¸€ç»„æµ‹è¯•æ•°æ®åŒ…æ‹¬ä¸€äº›æ–‡ä»¶å’Œç›®å½•çš„åå­—ï¼ˆè™½ç„¶åœ¨è¾“å…¥ä¸­æˆ‘ä»¬æ²¡æœ‰ç»™å‡ºï¼Œä½†æ˜¯æˆ‘ä»¬æ€»å‡è®¾ROOTç›®å½•æ˜¯æœ€å¤–å±‚çš„ç›®å½•ï¼‰ã€‚åœ¨è¾“å…¥ä¸­,ä»¥`]`è¡¨ç¤ºä¸€ä¸ªç›®å½•çš„å†…å®¹çš„ç»“æŸã€‚ç›®å½•åå­—çš„ç¬¬ä¸€ä¸ªå­—æ¯æ˜¯'d'ï¼Œæ–‡ä»¶åå­—çš„ç¬¬ä¸€ä¸ªå­—æ¯æ˜¯`f`ã€‚æ–‡ä»¶åå¯èƒ½æœ‰æ‰©å±•åä¹Ÿå¯èƒ½æ²¡æœ‰ï¼ˆæ¯”å¦‚`fmyfile.dat`å’Œ`fmyfile`ï¼‰ã€‚æ–‡ä»¶å’Œç›®å½•çš„åå­—ä¸­éƒ½ä¸åŒ…æ‹¬ç©ºæ ¼,é•¿åº¦éƒ½ä¸è¶…è¿‡30ã€‚ä¸€ä¸ªç›®å½•ä¸‹çš„å­ç›®å½•ä¸ªæ•°å’Œæ–‡ä»¶ä¸ªæ•°ä¹‹å’Œä¸è¶…è¿‡30ã€‚

**è¾“å‡º**

åœ¨æ˜¾ç¤ºä¸€ä¸ªç›®å½•ä¸­å†…å®¹çš„æ—¶å€™ï¼Œå…ˆæ˜¾ç¤ºå…¶ä¸­çš„å­ç›®å½•ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œç„¶åå†æ˜¾ç¤ºæ–‡ä»¶ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ã€‚<u>æ–‡ä»¶è¦æ±‚æŒ‰ç…§åå­—çš„å­—æ¯è¡¨çš„é¡ºåºæ˜¾ç¤º</u>ï¼ˆç›®å½•ä¸ç”¨æŒ‰ç…§åå­—çš„å­—æ¯è¡¨é¡ºåºæ˜¾ç¤ºï¼Œåªéœ€è¦æŒ‰ç…§ç›®å½•å‡ºç°çš„å…ˆåæ˜¾ç¤ºï¼‰ã€‚å¯¹æ¯ä¸€ç»„æµ‹è¯•æ•°æ®ï¼Œæˆ‘ä»¬è¦å…ˆè¾“å‡º`DATA SET x:`ï¼Œè¿™é‡Œ`x`æ˜¯æµ‹è¯•æ•°æ®çš„ç¼–å·ï¼ˆä»1å¼€å§‹ï¼‰ã€‚åœ¨ä¸¤ç»„æµ‹è¯•æ•°æ®ä¹‹é—´è¦è¾“å‡ºä¸€ä¸ªç©ºè¡Œæ¥éš”å¼€ã€‚

ä½ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª`|`å’Œ5ä¸ªç©ºæ ¼æ¥è¡¨ç¤ºå‡ºç¼©æ’çš„å±‚æ¬¡ã€‚

æ ·ä¾‹è¾“å…¥

```
file1
file2
dir3
dir2
file1
file2
]
]
file4
dir1
]
file3
*
file2
file1
*
#
```

æ ·ä¾‹è¾“å‡º

```
DATA SET 1:
ROOT
|     dir3
|     |     dir2
|     |     file1
|     |     file2
|     dir1
file1
file2
file3
file4

DATA SET 2:
ROOT
file1
file2
```

æç¤º

ä¸€ä¸ªç›®å½•å’Œå®ƒçš„å­ç›®å½•å¤„äºä¸åŒçš„å±‚æ¬¡
ä¸€ä¸ªç›®å½•å’Œå®ƒçš„é‡Œé¢çš„æ–‡ä»¶å¤„äºåŒä¸€å±‚æ¬¡

æ¥æº

ç¿»è¯‘è‡ª Pacific Northwest 1998 çš„è¯•é¢˜



```python
# å¤å¤©æ˜ï¼Œå…ƒåŸ¹å­¦é™¢
from sys import exit

class dir:
    def __init__(self, dname):
        self.name = dname
        self.dirs = []
        self.files = []
    
    def getGraph(self):
        g = [self.name]
        for d in self.dirs:
            subg = d.getGraph()
            g.extend(["|     " + s for s in subg])
        for f in sorted(self.files):
            g.append(f)
        return g

n = 0
while True:
    n += 1
    stack = [dir("ROOT")]
    while (s := input()) != "*":
        if s == "#": exit(0)
        if s[0] == 'f':
            stack[-1].files.append(s)
        elif s[0] == 'd':
            stack.append(dir(s))
            stack[-2].dirs.append(stack[-1])
        else:
            stack.pop()
    print(f"DATA SET {n}:")
    print(*stack[0].getGraph(), sep='\n')
    print()
```





### 2.5 é‚»æ¥è¡¨è¡¨ç¤ºæ³•

é‚»æ¥è¡¨è¡¨ç¤ºæ³•ï¼ˆAdjacency List Representationï¼‰æ˜¯ä¸€ç§å¸¸è§çš„æ ‘çš„è¡¨ç¤ºæ–¹æ³•ï¼Œç‰¹åˆ«<mark>é€‚ç”¨äºè¡¨ç¤ºç¨€ç–æ ‘</mark>ï¼ˆæ ‘ä¸­èŠ‚ç‚¹çš„åº¦æ•°ç›¸å¯¹è¾ƒå°ï¼‰ã€‚

åœ¨é‚»æ¥è¡¨è¡¨ç¤ºæ³•ä¸­ï¼Œ<mark>ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ ‘çš„èŠ‚ç‚¹ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ å¯¹åº”ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œä½¿ç”¨é“¾è¡¨æˆ–æ•°ç»„ç­‰æ•°æ®ç»“æ„æ¥å­˜å‚¨å®ƒçš„å­èŠ‚ç‚¹ã€‚</mark>

ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨é‚»æ¥è¡¨è¡¨ç¤ºæ³•è¡¨ç¤ºä¸€ä¸ªæ ‘ï¼š

å‡è®¾æˆ‘ä»¬æœ‰ä»¥ä¸‹æ ‘çš„ç»“æ„ï¼š

```
       A
     / | \
    B  C  D
   / \    \
  E   F    G
       \
        H
```

ä½¿ç”¨é‚»æ¥è¡¨è¡¨ç¤ºæ³•ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„è¡¨ç¤ºï¼š

```
A: ['B', 'C', 'D']
B: ['E', 'F']
E: []
F: ['H']
H: []
C: []
D: ['G']
G: []
```

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹ç”¨ä¸€ä¸ªæ•°ç»„æ¥è¡¨ç¤ºï¼Œæ•°ç»„çš„ç´¢å¼•å¯¹åº”èŠ‚ç‚¹çš„æ ‡è¯†ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œå­˜å‚¨äº†è¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€‚

è¿™ç§è¡¨ç¤ºæ–¹æ³•å¯ä»¥æœ‰æ•ˆåœ°å­˜å‚¨æ ‘çš„ç»“æ„ï¼Œå¹¶ä¸”å¯ä»¥å¿«é€Ÿåœ°æŸ¥æ‰¾å’Œè®¿é—®èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€‚

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []

def build_tree():
    # åˆ›å»ºæ ‘èŠ‚ç‚¹
    root = TreeNode('A')
    node_b = TreeNode('B')
    node_c = TreeNode('C')
    node_d = TreeNode('D')
    node_e = TreeNode('E')
    node_f = TreeNode('F')
    node_g = TreeNode('G')
    node_h = TreeNode('H')

    # æ„å»ºæ ‘çš„ç»“æ„
    root.children.extend([node_b, node_c, node_d])
    node_b.children.extend([node_e, node_f])
    node_d.children.append(node_g)
    node_f.children.append(node_h)

    return root

def print_tree_adjacency_list(root):
    adjacency_list = {}

    # é€’å½’æ„å»ºé‚»æ¥è¡¨
    def build_adjacency_list(node):
        adjacency_list[node.value] = [child.value for child in node.children]
        for child in node.children:
            build_adjacency_list(child)

    # æ„å»ºå¹¶æ‰“å°é‚»æ¥è¡¨
    build_adjacency_list(root)
    for node, children in adjacency_list.items():
        print(f"{node}: {children}")

# æ„å»ºæ ‘
root_node = build_tree()

# æ‰“å°é‚»æ¥è¡¨è¡¨ç¤ºçš„æ ‘
print_tree_adjacency_list(root_node)

"""
A: ['B', 'C', 'D']
B: ['E', 'F']
E: []
F: ['H']
H: []
C: []
D: ['G']
G: []
"""
```



é‚»æ¥è¡¨ï¼Œä¸é™Œç”Ÿã€‚

18182: æ‰“æ€ªå…½ï¼Œdata structures, http://cs101.openjudge.cn/practice/18182/

ç”¨å­—å…¸æ¨¡æ‹Ÿé‚»æ¥è¡¨ï¼Œå­˜å‚¨ç›¸åŒæ—¶åˆ»çš„æŠ€èƒ½ã€‚



#### ç»ƒä¹ T24729: æ‹¬å·åµŒå¥—æ ‘

http://cs101.openjudge.cn/practice/24729/

å¯ä»¥ç”¨æ‹¬å·åµŒå¥—çš„æ–¹å¼æ¥è¡¨ç¤ºä¸€æ£µæ ‘ã€‚è¡¨ç¤ºæ–¹æ³•å¦‚ä¸‹ï¼š

1) å¦‚æœä¸€æ£µæ ‘åªæœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œåˆ™è¯¥æ ‘å°±ç”¨ä¸€ä¸ªå¤§å†™å­—æ¯è¡¨ç¤ºï¼Œä»£è¡¨å…¶æ ¹ç»“ç‚¹ã€‚
2) å¦‚æœä¸€æ£µæ ‘æœ‰å­æ ‘ï¼Œåˆ™ç”¨â€œæ ‘æ ¹(å­æ ‘1,å­æ ‘2,...,å­æ ‘n)â€çš„å½¢å¼è¡¨ç¤ºã€‚æ ‘æ ¹æ˜¯ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œå­æ ‘ä¹‹é—´ç”¨é€—å·éš”å¼€ï¼Œæ²¡æœ‰ç©ºæ ¼ã€‚å­æ ‘éƒ½æ˜¯ç”¨æ‹¬å·åµŒå¥—æ³•è¡¨ç¤ºçš„æ ‘ã€‚

ç»™å‡ºä¸€æ£µä¸è¶…è¿‡26ä¸ªç»“ç‚¹çš„æ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼ï¼Œè¯·è¾“å‡ºå…¶å‰åºéå†åºåˆ—å’Œååºéå†åºåˆ—ã€‚

è¾“å…¥æ ·ä¾‹ä»£è¡¨çš„æ ‘å¦‚ä¸‹å›¾ï¼š

<img src="http://media.openjudge.cn/images/upload/5805/1653472173.png" alt="img" style="zoom:67%;" />

**è¾“å…¥**

ä¸€è¡Œï¼Œä¸€æ£µæ ‘çš„æ‹¬å·åµŒå¥—è¡¨ç¤ºå½¢å¼

**è¾“å‡º**

ä¸¤è¡Œã€‚ç¬¬ä¸€è¡Œæ˜¯æ ‘çš„å‰åºéå†åºåˆ—ï¼Œç¬¬äºŒè¡Œæ˜¯æ ‘çš„ååºéå†åºåˆ—



æ ·ä¾‹è¾“å…¥

```
A(B(E),C(F,G),D(H(I)))
```

æ ·ä¾‹è¾“å‡º

```
ABECFGDHI
EBFGCIHDA
```

æ¥æºï¼šGuo Wei



ä¸»è¦æ­¥éª¤ï¼š

1. **è§£ææ‹¬å·åµŒå¥—è¡¨ç¤º**ï¼šç”¨æ ˆæ¥æ„å»ºæ ‘ç»“æ„ï¼Œæ¯æ¬¡é‡åˆ°å­—æ¯åˆ›å»ºèŠ‚ç‚¹ï¼Œé‡åˆ° `)` å¼¹å‡ºæ ˆé¡¶èŠ‚ç‚¹è¡¨ç¤ºå­æ ‘ç»“æŸã€‚
2. **å‰åºéå†**ï¼šæ ¹èŠ‚ç‚¹ -> ä¾æ¬¡éå†å­èŠ‚ç‚¹ã€‚
3. **ååºéå†**ï¼šä¾æ¬¡éå†å­èŠ‚ç‚¹ -> æ ¹èŠ‚ç‚¹ã€‚

ä¸‹é¢ä¸¤ä¸ªä»£ç ã€‚å…ˆç»™å‡ºç”¨ç±»è¡¨ç¤ºnode

```python
class TreeNode:
    def __init__(self, value): #ç±»ä¼¼å­—å…¸
        self.value = value
        self.children = []

def parse_tree(s):
    stack = []
    node = None
    for char in s:
        if char.isalpha():  # å¦‚æœæ˜¯å­—æ¯ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹
            node = TreeNode(char)
            if stack:  # å¦‚æœæ ˆä¸ä¸ºç©ºï¼ŒæŠŠèŠ‚ç‚¹ä½œä¸ºå­èŠ‚ç‚¹åŠ å…¥åˆ°æ ˆé¡¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ—è¡¨ä¸­
                stack[-1].children.append(node)
        elif char == '(':  # é‡åˆ°å·¦æ‹¬å·ï¼Œå½“å‰èŠ‚ç‚¹å¯èƒ½ä¼šæœ‰å­èŠ‚ç‚¹
            if node:
                stack.append(node)  # æŠŠå½“å‰èŠ‚ç‚¹æ¨å…¥æ ˆä¸­
                node = None
        elif char == ')':  # é‡åˆ°å³æ‹¬å·ï¼Œå­èŠ‚ç‚¹åˆ—è¡¨ç»“æŸ
            if stack:
                node = stack.pop()  # å¼¹å‡ºå½“å‰èŠ‚ç‚¹
    return node  # æ ¹èŠ‚ç‚¹


def preorder(node):
    output = [node.value]
    for child in node.children:
        output.extend(preorder(child))
    return ''.join(output)

def postorder(node):
    output = []
    for child in node.children:
        output.extend(postorder(child))
    output.append(node.value)
    return ''.join(output)

# ä¸»ç¨‹åº
def main():
    s = input().strip()
    s = ''.join(s.split())  # å»æ‰æ‰€æœ‰ç©ºç™½å­—ç¬¦
    root = parse_tree(s)  # è§£ææ•´æ£µæ ‘
    if root:
        print(preorder(root))  # è¾“å‡ºå‰åºéå†åºåˆ—
        print(postorder(root))  # è¾“å‡ºååºéå†åºåˆ—
    else:
        print("input tree string error!")

if __name__ == "__main__":
    main()
```



ç”¨å­—å…¸è¡¨ç¤ºnode

```python
def parse_tree(s):
    stack = []
    node = None
    for char in s:
        if char.isalpha():  # å¦‚æœæ˜¯å­—æ¯ï¼Œåˆ›å»ºæ–°èŠ‚ç‚¹
            node = {'value': char, 'children': []}
            if stack:  # å¦‚æœæ ˆä¸ä¸ºç©ºï¼ŒæŠŠèŠ‚ç‚¹ä½œä¸ºå­èŠ‚ç‚¹åŠ å…¥åˆ°æ ˆé¡¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åˆ—è¡¨ä¸­
                stack[-1]['children'].append(node)
        elif char == '(':  # é‡åˆ°å·¦æ‹¬å·ï¼Œå½“å‰èŠ‚ç‚¹å¯èƒ½ä¼šæœ‰å­èŠ‚ç‚¹
            if node:
                stack.append(node)  # æŠŠå½“å‰èŠ‚ç‚¹æ¨å…¥æ ˆä¸­
                node = None
        elif char == ')':  # é‡åˆ°å³æ‹¬å·ï¼Œå­èŠ‚ç‚¹åˆ—è¡¨ç»“æŸ
            if stack:
                node = stack.pop()  # å¼¹å‡ºå½“å‰èŠ‚ç‚¹
    return node  # æ ¹èŠ‚ç‚¹


def preorder(node):
    output = [node['value']]
    for child in node['children']:
        output.extend(preorder(child))
    return ''.join(output)

def postorder(node):
    output = []
    for child in node['children']:
        output.extend(postorder(child))
    output.append(node['value'])
    return ''.join(output)

# ä¸»ç¨‹åº
def main():
    s = input().strip()
    s = ''.join(s.split())  # å»æ‰æ‰€æœ‰ç©ºç™½å­—ç¬¦
    root = parse_tree(s)  # è§£ææ•´æ£µæ ‘
    if root:
        print(preorder(root))  # è¾“å‡ºå‰åºéå†åºåˆ—
        print(postorder(root))  # è¾“å‡ºååºéå†åºåˆ—
    else:
        print("input tree string error!")

if __name__ == "__main__":
    main()
```



#### ç»ƒä¹ M27928:éå†æ ‘

http://cs101.openjudge.cn/practice/27928/

è¯·ä½ å¯¹è¾“å…¥çš„æ ‘åšéå†ã€‚éå†çš„è§„åˆ™æ˜¯ï¼šéå†åˆ°æ¯ä¸ªèŠ‚ç‚¹æ—¶ï¼ŒæŒ‰ç…§è¯¥èŠ‚ç‚¹å’Œæ‰€æœ‰å­èŠ‚ç‚¹çš„å€¼ä»å°åˆ°å¤§è¿›è¡Œéå†ï¼Œä¾‹å¦‚ï¼š

```
        7
    /   |   \
  10    3     6
```

å¯¹äºè¿™ä¸ªæ ‘ï¼Œä½ åº”è¯¥å…ˆéå†å€¼ä¸º3çš„å­èŠ‚ç‚¹ï¼Œç„¶åæ˜¯å€¼ä¸º6çš„å­èŠ‚ç‚¹ï¼Œç„¶åæ˜¯çˆ¶èŠ‚ç‚¹7ï¼Œæœ€åæ˜¯å€¼ä¸º10çš„å­èŠ‚ç‚¹ã€‚

æœ¬é¢˜ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ä¸ºäº’ä¸ç›¸åŒçš„æ­£æ•´æ•°ï¼Œæœ€å¤§ä¸è¶…è¿‡9999999ã€‚

è¾“å…¥

ç¬¬ä¸€è¡Œï¼šèŠ‚ç‚¹ä¸ªæ•°n (n<500)

æ¥ä¸‹æ¥çš„nè¡Œï¼šç¬¬ä¸€ä¸ªæ•°æ˜¯æ­¤èŠ‚ç‚¹çš„å€¼ï¼Œä¹‹åçš„æ•°åˆ†åˆ«è¡¨ç¤ºå®ƒçš„æ‰€æœ‰å­èŠ‚ç‚¹çš„å€¼ã€‚æ¯ä¸ªæ•°ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œè¯¥è¡Œä¾¿åªæœ‰ä¸€ä¸ªæ•°ã€‚

è¾“å‡º

è¾“å‡ºéå†ç»“æœï¼Œä¸€è¡Œä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚

æ ·ä¾‹è¾“å…¥

```
sample1 input:
4
7 10 3 6
10
6
3

sample1 output:
3
6
7
10
```

æ ·ä¾‹è¾“å‡º

```
sample2 input:
6
10 3 1
7
9 2 
2 10
3 7
1

sample2 output:
2
1
3
7
10
9
```

æ¥æºï¼š2024spring zht



æ€»ä½“æ€è·¯åˆ†ä¸ºä¸‰æ­¥ï¼š1.é€šè¿‡å­—å…¸å»ºç«‹è¾“å…¥æ•°æ®çš„çˆ¶å­å…³ç³»ï¼›2.æ‰¾åˆ°æ ‘çš„æ ¹ï¼ˆè¿™é‡Œæˆ‘å°†çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹åˆ†åˆ«ç”¨ä¸¤ä¸ªåˆ—è¡¨è®°å½•ï¼Œæœ€åä½¿ç”¨é›†åˆå‡æ³•ï¼‰ï¼›3.é€šè¿‡é€’å½’å®ç°è¦æ±‚çš„ä»å°åˆ°å¤§éå†ã€‚



```python
from collections import defaultdict
import sys
sys.setrecursionlimit(10000)

def main():
    n = int(sys.stdin.readline())
    tree = defaultdict(list)
    all_nodes = set()
    child_nodes = set()
    
    for _ in range(n):
        parts = list(map(int, sys.stdin.readline().split()))
        parent, *children = parts
        tree[parent].extend(children)
        all_nodes.add(parent)
        all_nodes.update(children)
        child_nodes.update(children)
    
    # æ ¹èŠ‚ç‚¹ = å‡ºç°åœ¨ all_nodes ä½†æ²¡å‡ºç°åœ¨ child_nodes çš„é‚£ä¸ª
    root = (all_nodes - child_nodes).pop()
    
    def traverse(u):
        # æŠŠ u è‡ªå·±å’Œå®ƒçš„æ‰€æœ‰ç›´æ¥å­©å­æ”¾ä¸€èµ·æ’åº
        group = tree[u] + [u]
        group.sort()
        for x in group:
            if x == u:
                print(u)
            else:
                traverse(x)
    
    traverse(root)

if __name__ == "__main__":
    main()

```





#### Height of a generic tree from parent array

https://www.geeksforgeeks.org/height-generic-tree-parent-array/

Last Updated : 01 Nov, 2024

ç»™å®šä¸€æ£µ**å¤§å°ä¸º n**çš„æ ‘ï¼Œä»¥æ•°ç»„ `parent[0..n-1]` çš„å½¢å¼è¡¨ç¤ºï¼Œå…¶ä¸­ `parent[]` ä¸­çš„æ¯ä¸ªç´¢å¼• `i` ä»£è¡¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œ `i` å¤„çš„å€¼è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„**ç›´æ¥çˆ¶èŠ‚ç‚¹**ã€‚å¯¹äºæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º **-1**ã€‚ <mark>æ ¹æ®ç»™å®šçš„çˆ¶èŠ‚ç‚¹é“¾æ¥ï¼Œæ±‚è¿™æ£µé€šç”¨æ ‘çš„**é«˜åº¦**ã€‚</mark>

> Given a tree of **size n** as array `parent[0..n-1]` where every index `i` in the `parent[]` represents a node and the value at `i` represents the **immediate parent** of that node. For root, the node value will be **-1**. <mark>Find the **height** of the generic tree given the parent links.</mark>
>

**Examples:** 

> ```
> Input : parent[] = [-1, 0, 0, 0, 3, 1, 1, 2]
> Output : 2
> ```
>
> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/Tree7-300x151.jpg" alt="Height of a generic tree from parent array 1" style="zoom:67%;" />
>
> ```
> Input  : parent[] = [-1, 0, 1, 2, 3]
> Output : 4
> ```
>
> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/Tree-_5.jpg" alt="Height of a generic tree from parent array 2" style="zoom: 67%;" />
>
> 
>
> 
>
> Here, a **generic tree** is sometimes also called an N-ary tree or N-way tree where N denotes the maximum number of child a node can have. In this problem, the array represents n number of nodes in the tree.



æœ´ç´ çš„æ–¹æ³•æ˜¯ä»**èŠ‚ç‚¹**å‘ä¸Š**éå†**æ ‘ï¼Œç›´åˆ°åˆ°è¾¾å€¼ä¸º **-1** çš„**æ ¹èŠ‚ç‚¹**ã€‚åœ¨éå†æ¯ä¸ªèŠ‚ç‚¹æ—¶ï¼Œè®°å½•**æœ€å¤§è·¯å¾„é•¿åº¦**ã€‚è¯¥è§£å†³æ–¹æ¡ˆçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚

> The naive approach is to **traverse** up the tree from the **node** till the **root node** is reached with node **value -1**. While Traversing for each node stores **maximum path length**. The Time Complexity of this solution is $O(n^2)$.
>



**[Expected Approach â€“ 1] Using BFS â€“ O(n) Time and O(n) Space**

> Build **graph** for **N-ary Tree in O(n)** time and apply **BFS** on the stored graph in **O(n)** time and while doing BFS store **maximum reached level.** This solution does **two iterations** to find the **height** of N-ary tree.

**Implementation:**

```python
# find height of N-ary tree in O(n)
from collections import deque

MAX = 1001
adj = [[] for i in range(MAX)] # Adjacency list to store N-ary tree

def build_tree(arr, n): # Build tree in tree in O(n)
    root_index = 0

    for i in range(n):
        if (arr[i] == -1): # if root node, store index
            root_index = i
        else:
            adj[i].append(arr[i])
            adj[arr[i]].append(i)

    return root_index


def BFS(start):
    vis = {} # map is used as visited array

    q = deque()
    max_level_reached = 0

    q.append([start, 0]) # height of root node is zero

    # p[0] denotes node in adjacency list
    # p[1] denotes level of p[0]
    p = []

    while (len(q) > 0):
        p = q.popleft()
        vis[p[0]] = 1

        max_level_reached = max(max_level_reached, p[1])

        for i in range(len(adj[p[0]])):
            if (adj[p[0]][i] not in vis):
                q.append([adj[p[0]][i], p[1] + 1]) # adding 1 to pre_level

    return max_level_reached


# Driver code
if __name__ == '__main__':
    parent = [-1, 0, 1, 2, 3] # node 0 to node n-1
    n = len(parent) # Number of nodes in tree

    root_index = build_tree(parent, n)
    ma = BFS(root_index)
    print("Height of N-ary Tree =", ma)

# output: Height of N-ary Tree = 4

```

**Time Complexity:** O(n) which converges to O(n) for very large n.
**Auxiliary Space:** O(n), we are using an <mark>adjacency list</mark> to store the tree in memory. The size of the adjacency list is proportional to the number of nodes in the tree, so the space complexity of the algorithm is O(n).



**[Expected Approach â€“ 2\] Without using map â€“ O(n) Time and O(n) Space**

æˆ‘ä»¬å¯ä»¥åœ¨**ä¸€æ¬¡è¿­ä»£**ä¸­æ‰¾åˆ°**Nå‰æ ‘**çš„**é«˜åº¦**ã€‚æˆ‘ä»¬ä»¥è¿­ä»£æ–¹å¼è®¿é—®ä»**0 åˆ° n-1**çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¹¶é€’å½’åœ°æ ‡è®°é‚£äº›å°šæœªè¢«è®¿é—®è¿‡çš„**ç¥–å…ˆèŠ‚ç‚¹**ï¼Œç›´åˆ°åˆ°è¾¾ä¸€ä¸ªå·²è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œæˆ–è€…åˆ°è¾¾**æ ¹èŠ‚ç‚¹**ã€‚<mark>å¦‚æœåœ¨é€šè¿‡çˆ¶èŠ‚ç‚¹é“¾æ¥å‘ä¸Šéå†æ ‘æ—¶é‡åˆ°ä¸€ä¸ªå·²è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¼šä½¿ç”¨å®ƒçš„**é«˜åº¦**ï¼Œå¹¶åœæ­¢è¿›ä¸€æ­¥çš„é€’å½’ã€‚</mark>

> We can find the **height** of the **N-ary Tree** in only one **iteration**. We visit nodes from **0 to n-1** iteratively and mark the unvisited **ancestors** recursively if they are not visited before till we reach a node which is visited, or we reach the **root** node. If we reach the visited node while traversing up the tree using parent links, then we use its **height** and will not go further in recursion.

```python
# find height of N-ary tree in O(n) (Efficient Approach)

# Recur For Ancestors of node and store height of node at last
def fillHeight(p, node, visited, height):
    if (p[node] == -1):  # If root node
        visited[node] = 1  # mark root node as visited
        return 0

    if (visited[node]):
        return height[node]

    visited[node] = 1

    # recur for the parent node
    height[node] = 1 + fillHeight(p, p[node], visited, height)

    # return calculated height for node
    return height[node]


def findHeight(parent):
    n = len(parent)
    maxHeight = 0
    visited = [0] * n
    height = [0] * n

    for i in range(n):
        if (not visited[i]):
            height[i] = fillHeight(parent, i, visited, height)

        maxHeight = max(maxHeight, height[i])

    return maxHeight


if __name__ == '__main__':
    parent = [-1, 0, 0, 0, 3, 1, 1, 2]
    n = len(parent)

    print(findHeight(parent))

# 2

```

**Time Complexity:** O(n)
**Auxiliary Space**: O(n), this is because we need to store the visited and height arrays which are of size n.



#### General Tree Level Order Traversalå±‚åºéå†

https://www.geeksforgeeks.org/generic-tree-level-order-traversal/

Last Updated : 14 Mar, 2023

<mark>æ ‘çš„éå†ï¼Œé™¤äº†å‰åºã€ä¸­åºã€ååºï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯å±‚åºéå†ï¼Œå°±æ˜¯ä½¿ç”¨é˜Ÿåˆ—çš„bfsæ–¹å¼ã€‚</mark>

Given a generic tree, perform a Level order traversal and print all of its nodes

**Examples:** 

```
Input :            10
             /   /    \   \
            2  34    56   100
           / \        |   / | \
          77  88      1   7  8  9

Output : 10
         2 34 56 100
         77 88 1 7 8 9

Input :             1
             /   /    \   \
            2  3      4    5
           / \        |  /  | \
          6   7       8 9  10  11
Output : 1
         2 3 4 5
         6 7 8 9 10 11
```

The approach to this problem is similar to [Level Order traversal in a binary tree](https://www.geeksforgeeks.org/level-order-tree-traversal/). We Start with pushing root node in a queue and for each node we pop it, print it and push all its child in the queue.

In case of a generic tree we store child nodes in a vector. Thus we put all elements of the vector in the queue. 

> å®ç°ä»£ç ï¼Œæˆ‘åšäº†éƒ¨åˆ†è°ƒæ•´ï¼Œä¸»è¦æ˜¯ç”¨deque

```python
# do level order traversal of a generic tree
from collections import deque

# Represents a node of an n-ary tree
class Node:
    def __init__(self, key):
        self.key = key
        self.children = []  


def create_node(key):
    """Helper function to create a new node."""
    return Node(key)


def level_order_traversal(root):
    """
    Perform level order traversal (BFS) of a generic n-ary tree.
    Prints nodes level by level.
    """
    if root is None:
        return

    queue = deque([root])  # Initialize the queue with the root node

    while queue:
        level_size = len(queue)  # Number of nodes at the current level

        # Process all nodes in the current level
        for _ in range(level_size):
            current_node = queue.popleft()  # Dequeue the front node
            print(current_node.key, end=' ')  # Print the node's key

            # Enqueue all children of the current node
            for child in current_node.children:
                queue.append(child)

        print()  # Separate levels with a newline


# Driver program
if __name__ == '__main__':
    '''
    Create the following n-ary tree:
               10
            / / \ \
           2 34 56 100
         / \      | / | \
        77 88     1 7 8 9
    '''
    root = create_node(10)
    root.children.append(create_node(2))
    root.children.append(create_node(34))
    root.children.append(create_node(56))
    root.children.append(create_node(100))
    
    root.children[0].children.append(create_node(77))
    root.children[0].children.append(create_node(88))
    
    root.children[2].children.append(create_node(1))
    
    root.children[3].children.append(create_node(7))
    root.children[3].children.append(create_node(8))
    root.children[3].children.append(create_node(9))

    print("Level order traversal of the tree:")
    level_order_traversal(root)

"""
Level order traversal Before Mirroring
10 
2 34 56 100 
77 88 1 7 8 9 
"""

```

Time Complexity: O(n) where n is the number of nodes in the n-ary tree.
Auxiliary Space: O(n)





# äºŒã€ğŸŒ²çš„åŸºæœ¬æ€§è´¨ã€AST & Huffman

## 3 æ ‘çš„åŸºæœ¬æ€§è´¨

### 3.1 $ m $-å‰æ ‘çš„æ€§è´¨

1. **<mark>æ€»ç»“ç‚¹æ•°</mark>**ï¼šè®¾æ ‘ä¸­æ€»çš„ç»“ç‚¹æ•°ä¸º $ N $ï¼Œåˆ™ï¼š
   $$
   N = N_0 + N_1 + N_2 + \dots + N_m
   $$
   å…¶ä¸­ $ N_0 $ è¡¨ç¤ºåº¦æ•°ä¸º 0 çš„ç»“ç‚¹æ•°ï¼ˆå³å¶ç»“ç‚¹ï¼‰ï¼Œ$ N_1, N_2, \dots, N_m $ åˆ†åˆ«è¡¨ç¤ºåº¦æ•°ä¸º 1, 2, ..., $ m $ çš„ç»“ç‚¹æ•°ã€‚

2. **<mark>æ€»åˆ†æ”¯æ•°</mark>**ï¼šåœ¨æ ‘ä¸­ï¼Œæ¯ä¸ªåº¦æ•°ä¸º $ k $ çš„ç»“ç‚¹è´¡çŒ®äº† $ k $ æ¡åˆ†æ”¯ã€‚å› æ­¤ï¼Œæ ‘ä¸­çš„æ€»åˆ†æ”¯æ•°å¯ä»¥è¡¨ç¤ºä¸ºï¼š
   $$
   \text{æ€»åˆ†æ”¯æ•°} = 1 \cdot N_1 + 2 \cdot N_2 + \dots + m \cdot N_m
   $$

3. **æ ‘çš„æ€»åˆ†æ”¯æ•°ä¸æ€»ç»“ç‚¹æ•°çš„å…³ç³»**ï¼šå¯¹äºä¸€æ£µæ ‘ï¼Œæ€»åˆ†æ”¯æ•°ç­‰äºæ€»ç»“ç‚¹æ•°å‡å» 1ï¼ˆå› ä¸ºé™¤äº†æ ¹ç»“ç‚¹å¤–ï¼Œæ¯ä¸ªç»“ç‚¹éƒ½ç”±ä¸€æ¡åˆ†æ”¯è¿æ¥åˆ°å…¶çˆ¶ç»“ç‚¹ï¼‰ã€‚å› æ­¤ï¼š
   $$
   \text{æ€»åˆ†æ”¯æ•°} = N - 1
   $$

> å°†ä»¥ä¸Šå…³ç³»ç»“åˆèµ·æ¥ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å…³äº $ N_0 $ çš„æ–¹ç¨‹ã€‚



<mark>å¯¹ä»»ä½•ä¸€æ£µéç©ºäºŒå‰æ ‘ï¼Œå¦‚æœå¶èŠ‚ç‚¹æ•° $n_0$ï¼Œåº¦ä¸º2çš„éå¶èŠ‚ç‚¹æ•° $n_2$ï¼Œåˆ™ï¼š</mark>

<mark>$n_0 = n_2 + 1$</mark>

> åœ¨ä¸€æ£µäºŒå‰æ ‘ä¸­ï¼Œé™¤äº†åº¦ä¸º0çš„å¶å­èŠ‚ç‚¹ï¼Œå°±æ˜¯åº¦ä¸º1çš„èŠ‚ç‚¹å’Œä¸º2çš„èŠ‚ç‚¹ï¼Œåˆ™æ ‘çš„æ€»èŠ‚ç‚¹æ•°ä¸ºï¼š
>
> $N = n_0 + n_1 + n_2$
>
> åœ¨äºŒå‰æ ‘ä¸­èŠ‚ç‚¹æ€»æ•°ä¸º $N$ å’Œè¾¹æ•°ä¹‹é—´çš„å…³ç³»æ˜¯ï¼š<mark>è¾¹æ•° = $N - 1$</mark>ï¼Œæ‰€ä»¥æœ‰ï¼š
>
> $n_0 + n_1 + n_2 - 1 = 2n_2 + n_1$ 
>
> æœ€åå¾—åˆ°ï¼š$n_0 = n_2 + 1$



#### ç¬”è¯•å¡«ç©º@20240618

è®¾ä¸€æ£µmå‰æ ‘ä¸­æœ‰$N_1$ä¸ªåº¦æ•°ä¸º1çš„ç»“ç‚¹ï¼ˆåº¦æ•°è¡¨ç¤ºå­ç»“ç‚¹ä¸ªæ•°ï¼‰ï¼Œ$N_2$ä¸ªåº¦æ•°ä¸º2çš„ç»“ç‚¹ï¼Œâ€¦â€¦ï¼Œ$N_m$ä¸ªåº¦æ•°ä¸ºmçš„ç»“ç‚¹ï¼Œåˆ™è¯¥må‰æ ‘ä¸­å…±æœ‰$\underline{\hspace{4cm}}$ä¸ªç»ˆç«¯ç»“ç‚¹ï¼ˆå³å¶ç»“ç‚¹ï¼‰ã€‚<mark>$ 1 + \sum_{i=2}^{m} (i-1) N_i $</mark>

> ä»æ ‘çš„æ€»ç»“ç‚¹æ•°å’Œæ€»åˆ†æ”¯æ•°ä¸¤æ¡æ€§è´¨å‡ºå‘ï¼š
>
> 1. æ€»åˆ†æ”¯æ•°çš„ä¸¤ç§è¡¨è¾¾å¼ç›¸ç­‰ï¼š
>    $$
>    1 \cdot N_1 + 2 \cdot N_2 + \dots + m \cdot N_m = N - 1
>    $$
>
> 2. å°† $ N = N_0 + N_1 + N_2 + \dots + N_m $ ä»£å…¥ä¸Šå¼ï¼š
>    $$
>    1 \cdot N_1 + 2 \cdot N_2 + \dots + m \cdot N_m = (N_0 + N_1 + N_2 + \dots + N_m) - 1
>    $$
>
> 3. åŒ–ç®€åå¾—åˆ°ï¼š
>    $$
>    N_0 = 1 + (0 \cdot N_0) + (1 \cdot N_1) + (2 \cdot N_2) + \dots + (m \cdot N_m) - (N_1 + N_2 + \dots + N_m)
>    $$
>
> 4. åˆå¹¶åŒç±»é¡¹ï¼š
>    $$
>    N_0 = 1 + \sum_{k=1}^m (k - 1) N_k
>    $$
>
> ---
>
> **æœ€ç»ˆå…¬å¼**
>
> ä¸€æ£µ $ m $-å‰æ ‘ä¸­ï¼Œå¶ç»“ç‚¹çš„æ•°é‡ $ N_0 $ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
> $$
> N_0 = 1 + \sum_{k=1}^m (k - 1) N_k
> $$
>
> å…¶ä¸­ï¼š
>
> - $ N_k $ æ˜¯åº¦æ•°ä¸º $ k $ çš„ç»“ç‚¹æ•°ï¼›
> - $ k - 1 $ è¡¨ç¤ºæ¯ä¸ªåº¦æ•°ä¸º $ k $ çš„ç»“ç‚¹å¯¹å¶ç»“ç‚¹æ•°é‡çš„è´¡çŒ®ã€‚



#### ç¬”è¯•å¡«ç©º@20240618

è®¾æ£®æ—Fä¸­æœ‰4æ£µæ ‘ï¼Œç¬¬1ã€2ã€3ã€4æ£µæ ‘çš„ç»“ç‚¹ä¸ªæ•°åˆ†åˆ«ä¸º10ã€9ã€11ã€7ï¼Œå½“æŠŠæ£®æ—Fè½¬æ¢æˆä¸€æ£µäºŒå‰æ ‘åï¼Œå…¶æ ¹ç»“ç‚¹çš„å³å­æ ‘ä¸­æœ‰$\underline{\hspace{4cm}}$ä¸ªç»“ç‚¹ã€‚<mark>27</mark>

> 
>
> **æ£®æ—è½¬æ¢ä¸ºäºŒå‰æ ‘çš„è§„åˆ™**
>
> 1. **ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹**ï¼šæ£®æ—ä¸­ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºäºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ã€‚
> 2. **å·¦å­æ ‘**ï¼šæ¯æ£µæ ‘çš„æ ¹ç»“ç‚¹çš„å·¦å­æ ‘æ˜¯å…¶åœ¨åŸæ ‘ä¸­çš„ç¬¬ä¸€ä¸ªå­æ ‘ã€‚
> 3. **å³å­æ ‘**ï¼šæ¯æ£µæ ‘çš„æ ¹ç»“ç‚¹çš„å³å­æ ‘æ˜¯æ£®æ—ä¸­ä¸‹ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹ã€‚
>
> æ¢å¥è¯è¯´ï¼š
>
> - ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºäºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ã€‚
> - ç¬¬ä¸€æ£µæ ‘çš„å­æ ‘æ„æˆäºŒå‰æ ‘æ ¹ç»“ç‚¹çš„å·¦å­æ ‘ã€‚
> - ç¬¬äºŒæ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬ä¸€æ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
> - ç¬¬ä¸‰æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬äºŒæ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ï¼Œä¾æ­¤ç±»æ¨ã€‚
>
> ---
>
> **åˆ†æé¢˜ç›®**
>
> æ£®æ— $ F $ ä¸­æœ‰ 4 æ£µæ ‘ï¼Œåˆ†åˆ«åŒ…å« 10ã€9ã€11ã€7 ä¸ªç»“ç‚¹ã€‚æŒ‰ç…§ä¸Šè¿°è§„åˆ™ï¼š
>
> - ç¬¬ä¸€æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºäºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ã€‚
> - ç¬¬äºŒæ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬ä¸€æ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
> - ç¬¬ä¸‰æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬äºŒæ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
> - ç¬¬å››æ£µæ ‘çš„æ ¹ç»“ç‚¹æˆä¸ºç¬¬ä¸‰æ£µæ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘ã€‚
>
> å› æ­¤ï¼ŒäºŒå‰æ ‘æ ¹ç»“ç‚¹çš„å³å­æ ‘åŒ…å«çš„æ˜¯**ç¬¬äºŒã€ç¬¬ä¸‰å’Œç¬¬å››æ£µæ ‘çš„æ‰€æœ‰ç»“ç‚¹**ã€‚



### 3.2 äºŒå‰æ ‘çš„æ€§è´¨

> 1. **æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹**ï¼š
>
> äºŒå‰æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œåˆ†åˆ«æ˜¯â€œå·¦å­èŠ‚ç‚¹â€å’Œâ€œå³å­èŠ‚ç‚¹â€ã€‚
>
> 2. **äºŒå‰æ ‘çš„é«˜åº¦ä¸æ·±åº¦**ï¼š
>
> - **æ ‘çš„é«˜åº¦**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„çš„é•¿åº¦ï¼ˆå³ç»è¿‡çš„è¾¹çš„æ•°é‡ï¼‰ã€‚ç©ºæ ‘çš„é«˜åº¦ä¸º-1ï¼Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æ—¶æ ‘çš„é«˜åº¦ä¸º0ã€‚
> - **èŠ‚ç‚¹çš„æ·±åº¦**ï¼šä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·¯å¾„é•¿åº¦ï¼ˆå³ç»è¿‡çš„è¾¹çš„æ•°é‡ï¼‰ã€‚æ ¹èŠ‚ç‚¹çš„æ·±åº¦ä¸º0ï¼Œå…¶ä»–èŠ‚ç‚¹çš„æ·±åº¦æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„æ·±åº¦åŠ 1ã€‚
>
> 3. **äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°**ï¼š
>
> - å¯¹äºä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ•°ç›®ä¸æ ‘çš„é«˜åº¦hæœ‰å…³ç³»ï¼šèŠ‚ç‚¹æ•° `n = 2^(h+1) - 1`ã€‚
> - å¯¹äºä¸€èˆ¬äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ•°ç›®æ˜¯æœ‰é™çš„ï¼Œå¯ä»¥é€šè¿‡éå†è®¡ç®—ã€‚
>
> 4. **æ»¡äºŒå‰æ ‘**ï¼š
>
> - æ»¡äºŒå‰æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸€å±‚çš„èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼ˆå³æ¯ä¸ªéå¶å­èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼‰ã€‚å‡è®¾æ ‘çš„é«˜åº¦ä¸ºhï¼Œåˆ™æ»¡äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ä¸º `2^(h+1) - 1`ã€‚
>
> 5. **å®Œå…¨äºŒå‰æ ‘**ï¼š
>
> - å®Œå…¨äºŒå‰æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½è¢«å®Œå…¨å¡«æ»¡ï¼Œä¸”æœ€åº•å±‚çš„èŠ‚ç‚¹é›†ä¸­åœ¨å·¦è¾¹ã€‚å¦‚æœä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘æœ‰nä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå®ƒçš„é«˜åº¦ä¸º `log2(n)`ï¼ˆå‘ä¸‹å–æ•´ï¼‰ã€‚
>
> 6. **å¶å­èŠ‚ç‚¹å’Œéå¶å­èŠ‚ç‚¹**ï¼š
>
> - **å¶å­èŠ‚ç‚¹**ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
> - **éå¶å­èŠ‚ç‚¹**ï¼šæœ‰ä¸€ä¸ªæˆ–ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
>
> 7. **äºŒå‰æ ‘çš„éå†æ–¹å¼**ï¼š
>
> - **å‰åºéå†**ï¼ˆPre-orderï¼‰ï¼šæ ¹èŠ‚ç‚¹ -> å·¦å­æ ‘ -> å³å­æ ‘
> - **ä¸­åºéå†**ï¼ˆIn-orderï¼‰ï¼šå·¦å­æ ‘ -> æ ¹èŠ‚ç‚¹ -> å³å­æ ‘
> - **ååºéå†**ï¼ˆPost-orderï¼‰ï¼šå·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹èŠ‚ç‚¹
> - **å±‚åºéå†**ï¼ˆLevel-orderï¼‰ï¼šä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³é€å±‚è®¿é—®èŠ‚ç‚¹ã€‚
>
> 8. **äºŒå‰æ ‘çš„å¹³è¡¡æ€§**ï¼š
>
> - å¦‚æœä¸€ä¸ªäºŒå‰æ ‘çš„å·¦å³å­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼å¤§äº1ï¼Œé‚£ä¹ˆè¿™ä¸ªäºŒå‰æ ‘å°±æ˜¯**ä¸å¹³è¡¡çš„**ã€‚å¦‚æœä¸€ä¸ªäºŒå‰æ ‘åœ¨ä»»ä½•æ—¶åˆ»éƒ½æ»¡è¶³å·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡1ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯**å¹³è¡¡äºŒå‰æ ‘**ã€‚
>
> è¿™äº›æ€§è´¨æ˜¯ç†è§£äºŒå‰æ ‘ç»“æ„çš„åŸºç¡€ï¼Œæœ‰åŠ©äºè®¾è®¡å’Œä¼˜åŒ–åŸºäºäºŒå‰æ ‘çš„ç®—æ³•ï¼Œæ¯”å¦‚äºŒå‰æŸ¥æ‰¾æ ‘ã€å¹³è¡¡æ ‘ç­‰ã€‚



#### ç¬”è¯•é€‰æ‹©@20240618

Q. å®šä¹‰ä¸€æ£µæ²¡æœ‰1åº¦ç»“ç‚¹çš„äºŒå‰æ ‘ä¸ºæ»¡äºŒå‰æ ‘ã€‚å¯¹äºä¸€æ£µåŒ…å«kä¸ªç»“ç‚¹çš„æ»¡äºŒå‰æ ‘ï¼Œå…¶å¶å­ç»“ç‚¹çš„ä¸ªæ•°ä¸ºï¼ˆ <mark>C</mark>  ï¼‰ã€‚
A.   âŒŠk/2âŒ‹   B. âŒŠk/2âŒ‹-1  C.âŒŠk/2âŒ‹+1   D.ä»¥ä¸Šä¸‰ä¸ªéƒ½æœ‰å¯èƒ½



#### ç¬”è¯•é€‰æ‹©@20230620

Q. å®šä¹‰äºŒå‰æ ‘ä¸­ä¸€ä¸ªç»“ç‚¹çš„åº¦æ•°ä¸ºå…¶å­ç»“ç‚¹çš„ä¸ªæ•°ã€‚ç°æœ‰ä¸€æ£µç»“ç‚¹æ€»æ•°ä¸º 101 çš„äºŒå‰æ ‘ï¼Œå…¶ä¸­åº¦æ•°ä¸º 1 çš„ç»“ç‚¹æ•°æœ‰ 30 ä¸ªï¼Œåˆ™åº¦æ•°ä¸º 0 ç»“ç‚¹æœ‰ _ _ _ _ ä¸ªã€‚

> æ¨å¯¼è¿‡ç¨‹
>
> 1. æ ¹æ®æ€»ç»“ç‚¹æ•°å…¬å¼ï¼š
>    $N = N_0 + N_1 + N_2$
>    å°†å·²çŸ¥å€¼ä»£å…¥ï¼š
>    $101 = N_0 + 30 + N_2$
>    åŒ–ç®€å¾—ï¼š
>    $$
>    N_0 + N_2 = 71 \tag{1}
>    $$
>
> 2. æ ¹æ®æ€»åˆ†æ”¯æ•°å…¬å¼ï¼š
>    $N_1 + 2N_2 = N - 1$
>    å°†å·²çŸ¥å€¼ä»£å…¥ï¼š
>    $30 + 2N_2 = 101 - 1$
>    åŒ–ç®€å¾—ï¼š
>    $$
>    2N_2 = 70 \quad \Rightarrow \quad N_2 = 35 \tag{2}
>    $$
>
> 3. å°† $ N_2 = 35 $ ä»£å…¥ (1) å¼ï¼š
>    $N_0 + 35 = 71$
>    åŒ–ç®€å¾—ï¼š
>    $N_0 = 36$
>
> <mark>36</mark>



#### ç¬”è¯•é€‰æ‹©@20230620

Q. å®šä¹‰å®Œå…¨äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹æ‰€åœ¨å±‚ä¸ºç¬¬ä¸€å±‚ã€‚å¦‚æœä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘çš„ç¬¬å…­å±‚æœ‰ 23 ä¸ªå¶ç»“ç‚¹ï¼Œåˆ™å®ƒçš„æ€»ç»“ç‚¹æ•°å¯èƒ½ä¸º _ _ _ _ ï¼ˆè¯·å¡«å†™æ‰€æœ‰ 3 ä¸ªå¯èƒ½çš„ç»“ç‚¹æ•°ï¼Œå†™å¯¹ 1 ä¸ªå¾— 1 åˆ†ï¼Œ2 ä¸ªå¾— 1.5 åˆ†ï¼Œå†™ é”™ 1 ä¸ªä¸å¾—åˆ†ï¼‰ã€‚

> 54ï¼Œæ˜¯ 1+2+4+8+16+23= 54
>
> åœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚ï¼Œå…¶ä»–æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½æ˜¯æ»¡çš„ã€‚åœ¨æœ€åº•å±‚ï¼Œä»å·¦å¾€å³å¡«å……èŠ‚ç‚¹ã€‚
>
> å¯ä»¥æ˜¯ç¬¬å…­å±‚æ˜¯æ»¡çš„ã€‚ä½†æ˜¯å¶èŠ‚ç‚¹åªæœ‰23ä¸ªï¼Œè¿˜æœ‰9ä¸ªç»“ç‚¹æ˜¯éå¶ç»“ç‚¹ã€‚è¿™æ ·ç¬¬ä¸ƒå±‚è¦ä¹ˆæ˜¯17ä¸ªèŠ‚ç‚¹è¦ä¹ˆæ˜¯18ä¸ªã€‚(1+2+4+8+16+32) + 17 æˆ– 18 = 80ï¼Œæˆ– 81
>
> <mark>54,80,81</mark>



## 4 äºŒå‰æ ‘çš„åº”ç”¨

### 4.1 è§£ææ ‘/æŠ½è±¡è¯­æ³•æ ‘AST

ç°åœ¨æ¥çœ‹çœ‹å¦‚ä½•ç”¨æ ‘è§£å†³ä¸€äº›å®é™…é—®é¢˜ã€‚æœ¬èŠ‚ä»‹ç»è§£ææ ‘ï¼Œå¯ä»¥ç”¨å®ƒæ¥è¡¨ç¤ºç°å®ä¸–ç•Œä¸­åƒå¥å­ï¼ˆå¦‚å›¾1æ‰€ç¤ºï¼‰æˆ–æ•°å­¦è¡¨è¾¾å¼è¿™æ ·çš„æ„é€ ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311914368.png" alt="image-20240131191318107" style="zoom: 25%;" />

<center>å›¾1 ä¸€ä¸ªç®€å•å¥å­çš„è§£ææ ‘</center>



å›¾1å±•ç¤ºäº†ä¸€ä¸ªç®€å•å¥å­çš„å±‚æ¬¡ç»“æ„ã€‚ç”¨æ ‘çŠ¶ç»“æ„è¡¨ç¤ºå¥å­å¯ä»¥ä½¿ç”¨å­æ ‘å¤„ç†å¥å­çš„ç‹¬ç«‹éƒ¨åˆ†ã€‚

ä¹Ÿå¯ä»¥å°†` ( ( 7 + 3) * ( 5 - 2 ) )` è¿™æ ·çš„æ•°å­¦è¡¨è¾¾å¼è¡¨ç¤ºæˆè§£ææ ‘ï¼Œå¦‚å›¾2æ‰€ç¤ºã€‚è¿™æ˜¯å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ï¼Œä¹˜æ³•çš„ä¼˜å…ˆçº§é«˜äºåŠ æ³•å’Œå‡æ³•ï¼Œä½†å› ä¸ºæœ‰æ‹¬å·ï¼Œæ‰€ä»¥åœ¨åšä¹˜æ³•å‰å¿…é¡»å…ˆåšæ‹¬å·å†…çš„åŠ æ³•å’Œå‡æ³•ã€‚<mark>æ ‘çš„å±‚æ¬¡æ€§æœ‰åŠ©äºç†è§£æ•´ä¸ªè¡¨è¾¾å¼çš„è®¡ç®—æ¬¡åºã€‚åœ¨è®¡ç®—é¡¶å±‚çš„ä¹˜æ³•å‰ï¼Œå¿…é¡»å…ˆè®¡ç®—å­æ ‘ä¸­çš„åŠ æ³•å’Œå‡æ³•ã€‚</mark>åŠ æ³•ï¼ˆå·¦å­æ ‘ï¼‰çš„ç»“æœæ˜¯`10`ï¼Œå‡æ³•ï¼ˆå³å­æ ‘ï¼‰çš„ç»“æœæ˜¯`3`ã€‚åˆ©ç”¨æ ‘çš„å±‚æ¬¡ç»“æ„ï¼Œåœ¨è®¡ç®—å®Œå­æ ‘çš„è¡¨è¾¾å¼åï¼Œåªéœ€ç”¨ä¸€ä¸ªèŠ‚ç‚¹ä»£æ›¿æ•´æ£µå­æ ‘å³å¯ã€‚åº”ç”¨è¿™ä¸ªæ›¿æ¢è¿‡ç¨‹åï¼Œä¾¿å¾—åˆ°å¦‚å›¾3æ‰€ç¤ºçš„ç®€åŒ–æ ‘ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311918463.png" alt="image-20240131191832905" style="zoom:25%;" />

<center>å›¾2 `( ( 7 + 3) * ( 5 - 2 ) )`çš„è§£ææ ‘</center>



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311919250.png" alt="image-20240131191907102" style="zoom: 33%;" />

<center>å›¾3 `( ( 7 + 3 ) * ( 5 - 2 ) )`çš„ç®€åŒ–è§£ææ ‘</center>

æœ¬èŠ‚çš„å‰©ä½™éƒ¨åˆ†å°†ä»”ç»†è€ƒå¯Ÿè§£ææ ‘ï¼Œé‡ç‚¹å¦‚ä¸‹ï¼š
	â å¦‚ä½•æ ¹æ®å®Œå…¨æ‹¬å·è¡¨è¾¾å¼æ„å»ºè§£ææ ‘ï¼›
	â å¦‚ä½•è®¡ç®—è§£ææ ‘ä¸­çš„è¡¨è¾¾å¼ï¼›
	â å¦‚ä½•å°†è§£ææ ‘è¿˜åŸæˆæœ€åˆçš„æ•°å­¦è¡¨è¾¾å¼ã€‚



**Q: æƒ³ç¡®è®¤ä¸‹æ ¹æ®å®Œå…¨æ‹¬å·è¡¨è¾¾å¼æ„å»ºè§£æå¼æ˜¯å¦æœ‰ä¸€ä¸ªç®—æ³•åç§°ï¼Ÿ**

> gptè¯´ï¼š
>
> å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ï¼Œé€šå¸¸ç§°ä¸ºâ€œå®Œå…¨åœ†æ‹¬å·è¡¨è¾¾å¼â€æˆ–â€œå®Œå…¨æ‹¬å·åŒ–è¡¨è¾¾å¼â€ï¼Œæ˜¯æ•°å­¦å’Œè®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ä¸ªæ¦‚å¿µï¼Œç”¨äºæ˜ç¡®æ— è¯¯åœ°è¡¨ç¤ºå¸¦æœ‰æ‹¬å·çš„ç®—æœ¯è¡¨è¾¾å¼æˆ–å…¶ä»–ä»»ä½•éœ€è¦æ“ä½œç¬¦ä¼˜å…ˆçº§çš„è¡¨è¾¾å¼ã€‚è¿™ç§è¡¨è¾¾å¼å½¢å¼æ¶ˆé™¤äº†æ“ä½œç¬¦ä¼˜å…ˆè§„åˆ™çš„æ­§ä¹‰ï¼Œå› ä¸ºæ‰€æœ‰çš„æ“ä½œéƒ½æ˜ç¡®åœ°é€šè¿‡æ‹¬å·æ¥æŒ‡ç¤ºå…¶é¡ºåºã€‚
>
> æ„å»ºè§£ææ ‘ï¼ˆæˆ–æŠ½è±¡è¯­æ³•æ ‘ï¼ŒAbstract Syntax Treeï¼ŒASTï¼‰çš„è¿‡ç¨‹ï¼Œä»ç»™å®šçš„å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ä¸­æå–ç»“æ„ä¿¡æ¯ï¼Œå¹¶åˆ›å»ºç›¸åº”çš„æ ‘å½¢ç»“æ„ï¼Œè¿™åœ¨è®¡ç®—æœºç§‘å­¦ä¸­é€šå¸¸æ˜¯è¯­æ³•åˆ†æï¼ˆParsingï¼‰çš„ä¸€éƒ¨åˆ†ã€‚é’ˆå¯¹æ­¤è¿‡ç¨‹çš„ç®—æ³•æ²¡æœ‰ç‰¹å®šçš„é€šç”¨åç§°ï¼Œä½†å®ƒæ˜¯ç¼–è¯‘å™¨å’Œè§£é‡Šå™¨ä¸­ä½¿ç”¨çš„è¯­æ³•åˆ†ææˆ–è§£æç®—æ³•çš„ä¸€éƒ¨åˆ†ã€‚
>
> æ ‘å½¢ç»“æ„èƒ½å¤Ÿä½“ç°æ“ä½œç¬¦å’Œæ“ä½œæ•°ä¹‹é—´çš„å±‚çº§å…³ç³»ï¼Œè€Œè¡¨è¾¾å¼çš„è§£æè¿‡ç¨‹é€šå¸¸éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š
>
> 1. **è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰**ï¼šæ­¤æ­¥éª¤ä¸­ï¼Œè¾“å…¥çš„å­—ç¬¦åºåˆ—ï¼ˆä»£ç ã€è¡¨è¾¾å¼ç­‰ï¼‰è¢«è½¬æ¢æˆä¸€ç³»åˆ—æ ‡è®°ï¼ˆtokensï¼‰ï¼Œä¾‹å¦‚æ•°å­—ã€æ“ä½œç¬¦ã€æ‹¬å·ç­‰ã€‚
>
> 2. **è¯­æ³•åˆ†æï¼ˆSyntactic Analysisï¼‰**ï¼šåœ¨è¯¥é˜¶æ®µï¼Œæ ‡è®°åºåˆ—æ ¹æ®è¯­æ³•è§„åˆ™è¢«ç»„ç»‡æˆè§£ææ ‘ã€‚è¯­æ³•åˆ†æå™¨ä¼šä½¿ç”¨è¯¸å¦‚é€’å½’ä¸‹é™ã€LL è§£æã€LR è§£æç­‰ç®—æ³•æ¥æ„é€ æ ‘ã€‚
>
> 3. **è¯­ä¹‰åˆ†æï¼ˆSemantic Analysisï¼‰**ï¼šæ„å»ºçš„è§£ææ ‘å¯èƒ½ä¼šè¿›ä¸€æ­¥ç»è¿‡è¯­ä¹‰æ£€æŸ¥ï¼Œä»¥ç¡®ä¿è¡¨è¾¾å¼çš„æ„ä¹‰æ˜¯åˆç†çš„ï¼Œæ¯”å¦‚ç±»å‹æ£€æŸ¥ç­‰ã€‚
>
> å¯¹äºæ„å»ºè§£ææ ‘çš„å…·ä½“ç®—æ³•ï¼Œæ²¡æœ‰ä¸€ä¸ªç»Ÿä¸€çš„åç§°æ¥æè¿°è¿™ä¸ªè¿‡ç¨‹ï¼Œå› ä¸ºå®ƒå¯èƒ½ä¼šæ¶‰åŠä¸åŒçš„è§£æç­–ç•¥å’ŒæŠ€æœ¯ã€‚åœ¨ç¼–è¯‘å™¨è®¾è®¡ä¸­ï¼Œå¸¸è§çš„è§£æç®—æ³•æœ‰LLè§£æå™¨ã€LRè§£æå™¨ã€é€’å½’ä¸‹é™è§£æå™¨ç­‰ã€‚è¿™äº›ç®—æ³•éƒ½å¯ä»¥ç”¨æ¥ä»å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ä¸­æ„å»ºå‡ºè§£ææ ‘ã€‚ã€‚

æ„å»ºè§£ææ ‘çš„ç¬¬ä¸€æ­¥æ˜¯å°†è¡¨è¾¾å¼å­—ç¬¦ä¸²æ‹†åˆ†æˆæ ‡è®°åˆ—è¡¨ã€‚éœ€è¦è€ƒè™‘4ç§æ ‡è®°ï¼š<mark>å·¦æ‹¬å·ã€å³æ‹¬å·ã€è¿ç®—ç¬¦å’Œæ“ä½œæ•°</mark>ã€‚å·¦æ‹¬å·ä»£è¡¨æ–°è¡¨è¾¾å¼çš„èµ·ç‚¹ï¼Œæ‰€ä»¥åº”è¯¥åˆ›å»ºä¸€æ£µå¯¹åº”è¯¥è¡¨è¾¾å¼çš„æ–°æ ‘ã€‚åä¹‹ï¼Œé‡åˆ°å³æ‹¬å·åˆ™æ„å‘³ç€åˆ°è¾¾è¯¥è¡¨è¾¾å¼çš„ç»ˆç‚¹ã€‚æ“ä½œæ•°æ—¢æ˜¯å¶å­èŠ‚ç‚¹ï¼Œä¹Ÿæ˜¯å…¶è¿ç®—ç¬¦çš„å­èŠ‚ç‚¹ã€‚æ­¤å¤–ï¼Œæ¯ä¸ªè¿ç®—ç¬¦éƒ½æœ‰å·¦å³å­èŠ‚ç‚¹ã€‚

æœ‰äº†ä¸Šè¿°ä¿¡æ¯ï¼Œä¾¿å¯ä»¥å®šä¹‰ä»¥ä¸‹<mark>4æ¡è§„åˆ™</mark>ï¼š

(1) å¦‚æœå½“å‰æ ‡è®°æ˜¯(ï¼Œå°±ä¸ºå½“å‰èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ï¼Œå¹¶ä¸‹æ²‰è‡³è¯¥å­èŠ‚ç‚¹ï¼›
(2) å¦‚æœå½“å‰æ ‡è®°åœ¨åˆ—è¡¨`['+', '-', '/', 'ï¼Š']`ä¸­ï¼Œå°±å°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸ºå½“å‰æ ‡è®°å¯¹åº”çš„è¿ç®—ç¬¦ï¼›ä¸ºå½“å‰èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå³å­èŠ‚ç‚¹ï¼Œå¹¶ä¸‹æ²‰è‡³è¯¥å­èŠ‚ç‚¹ï¼›
(3) å¦‚æœå½“å‰æ ‡è®°æ˜¯æ•°å­—ï¼Œå°±å°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸ºè¿™ä¸ªæ•°å¹¶è¿”å›è‡³çˆ¶èŠ‚ç‚¹ï¼›
(4) å¦‚æœå½“å‰æ ‡è®°æ˜¯)ï¼Œå°±è·³åˆ°å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

ç¼–å†™Pythonä»£ç å‰ï¼Œæˆ‘ä»¬å…ˆé€šè¿‡ä¸€ä¸ªä¾‹å­æ¥ç†è§£ä¸Šè¿°è§„åˆ™ã€‚å°†è¡¨è¾¾å¼`(3 + (4 âˆ— 5))`æ‹†åˆ†æˆæ ‡è®°åˆ—è¡¨`['(', '3', '+', '(', '4', 'ï¼Š', '5', ')', ')']`ã€‚èµ·åˆï¼Œè§£ææ ‘åªæœ‰ä¸€ä¸ªç©ºçš„æ ¹èŠ‚ç‚¹ï¼Œéšç€å¯¹æ¯ä¸ªæ ‡è®°çš„å¤„ç†ï¼Œè§£ææ ‘çš„ç»“æ„å’Œå†…å®¹é€æ¸å……å®ï¼Œå¦‚å›¾6æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311922845.png" alt="image-20240131192244859" style="zoom: 33%;" />

<center>å›¾4 å°†`(3 + (4 âˆ— 5))`ä¸€æ­¥æ­¥åœ°æ„å»ºè§£ææ ‘</center>

ä»¥å›¾4ä¸ºä¾‹ï¼Œæˆ‘ä»¬æ¥ä¸€æ­¥æ­¥åœ°æ„å»ºè§£ææ ‘ã€‚

(a) åˆ›å»ºä¸€æ£µç©ºæ ‘ã€‚
(b) è¯»å…¥ç¬¬ä¸€ä¸ªæ ‡è®°(ã€‚æ ¹æ®è§„åˆ™1ï¼Œä¸ºæ ¹èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ã€‚
(c) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°3ã€‚æ ¹æ®è§„åˆ™3ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º3ï¼Œå¹¶å›åˆ°çˆ¶èŠ‚ç‚¹ã€‚
(d) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°+ã€‚æ ¹æ®è§„åˆ™2ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º+ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚æ–°èŠ‚ç‚¹æˆä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(e) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°(ã€‚æ ¹æ®è§„åˆ™1ï¼Œä¸ºå½“å‰èŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(f) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°4ã€‚æ ¹æ®è§„åˆ™3ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º4ï¼Œå¹¶å›åˆ°çˆ¶èŠ‚ç‚¹ã€‚
(g) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°ï¼Šã€‚æ ¹æ®è§„åˆ™2ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸ºï¼Šï¼Œå¹¶æ·»åŠ ä¸€ä¸ªå³å­èŠ‚ç‚¹ã€‚æ–°èŠ‚ç‚¹æˆä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(h) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°5ã€‚æ ¹æ®è§„åˆ™3ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„å€¼è®¾ä¸º5ï¼Œå¹¶å›åˆ°çˆ¶èŠ‚ç‚¹ã€‚
(i) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°)ã€‚æ ¹æ®è§„åˆ™4ï¼Œå°†ï¼Šçš„çˆ¶èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚
(j) è¯»å…¥ä¸‹ä¸€ä¸ªæ ‡è®°)ã€‚æ ¹æ®è§„åˆ™4ï¼Œå°†+çš„çˆ¶èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹ã€‚å› ä¸º+æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œæ‰€ä»¥å·¥ä½œå®Œæˆã€‚

æœ¬ä¾‹è¡¨æ˜ï¼Œåœ¨æ„å»ºè§£ææ ‘çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦è¿½è¸ªå½“å‰èŠ‚ç‚¹åŠå…¶çˆ¶èŠ‚ç‚¹ã€‚å¯ä»¥é€šè¿‡`getLeftChild`ä¸`getRightChild`è·å–å­èŠ‚ç‚¹ï¼Œä½†å¦‚ä½•è¿½è¸ªçˆ¶èŠ‚ç‚¹å‘¢ï¼Ÿä¸€ä¸ªç®€å•çš„åŠæ³•å°±æ˜¯åœ¨éå†è¿™æ£µæ ‘æ—¶ä½¿ç”¨æ ˆè®°å½•çˆ¶èŠ‚ç‚¹ã€‚æ¯å½“è¦ä¸‹æ²‰è‡³å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ—¶ï¼Œå…ˆå°†å½“å‰èŠ‚ç‚¹å‹åˆ°æ ˆä¸­ã€‚å½“è¦è¿”å›åˆ°å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ—¶ï¼Œå°±å°†çˆ¶èŠ‚ç‚¹ä»æ ˆä¸­å¼¹å‡ºæ¥ã€‚

åˆ©ç”¨å‰é¢æè¿°çš„è§„åˆ™ä»¥åŠ`Stack`å’Œ`BinaryTree`ï¼Œå°±å¯ä»¥ç¼–å†™åˆ›å»ºè§£ææ ‘çš„Pythonå‡½æ•°ã€‚

#### 4.1.1 å®ç°ï¼šè§£ææ ‘æ„å»ºå™¨



```python
class Stack(object):
    def __init__(self):
        self.items = []
        self.stack_size = 0

    def isEmpty(self):
        return self.stack_size == 0

    def push(self, new_item):
        self.items.append(new_item)
        self.stack_size += 1

    def pop(self):
        self.stack_size -= 1
        return self.items.pop()

    def peek(self):
        return self.items[self.stack_size - 1]

    def size(self):
        return self.stack_size


class BinaryTree:
    def __init__(self, rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None

    def insertLeft(self, newNode):
        if self.leftChild == None:
            self.leftChild = BinaryTree(newNode)
        else:  # å·²ç»å­˜åœ¨å·¦å­èŠ‚ç‚¹ã€‚æ­¤æ—¶ï¼Œæ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å°†å·²æœ‰çš„å·¦å­èŠ‚ç‚¹é™ä¸€å±‚ã€‚
            t = BinaryTree(newNode)
            t.leftChild = self.leftChild
            self.leftChild = t

    def insertRight(self, newNode):
        if self.rightChild == None:
            self.rightChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.rightChild = self.rightChild
            self.rightChild = t

    def getRightChild(self):
        return self.rightChild

    def getLeftChild(self):
        return self.leftChild

    def setRootVal(self, obj):
        self.key = obj

    def getRootVal(self):
        return self.key

    def traversal(self, method="preorder"):
        if method == "preorder":
            print(self.key, end=" ")
        if self.leftChild != None:
            self.leftChild.traversal(method)
        if method == "inorder":
            print(self.key, end=" ")
        if self.rightChild != None:
            self.rightChild.traversal(method)
        if method == "postorder":
            print(self.key, end=" ")


def buildParseTree(fpexp):
    fplist = fpexp.split()
    pStack = Stack()
    eTree = BinaryTree('')
    pStack.push(eTree)
    currentTree = eTree

    for i in fplist:
        if i == '(':
            currentTree.insertLeft('')
            pStack.push(currentTree)
            currentTree = currentTree.getLeftChild()
        elif i not in '+-*/)':
            currentTree.setRootVal(int(i))
            parent = pStack.pop()
            currentTree = parent
        elif i in '+-*/':
            currentTree.setRootVal(i)
            currentTree.insertRight('')
            pStack.push(currentTree)
            currentTree = currentTree.getRightChild()
        elif i == ')':
            currentTree = pStack.pop()
        else:
            raise ValueError("Unknown Operator: " + i)
    return eTree


exp = "( ( 7 + 3 ) * ( 5 - 2 ) )"
pt = buildParseTree(exp)
for mode in ["preorder", "postorder", "inorder"]:
    pt.traversal(mode)
    print()

"""
* + 7 3 - 5 2 
7 3 + 5 2 - * 
7 + 3 * 5 - 2 
"""

# ä»£ç æ¸…å•6-10
import operator

def evaluate(parseTree):
    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}

    leftC = parseTree.getLeftChild()
    rightC = parseTree.getRightChild()

    if leftC and rightC:
        fn = opers[parseTree.getRootVal()]
        return fn(evaluate(leftC),evaluate(rightC))
    else:
        return parseTree.getRootVal()

print(evaluate(pt))
# 30

#ä»£ç æ¸…å•6-14 ååºæ±‚å€¼
def postordereval(tree):
    opers = {'+':operator.add, '-':operator.sub,
             '*':operator.mul, '/':operator.truediv}
    res1 = None
    res2 = None
    if tree:
        res1 = postordereval(tree.getLeftChild())
        res2 = postordereval(tree.getRightChild())
        if res1 and res2:
            return opers[tree.getRootVal()](res1,res2)
        else:
            return tree.getRootVal()

print(postordereval(pt))
# 30

#ä»£ç æ¸…å•6-16 ä¸­åºè¿˜åŸå®Œå…¨æ‹¬å·è¡¨è¾¾å¼
def printexp(tree):
    sVal = ""
    if tree:
        sVal = '(' + printexp(tree.getLeftChild())
        sVal = sVal + str(tree.getRootVal())
        sVal = sVal + printexp(tree.getRightChild()) + ')'
    return sVal

print(printexp(pt))
# (((7)+3)*((5)-2))
```



åœ¨ä»£ç æ¸…å•ä¸­ï¼Œç¬¬79ã€83ã€87å’Œ92è¡Œçš„`if`è¯­å¥ä½“ç°äº†æ„å»ºè§£ææ ‘çš„4æ¡è§„åˆ™ï¼Œå…¶ä¸­æ¯æ¡è¯­å¥éƒ½é€šè¿‡è°ƒç”¨`BinaryTree`å’Œ`Stack`çš„æ–¹æ³•å®ç°äº†å‰é¢æè¿°çš„è§„åˆ™ã€‚è¿™ä¸ªå‡½æ•°ä¸­å”¯ä¸€çš„é”™è¯¯æ£€æŸ¥åœ¨`else`ä»å¥ä¸­ï¼Œå¦‚æœé‡åˆ°ä¸€ä¸ªä¸èƒ½è¯†åˆ«çš„æ ‡è®°ï¼Œå°±æŠ›å‡ºä¸€ä¸ª`ValueError`å¼‚å¸¸ã€‚

æœ‰äº†ä¸€æ£µè§£ææ ‘ä¹‹åï¼Œæˆ‘ä»¬èƒ½å¯¹å®ƒåšäº›ä»€ä¹ˆå‘¢ï¼Ÿä½œä¸ºç¬¬ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå‡½æ•°<mark>è®¡ç®—è§£ææ ‘</mark>ï¼Œå¹¶è¿”å›è®¡ç®—ç»“æœã€‚è¦å†™è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å°†åˆ©ç”¨æ ‘çš„å±‚æ¬¡æ€§ã€‚<u>é’ˆå¯¹å›¾2ä¸­çš„è§£ææ ‘ï¼Œå¯ä»¥ç”¨å›¾3ä¸­çš„ç®€åŒ–è§£ææ ‘æ›¿æ¢ã€‚ç”±æ­¤å¯è§ï¼Œå¯ä»¥å†™ä¸€ä¸ªç®—æ³•ï¼Œé€šè¿‡é€’å½’è®¡ç®—æ¯æ£µå­æ ‘å¾—åˆ°æ•´æ£µè§£ææ ‘çš„ç»“æœã€‚</u>

> å› ä¸ºä¸¤ä¸ªå›¾è·ç¦»ç›®å‰æ–‡å­—å¤ªè¿œï¼Œå¤åˆ¶ç²˜è´´

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311918463.png" alt="image-20240131191832905" style="zoom:25%;" />

<center>å›¾2 `( ( 7 + 3 ) * ( 5 - 2 ) )`çš„è§£ææ ‘</center>



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202401311919250.png" alt="image-20240131191907102" style="zoom: 33%;" />

<center>å›¾3 `( ( 7 + 3 ) * ( 5 - 2 ) )`çš„ç®€åŒ–è§£ææ ‘</center>

å’Œä¹‹å‰ç¼–å†™é€’å½’å‡½æ•°ä¸€æ ·ï¼Œ<mark>è®¾è®¡é€’å½’è®¡ç®—å‡½æ•°è¦ä»ç¡®å®šåŸºæœ¬æƒ…å†µå¼€å§‹</mark>ã€‚å°±é’ˆå¯¹æ ‘è¿›è¡Œæ“ä½œçš„é€’å½’ç®—æ³•è€Œè¨€ï¼Œä¸€ä¸ªå¾ˆè‡ªç„¶çš„åŸºæœ¬æƒ…å†µå°±æ˜¯æ£€æŸ¥å¶å­èŠ‚ç‚¹ã€‚è§£ææ ‘çš„å¶å­èŠ‚ç‚¹å¿…å®šæ˜¯æ“ä½œæ•°ã€‚ç”±äºåƒæ•´æ•°å’Œæµ®ç‚¹æ•°è¿™æ ·çš„æ•°å€¼å¯¹è±¡ä¸éœ€è¦è¿›ä¸€æ­¥ç¿»è¯‘ï¼Œå› æ­¤evaluateå‡½æ•°å¯ä»¥ç›´æ¥è¿”å›å¶å­èŠ‚ç‚¹çš„å€¼ã€‚ä¸ºäº†å‘**åŸºæœ¬æƒ…å†µ**é è¿‘ï¼Œç®—æ³•å°†æ‰§è¡Œé€’å½’æ­¥éª¤ï¼Œå³å¯¹å½“å‰èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹è°ƒç”¨evaluateå‡½æ•°ã€‚<mark>é€’å½’è°ƒç”¨å¯ä»¥æœ‰æ•ˆåœ°æ²¿ç€å„æ¡è¾¹å¾€å¶å­èŠ‚ç‚¹é è¿‘ã€‚</mark>

è‹¥è¦ç»“åˆä¸¤ä¸ªé€’å½’è°ƒç”¨çš„ç»“æœï¼Œåªéœ€å°†çˆ¶èŠ‚ç‚¹ä¸­å­˜å‚¨çš„è¿ç®—ç¬¦åº”ç”¨äºå­èŠ‚ç‚¹çš„è®¡ç®—ç»“æœå³å¯ã€‚ä»å›¾3ä¸­å¯çŸ¥ï¼Œæ ¹èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹çš„è®¡ç®—ç»“æœå°±æ˜¯å®ƒä»¬è‡ªèº«ï¼Œå³`10`å’Œ`3`ã€‚åº”ç”¨ä¹˜å·ï¼Œå¾—åˆ°æœ€åçš„ç»“æœ30ã€‚

é€’å½’å‡½æ•°evaluateçš„å®ç°å¦‚ä»£ç æ¸…å•æ‰€ç¤ºã€‚é¦–å…ˆï¼Œè·å–æŒ‡å‘å½“å‰èŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹çš„å¼•ç”¨ã€‚<mark>å¦‚æœå·¦å³å­èŠ‚ç‚¹çš„å€¼éƒ½æ˜¯Noneï¼Œå°±è¯´æ˜å½“å‰èŠ‚ç‚¹ç¡®å®æ˜¯å¶å­èŠ‚ç‚¹ã€‚</mark>ç¬¬9è¡Œæ‰§è¡Œè¿™é¡¹æ£€æŸ¥ã€‚å¦‚æœå½“å‰èŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œåˆ™æŸ¥çœ‹å½“å‰èŠ‚ç‚¹ä¸­å­˜å‚¨çš„è¿ç®—ç¬¦ï¼Œå¹¶å°†å…¶åº”ç”¨äºå·¦å³å­èŠ‚ç‚¹çš„é€’å½’è®¡ç®—ç»“æœã€‚



#### 4.1.2 å®ç°ï¼šè®¡ç®—äºŒå‰è§£ææ ‘çš„é€’å½’å‡½æ•°

ä»£ç æ¸…å•6-10ã€‚

```python
import operator

def evaluate(parseTree):
    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}

    leftC = parseTree.getLeftChild()
    rightC = parseTree.getRightChild()

    if leftC and rightC:
        fn = opers[parseTree.getRootVal()]
        return fn(evaluate(leftC),evaluate(rightC)) #å…ˆè®¡ç®—å·¦å­æ ‘ï¼Œå†è®¡ç®—å³å­æ ‘ï¼Œæœ€åé€šè¿‡æ ¹èŠ‚ç‚¹è¿ç®—ç¬¦çš„å‡½æ•°è°ƒç”¨å°†ä¸¤ä¸ªç»“æœç»“åˆèµ·æ¥ã€‚
    else:
        return parseTree.getRootVal()
```



æˆ‘ä»¬ä½¿ç”¨å…·æœ‰é”®+ã€-ã€ï¼Šå’Œ/çš„å­—å…¸å®ç°ã€‚å­—å…¸ä¸­å­˜å‚¨çš„å€¼æ˜¯`operator`æ¨¡å—çš„å‡½æ•°ã€‚è¯¥æ¨¡å—æä¾›äº†å¸¸ç”¨è¿ç®—ç¬¦çš„å‡½æ•°ç‰ˆæœ¬ã€‚<mark>åœ¨å­—å…¸ä¸­æŸ¥è¯¢è¿ç®—ç¬¦æ—¶ï¼Œå¯¹åº”çš„å‡½æ•°å¯¹è±¡è¢«å–å‡º</mark>ã€‚æ—¢ç„¶å–å‡ºçš„å¯¹è±¡æ˜¯å‡½æ•°ï¼Œå°±å¯ä»¥ç”¨æ™®é€šçš„æ–¹å¼`function(param1, param2)`è°ƒç”¨ã€‚å› æ­¤ï¼Œ`opers\['+'](2, 2)`ç­‰ä»·äº`operator.add(2, 2)`ã€‚

æœ€åï¼Œè®©æˆ‘ä»¬é€šè¿‡å›¾4ä¸­çš„è§£ææ ‘æ„å»ºè¿‡ç¨‹æ¥ç†è§£evaluateå‡½æ•°ã€‚ç¬¬ä¸€æ¬¡è°ƒç”¨evaluateå‡½æ•°æ—¶ï¼Œå°†æ•´æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ä½œä¸ºå‚æ•°parseTreeä¼ å…¥ã€‚ç„¶åï¼Œè·å–æŒ‡å‘å·¦å³å­èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œæ£€æŸ¥å®ƒä»¬æ˜¯å¦å­˜åœ¨ã€‚<mark>ç¬¬11è¡Œè¿›è¡Œé€’å½’è°ƒç”¨ã€‚</mark>ä»æŸ¥è¯¢æ ¹èŠ‚ç‚¹çš„è¿ç®—ç¬¦å¼€å§‹ï¼Œè¯¥è¿ç®—ç¬¦æ˜¯+ï¼Œå¯¹åº”operator.addå‡½æ•°ï¼Œè¦ä¼ å…¥ä¸¤ä¸ªå‚æ•°ã€‚å’Œæ™®é€šçš„Pythonå‡½æ•°è°ƒç”¨ä¸€æ ·ï¼ŒPythonåšçš„ç¬¬ä¸€ä»¶äº‹æ˜¯è®¡ç®—å…¥å‚çš„å€¼ã€‚æœ¬ä¾‹ä¸­ï¼Œä¸¤ä¸ªå…¥å‚éƒ½æ˜¯å¯¹evaluateå‡½æ•°çš„é€’å½’è°ƒç”¨ã€‚ç”±äºå…¥å‚çš„è®¡ç®—é¡ºåºæ˜¯ä»å·¦åˆ°å³ï¼Œå› æ­¤ç¬¬ä¸€æ¬¡é€’å½’è°ƒç”¨æ˜¯åœ¨å·¦è¾¹ã€‚å¯¹å·¦å­æ ‘é€’å½’è°ƒç”¨evaluateå‡½æ•°ï¼Œå‘ç°èŠ‚ç‚¹æ²¡æœ‰å·¦å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹ã€‚å¤„äºå¶å­èŠ‚ç‚¹æ—¶ï¼Œåªéœ€è¿”å›å¶å­èŠ‚ç‚¹çš„å€¼ä½œä¸ºè®¡ç®—ç»“æœå³å¯ã€‚æœ¬ä¾‹ä¸­ï¼Œè¿”å›æ•´æ•°3ã€‚

è‡³æ­¤ï¼Œå·²ç»ä¸ºé¡¶å±‚çš„`operator.add`è°ƒç”¨è®¡ç®—å‡ºä¸€ä¸ªå‚æ•°çš„å€¼äº†ï¼Œä½†è¿˜æ²¡å®Œã€‚ç»§ç»­ä»å·¦åˆ°å³çš„å‚æ•°è®¡ç®—è¿‡ç¨‹ï¼Œç°åœ¨è¿›è¡Œä¸€ä¸ªé€’å½’è°ƒç”¨ï¼Œè®¡ç®—æ ¹èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ã€‚å‘ç°è¯¥èŠ‚ç‚¹ä¸ä»…æœ‰å·¦å­èŠ‚ç‚¹ï¼Œè¿˜æœ‰å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ£€æŸ¥èŠ‚ç‚¹å­˜å‚¨çš„è¿ç®—ç¬¦â€”â€”æ˜¯ï¼Šï¼Œå°†å·¦å³å­èŠ‚ç‚¹ä½œä¸ºå‚æ•°è°ƒç”¨å‡½æ•°ã€‚è¿™æ—¶å¯ä»¥çœ‹åˆ°ï¼Œä¸¤ä¸ªè°ƒç”¨éƒ½å·²åˆ°è¾¾å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—ç»“æœåˆ†åˆ«æ˜¯4å’Œ5ã€‚ç®—å‡ºå‚æ•°ä¹‹åï¼Œè¿”å›operator.mul(4, 5)çš„ç»“æœã€‚è‡³æ­¤ï¼Œå·²ç»ç®—å‡ºäº†é¡¶å±‚è¿ç®—ç¬¦ï¼ˆ+ï¼‰çš„æ“ä½œæ•°ï¼Œå‰©ä¸‹çš„å·¥ä½œå°±æ˜¯å®Œæˆå¯¹operator.add(3, 20)çš„è°ƒç”¨ã€‚å› æ­¤ï¼Œè¡¨è¾¾å¼(3 + (4 âˆ— 5))çš„è®¡ç®—ç»“æœå°±æ˜¯23ã€‚

#### 4.1.3 ç¼–ç¨‹é¢˜ç›®

##### ç»ƒä¹ M25140: æ ¹æ®ååºè¡¨è¾¾å¼å»ºç«‹é˜Ÿåˆ—è¡¨è¾¾å¼

http://cs101.openjudge.cn/practice/25140/

ååºç®—æœ¯è¡¨è¾¾å¼å¯ä»¥é€šè¿‡æ ˆæ¥è®¡ç®—å…¶å€¼ï¼Œåšæ³•å°±æ˜¯ä»å·¦åˆ°å³æ‰«æè¡¨è¾¾å¼ï¼Œç¢°åˆ°æ“ä½œæ•°å°±å…¥æ ˆï¼Œç¢°åˆ°è¿ç®—ç¬¦ï¼Œå°±å–å‡ºæ ˆé¡¶çš„2ä¸ªæ“ä½œæ•°åšè¿ç®—(å…ˆå‡ºæ ˆçš„æ˜¯ç¬¬äºŒä¸ªæ“ä½œæ•°ï¼Œåå‡ºæ ˆçš„æ˜¯ç¬¬ä¸€ä¸ª)ï¼Œå¹¶å°†è¿ç®—ç»“æœå‹å…¥æ ˆä¸­ã€‚æœ€åæ ˆé‡Œåªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå°±æ˜¯è¡¨è¾¾å¼çš„å€¼ã€‚

æœ‰ä¸€ç§ç®—æœ¯è¡¨è¾¾å¼ä¸å¦¨å«åšâ€œé˜Ÿåˆ—è¡¨è¾¾å¼â€ï¼Œå®ƒçš„æ±‚å€¼è¿‡ç¨‹å’Œååºè¡¨è¾¾å¼å¾ˆåƒï¼Œåªæ˜¯å°†æ ˆæ¢æˆäº†é˜Ÿåˆ—ï¼šä»å·¦åˆ°å³æ‰«æè¡¨è¾¾å¼ï¼Œç¢°åˆ°æ“ä½œæ•°å°±å…¥é˜Ÿåˆ—ï¼Œç¢°åˆ°è¿ç®—ç¬¦ï¼Œå°±å–å‡ºé˜Ÿå¤´2ä¸ªæ“ä½œæ•°åšè¿ç®—ï¼ˆå…ˆå‡ºé˜Ÿçš„æ˜¯ç¬¬2ä¸ªæ“ä½œæ•°ï¼Œåå‡ºé˜Ÿçš„æ˜¯ç¬¬1ä¸ªï¼‰ï¼Œå¹¶å°†è¿ç®—ç»“æœåŠ å…¥é˜Ÿåˆ—ã€‚æœ€åé˜Ÿåˆ—é‡Œåªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå°±æ˜¯è¡¨è¾¾å¼çš„å€¼ã€‚

ç»™å®šä¸€ä¸ªååºè¡¨è¾¾å¼ï¼Œè¯·è½¬æ¢æˆç­‰ä»·çš„é˜Ÿåˆ—è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼Œ`3 4 + 6 5 * -`çš„ç­‰ä»·é˜Ÿåˆ—è¡¨è¾¾å¼å°±æ˜¯`5 6 4 3 * + -` ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ­£æ•´æ•° n (n<100)ã€‚æ¥ä¸‹æ¥æ˜¯nè¡Œï¼Œæ¯è¡Œä¸€ä¸ªç”±å­—æ¯æ„æˆçš„å­—ç¬¦ä¸²ï¼Œé•¿åº¦ä¸è¶…è¿‡100,è¡¨ç¤ºä¸€ä¸ªååºè¡¨è¾¾å¼ï¼Œå…¶ä¸­å°å†™å­—æ¯æ˜¯æ“ä½œæ•°ï¼Œå¤§å†™å­—æ¯æ˜¯è¿ç®—ç¬¦ã€‚è¿ç®—ç¬¦éƒ½æ˜¯éœ€è¦2ä¸ªæ“ä½œæ•°çš„ã€‚

**è¾“å‡º**

å¯¹æ¯ä¸ªååºè¡¨è¾¾å¼ï¼Œè¾“å‡ºå…¶ç­‰ä»·çš„é˜Ÿåˆ—è¡¨è¾¾å¼ã€‚

æ ·ä¾‹è¾“å…¥

```
2
xyPzwIM
abcABdefgCDEF
```

æ ·ä¾‹è¾“å‡º

```
wzyxIPM
gfCecbDdAaEBF
```

æç¤º

<mark>å»ºç«‹èµ·è¡¨è¾¾å¼æ ‘ï¼ŒæŒ‰å±‚æ¬¡éå†è¡¨è¾¾å¼æ ‘çš„ç»“æœå‰åé¢ å€’å°±å¾—åˆ°é˜Ÿåˆ—è¡¨è¾¾å¼</mark>

æ¥æºï¼šGuo Wei modified from Ulm Local 2007



The problem is asking to convert a postfix expression to an equivalent queue expression. The queue expression is obtained by reversing the level order traversal of the expression tree built from the postfix expression.  

Here is a step-by-step plan:  
1.Create a TreeNode class to represent each node in the tree.
2.Create a function build_tree that takes the postfix expression as input and returns the root of the constructed tree.
	Use a stack to store the nodes.
	Iterate over the characters in the postfix expression.
	If the character is an operand, create a new node and push it onto the stack.
	If the character is an operator, pop two nodes from the stack, make them the children of a new node, and push the new node onto the stack.
3.Create a function level_order_traversal that takes the root of the tree as input and returns the level order traversal of the tree.
	Use a queue `traversal` to store the nodes to be visited.
	While the queue is not empty, dequeue a node, visit it, and enqueue its children.
4.For each postfix expression, construct the tree, perform the level order traversal, reverse the result, and output it.

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def build_tree(postfix):
    stack = []
    for char in postfix:
        node = TreeNode(char)
        if char.isupper():
            node.right = stack.pop()
            node.left = stack.pop()
        stack.append(node)
    return stack[0]

def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal

n = int(input().strip())
for _ in range(n):
    postfix = input().strip()
    root = build_tree(postfix)
    queue_expression = level_order_traversal(root)[::-1]
    print(''.join(queue_expression))
```



### 4.2 ğŸŒ²çš„éå†åŠåº”ç”¨

æˆ‘ä»¬å·²ç»äº†è§£äº†æ ‘çš„åŸºæœ¬åŠŸèƒ½ï¼Œç°åœ¨æ˜¯æ—¶å€™çœ‹çœ‹ä¸€äº›é™„åŠ çš„ä½¿ç”¨æ¨¡å¼äº†ã€‚è¿™äº›ä½¿ç”¨æ¨¡å¼å¯ä»¥æŒ‰èŠ‚ç‚¹çš„è®¿é—®æ–¹å¼åˆ†ä¸º3ç§ã€‚æˆ‘ä»¬å°†å¯¹æ‰€æœ‰èŠ‚ç‚¹çš„è®¿é—®ç§°ä¸ºâ€œéå†â€ï¼Œå…±æœ‰3ç§éå†æ–¹å¼ï¼Œåˆ†åˆ«ä¸ºå‰åºéå†ã€ä¸­åºéå†å’Œååºéå†ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å…ˆä»”ç»†åœ°å®šä¹‰è¿™3ç§éå†æ–¹å¼ï¼Œç„¶åé€šè¿‡ä¸€äº›ä¾‹å­çœ‹çœ‹å®ƒä»¬çš„ç”¨æ³•ã€‚

> **å‰åºéå†**
> åœ¨å‰åºéå†ä¸­ï¼Œå…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’åœ°å‰åºéå†å·¦å­æ ‘ï¼Œæœ€åé€’å½’åœ°å‰åºéå†å³å­æ ‘ã€‚
>
> **ä¸­åºéå†**
> åœ¨ä¸­åºéå†ä¸­ï¼Œå…ˆé€’å½’åœ°ä¸­åºéå†å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åé€’å½’åœ°ä¸­åºéå†å³å­æ ‘ã€‚
>
> **ååºéå†**
> åœ¨ååºéå†ä¸­ï¼Œå…ˆé€’å½’åœ°ååºéå†å·¦å­æ ‘ï¼Œç„¶åé€’å½’åœ°ååºéå†å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ã€‚

è®©æˆ‘ä»¬é€šè¿‡å‡ ä¸ªä¾‹å­æ¥ç†è§£è¿™3ç§éå†æ–¹å¼ã€‚é¦–å…ˆçœ‹çœ‹å‰åºéå†ã€‚<mark>å°†ä¸€æœ¬ä¹¦çš„å†…å®¹ç»“æ„è¡¨ç¤ºä¸ºä¸€æ£µæ ‘</mark>ï¼Œæ•´æœ¬ä¹¦æ˜¯æ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸€ç« æ˜¯æ ¹èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œæ¯ä¸€ç« ä¸­çš„æ¯ä¸€èŠ‚æ˜¯è¿™ç« çš„å­èŠ‚ç‚¹ï¼Œæ¯å°èŠ‚åˆæ˜¯è¿™èŠ‚çš„å­èŠ‚ç‚¹ï¼Œä¾æ­¤ç±»æ¨ã€‚å›¾8 å±•ç¤ºäº†ä¸€æœ¬ä¹¦çš„æ ‘çŠ¶ç»“æ„ï¼Œå®ƒåŒ…å«ä¸¤ç« ã€‚æ³¨æ„ï¼Œ<mark>éå†ç®—æ³•å¯¹æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°æ²¡æœ‰è¦æ±‚</mark>ï¼Œä½†æœ¬ä¾‹åªé’ˆå¯¹äºŒå‰æ ‘ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/booktree.png" alt="image" style="zoom:67%;" />

<center>å›¾8 ä¸€æœ¬ä¹¦çš„æ ‘çŠ¶ç»“æ„</center>

<mark>å‡è®¾æˆ‘ä»¬ä»å‰å¾€åé˜…è¯»è¿™æœ¬ä¹¦ï¼Œé‚£ä¹ˆé˜…è¯»é¡ºåºå°±ç¬¦åˆå‰åºéå†çš„æ¬¡åº</mark>ã€‚ä»æ ¹èŠ‚ç‚¹â€œä¹¦â€å¼€å§‹ï¼Œéµå¾ªå‰åºéå†æŒ‡ä»¤ï¼Œå¯¹å·¦å­èŠ‚ç‚¹â€œç¬¬1ç« â€é€’å½’è°ƒç”¨preorderå‡½æ•°ã€‚ç„¶åï¼Œå¯¹â€œç¬¬1ç« â€çš„å·¦å­èŠ‚ç‚¹é€’å½’è°ƒç”¨preorderå‡½æ•°ï¼Œå¾—åˆ°èŠ‚ç‚¹â€œ1.1èŠ‚â€ã€‚ç”±äºè¯¥èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œå› æ­¤ä¸å¿…å†è¿›è¡Œé€’å½’è°ƒç”¨ã€‚æ²¿ç€æ ‘å›åˆ°èŠ‚ç‚¹â€œç¬¬1ç« â€ï¼Œæ¥ä¸‹æ¥è®¿é—®å®ƒçš„å³å­èŠ‚ç‚¹ï¼Œå³â€œ1.2èŠ‚â€ã€‚å’Œå‰é¢ä¸€æ ·ï¼Œå…ˆè®¿é—®å·¦å­èŠ‚ç‚¹â€œ1.2.1èŠ‚â€ï¼Œç„¶åè®¿é—®å³å­èŠ‚ç‚¹â€œ1.2.2èŠ‚â€ã€‚è®¿é—®å®Œâ€œ1.2èŠ‚â€ä¹‹åï¼Œå›åˆ°â€œç¬¬1ç« â€ã€‚æ¥ä¸‹æ¥ï¼Œå›åˆ°æ ¹èŠ‚ç‚¹ï¼Œä»¥åŒæ ·çš„æ–¹å¼è®¿é—®èŠ‚ç‚¹â€œç¬¬2ç« â€ã€‚

<mark>éå†æ ‘çš„ä»£ç æ ¼å¤–ç®€æ´ï¼Œè¿™ä¸»è¦æ˜¯å› ä¸ºéå†æ˜¯é€’å½’çš„ã€‚</mark>

ä½ å¯èƒ½ä¼šæƒ³ï¼Œå‰åºéå†ç®—æ³•çš„æœ€ä½³å®ç°æ–¹å¼æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ˜¯ä¸€ä¸ªå°†æ ‘ç”¨ä½œæ•°æ®ç»“æ„çš„å‡½æ•°ï¼Œè¿˜æ˜¯æ ‘æœ¬èº«çš„ä¸€ä¸ªæ–¹æ³•ï¼Ÿä»£ç æ¸…å•6-11ç»™å‡ºäº†å‰åºéå†ç®—æ³•çš„å¤–éƒ¨å‡½æ•°ç‰ˆæœ¬ï¼Œè¯¥å‡½æ•°å°†äºŒå‰æ ‘ä½œä¸ºå‚æ•°ï¼Œå…¶ä»£ç å°¤ä¸ºç®€æ´ï¼Œè¿™æ˜¯å› ä¸ºç®—æ³•çš„åŸºæœ¬æƒ…å†µä»…ä»…æ˜¯æ£€æŸ¥æ ‘æ˜¯å¦å­˜åœ¨ã€‚å¦‚æœå‚æ•°treeæ˜¯Noneï¼Œå‡½æ•°ç›´æ¥è¿”å›ã€‚

ä»£ç æ¸…å•6-11 å°†å‰åºéå†ç®—æ³•å®ç°ä¸ºå¤–éƒ¨å‡½æ•°

```python
def preorder(tree):
    if tree:
        print(tree.getRootVal())
        preorder(tree.getLeftChild())
        preorder(tree.getRightChild())
```



ä¹Ÿå¯ä»¥å°†preorderå®ç°ä¸ºBinaryTreeç±»çš„æ–¹æ³•ï¼Œå¦‚ä»£ç æ¸…å•6-12æ‰€ç¤ºã€‚è¯·ç•™æ„å°†ä»£ç ä»å¤–éƒ¨ç§»åˆ°å†…éƒ¨åæœ‰ä½•å˜åŒ–ã€‚é€šå¸¸æ¥è¯´ï¼Œä¸ä»…éœ€è¦ç”¨selfä»£æ›¿treeï¼Œè¿˜éœ€è¦ä¿®æ”¹åŸºæœ¬æƒ…å†µã€‚<mark>å†…éƒ¨æ–¹æ³•å¿…é¡»åœ¨é€’å½’è°ƒç”¨preorderå‰ï¼Œæ£€æŸ¥å·¦å³å­èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ã€‚</mark>

ä»£ç æ¸…å•6-12 å°†å‰åºéå†ç®—æ³•å®ç°ä¸ºBinaryTreeç±»çš„æ–¹æ³•

```python
def preorder(self):
    print(self.key)
    if self.leftChild:
        self.leftChild.preorder()
    if self.rightChild:
        self.rightChild.preorder()
```



å“ªç§å®ç°æ–¹å¼æ›´å¥½å‘¢ï¼Ÿåœ¨æœ¬ä¾‹ä¸­ï¼Œå°†preorderå®ç°ä¸ºå¤–éƒ¨å‡½æ•°å¯èƒ½æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚åŸå› åœ¨äºï¼Œå¾ˆå°‘ä¼šä»…æ‰§è¡Œéå†æ“ä½œï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿˜è¦é€šè¿‡åŸºæœ¬çš„éå†æ¨¡å¼å®ç°åˆ«çš„ç›®æ ‡ã€‚åœ¨ä¸‹ä¸€ä¸ªä¾‹å­ä¸­ï¼Œå°±ä¼šé€šè¿‡ååºéå†æ¥è®¡ç®—è§£ææ ‘ã€‚æ‰€ä»¥ï¼Œåœ¨æ­¤é‡‡ç”¨å¤–éƒ¨å‡½æ•°ç‰ˆæœ¬ã€‚

åœ¨ä»£ç æ¸…å•6-13ä¸­ï¼Œååºéå†å‡½æ•°postorderä¸å‰åºéå†å‡½æ•°preorderå‡ ä¹ç›¸åŒï¼Œåªä¸è¿‡å¯¹printçš„è°ƒç”¨è¢«ç§»åˆ°äº†å‡½æ•°çš„æœ«å°¾ã€‚

ä»£ç æ¸…å•6-13 ååºéå†å‡½æ•°

```python
def postorder(tree):
    if tree != None:
        postorder(tree.getLeftChild())
        postorder(tree.getRightChild())
        print(tree.getRootVal())
```



æˆ‘ä»¬å·²ç»è§è¯†è¿‡<mark>ååºéå†çš„ä¸€ä¸ªå¸¸è§ç”¨é€”ï¼Œé‚£å°±æ˜¯è®¡ç®—è§£ææ ‘</mark>ã€‚<mark>å›é¡¾ä»£ç æ¸…å•6-10ï¼Œæ‰€åšçš„å°±æ˜¯å…ˆè®¡ç®—å·¦å­æ ‘ï¼Œå†è®¡ç®—å³å­æ ‘ï¼Œæœ€åé€šè¿‡æ ¹èŠ‚ç‚¹è¿ç®—ç¬¦çš„å‡½æ•°è°ƒç”¨å°†ä¸¤ä¸ªç»“æœç»“åˆèµ·æ¥ã€‚</mark>å‡è®¾äºŒå‰æ ‘åªå­˜å‚¨ä¸€ä¸ªè¡¨è¾¾å¼çš„æ•°æ®ã€‚è®©æˆ‘ä»¬æ¥é‡å†™è®¡ç®—å‡½æ•°ï¼Œä½¿ä¹‹æ›´æ¥è¿‘äºä»£ç æ¸…å•6-13ä¸­çš„ååºéå†å‡½æ•°ã€‚

#### 4.2.1 ååºæ±‚å€¼

ä»£ç æ¸…å•6-14 

```python
def postordereval(tree):
    opers = {'+':operator.add, '-':operator.sub, 
             '*':operator.mul, '/':operator.truediv}
    res1 = None
    res2 = None
    if tree:
        res1 = postordereval(tree.getLeftChild())
        res2 = postordereval(tree.getRightChild())
        if res1 and res2:
            return opers[tree.getRootVal()](res1,res2)
        else:
            return tree.getRootVal()
```

æ³¨æ„ï¼Œä»£ç æ¸…å•6-14ä¸ä»£ç æ¸…å•6-13åœ¨å½¢å¼ä¸Šå¾ˆç›¸ä¼¼ï¼Œåªä¸è¿‡æ±‚å€¼å‡½æ•°æœ€åä¸æ˜¯æ‰“å°èŠ‚ç‚¹ï¼Œè€Œæ˜¯è¿”å›èŠ‚ç‚¹ã€‚è¿™æ ·ä¸€æ¥ï¼Œå°±å¯ä»¥ä¿å­˜ä»ç¬¬7è¡Œå’Œç¬¬8è¡Œçš„é€’å½’è°ƒç”¨è¿”å›çš„å€¼ï¼Œç„¶ååœ¨ç¬¬10è¡Œä½¿ç”¨è¿™äº›å€¼å’Œè¿ç®—ç¬¦è¿›è¡Œè®¡ç®—ã€‚

æœ€åæ¥äº†è§£<mark>ä¸­åºéå†</mark>ã€‚ä¸­åºéå†çš„è®¿é—®é¡ºåºæ˜¯å·¦å­æ ‘ã€æ ¹èŠ‚ç‚¹ã€å³å­æ ‘ã€‚ä»£ç æ¸…å•6-15ç»™å‡ºäº†ä¸­åºéå†å‡½æ•°çš„ä»£ç ã€‚æ³¨æ„ï¼Œ3ä¸ªéå†å‡½æ•°çš„åŒºåˆ«ä»…åœ¨äºprintè¯­å¥ä¸é€’å½’è°ƒç”¨è¯­å¥çš„ç›¸å¯¹ä½ç½®ã€‚

ä»£ç æ¸…å•6-15 ä¸­åºéå†å‡½æ•°

```python
def inorder(tree):
    if tree != None:
        inorder(tree.getLeftChild())
        print(tree.getRootVal())
        inorder(tree.getRightChild())
```

<mark>é€šè¿‡ä¸­åºéå†è§£ææ ‘ï¼Œå¯ä»¥è¿˜åŸä¸å¸¦æ‹¬å·çš„è¡¨è¾¾å¼ã€‚</mark>æ¥ä¸‹æ¥ä¿®æ”¹ä¸­åºéå†ç®—æ³•ï¼Œä»¥å¾—åˆ°å®Œå…¨æ‹¬å·è¡¨è¾¾å¼ã€‚å”¯ä¸€è¦åšçš„ä¿®æ”¹æ˜¯ï¼šåœ¨é€’å½’è°ƒç”¨å·¦å­æ ‘å‰æ‰“å°ä¸€ä¸ªå·¦æ‹¬å·ï¼Œåœ¨é€’å½’è°ƒç”¨å³å­æ ‘åæ‰“å°ä¸€ä¸ªå³æ‹¬å·ã€‚ä»£ç æ¸…å•6-16æ˜¯ä¿®æ”¹åçš„å‡½æ•°ã€‚

#### 4.2.2 ä¸­åºè¿˜åŸå®Œå…¨æ‹¬å·è¡¨è¾¾å¼

ä»£ç æ¸…å•6-16 

```python
def printexp(tree):
    sVal = ""
    if tree:
        sVal = '(' + printexp(tree.getLeftChild())
        sVal = sVal + str(tree.getRootVal())
        sVal = sVal + printexp(tree.getRightChild()) + ')'
    return sVal

print(printexp(pt))
# (((7)+3)*((5)-2))
```



æ³¨æ„ï¼Œprintexpå‡½æ•°ç»™æ¯ä¸ªæ•°å­—éƒ½åŠ ä¸Šäº†æ‹¬å·ã€‚å°½ç®¡ä¸èƒ½ç®—é”™è¯¯ï¼Œä½†è¿™äº›æ‹¬å·æ˜¾ç„¶æ˜¯å¤šä½™çš„ã€‚è¯·ä¿®æ”¹printexpå‡½æ•°ï¼Œç§»é™¤è¿™äº›æ‹¬å·ã€‚



#### 4.2.3 ç¼–ç¨‹é¢˜ç›®



##### ç»ƒä¹ LC105.ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `preorder` å’Œ `inorder` ï¼Œå…¶ä¸­ `preorder` æ˜¯äºŒå‰æ ‘çš„**å…ˆåºéå†**ï¼Œ `inorder` æ˜¯åŒä¸€æ£µæ ‘çš„**ä¸­åºéå†**ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 1:**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" style="zoom:67%;" />

```
è¾“å…¥: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
è¾“å‡º: [3,9,20,null,null,15,7]
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: preorder = [-1], inorder = [-1]
è¾“å‡º: [-1]
```

 

**æç¤º:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` å’Œ `inorder` å‡ **æ— é‡å¤** å…ƒç´ 
- `inorder` å‡å‡ºç°åœ¨ `preorder`
- `preorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—
- `inorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—



```python
from typing import List, Optional
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        if not preorder or not inorder:
            return None

        # The first element in preorder is the root
        root_val = preorder[0]
        root = TreeNode(root_val)

        # Find the index of the root in inorder
        root_index = inorder.index(root_val)

        # Recursively build the left and right subtrees
        root.left = self.buildTree(preorder[1:1 + root_index], inorder[:root_index])
        root.right = self.buildTree(preorder[1 + root_index:], inorder[root_index + 1:])

        return root

if __name__ == '__main__':
    solution = Solution()
    preorder = [3, 9, 20, 15, 7]
    inorder = [9, 3, 15, 20, 7]
    root = solution.buildTree(preorder, inorder)
    # The output tree is [3, 9, 20, None, None, 15, 7]

```



<mark>ä»¥ä¸‹æ˜¯ä¸LC105ç±»ä¼¼çš„3ä¸ªé¢˜ç›®</mark>

###### 1ï¼‰ç»ƒä¹ M24750: æ ¹æ®äºŒå‰æ ‘ä¸­ååºåºåˆ—å»ºæ ‘

http://cs101.openjudge.cn/practice/24750/

å‡è®¾äºŒå‰æ ‘çš„èŠ‚ç‚¹é‡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å­—æ¯éƒ½ä¸åŒã€‚

ç»™å®šäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—å’Œååºéå†åºåˆ—ï¼ˆé•¿åº¦å‡ä¸è¶…è¿‡26ï¼‰ï¼Œè¯·è¾“å‡ºè¯¥äºŒå‰æ ‘çš„å‰åºéå†åºåˆ—ã€‚

**è¾“å…¥**

2è¡Œï¼Œå‡ä¸ºå¤§å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€æ£µäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—ä¸ååºéå†æ’åˆ—ã€‚

**è¾“å‡º**

è¡¨ç¤ºäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—ã€‚

æ ·ä¾‹è¾“å…¥

```
BADC
BDCA
```

æ ·ä¾‹è¾“å‡º

```
ABCD
```

æ¥æº

Lou Yuke



```python
"""
ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ç„¶åï¼Œåœ¨ä¸­åºéå†åºåˆ—ä¸­ï¼Œæ ¹èŠ‚ç‚¹å°†å·¦å³å­æ ‘åˆ†å¼€ã€‚
å¯ä»¥é€šè¿‡è¿™ç§æ–¹æ³•æ‰¾åˆ°å·¦å³å­æ ‘çš„ä¸­åºéå†åºåˆ—ã€‚ç„¶åï¼Œä½¿ç”¨é€’å½’åœ°å¤„ç†å·¦å³å­æ ‘æ¥æ„å»ºæ•´ä¸ªæ ‘ã€‚
"""

def build_tree(inorder, postorder):
    if not inorder or not postorder:
        return []

    root_val = postorder[-1]
    root_index = inorder.index(root_val)

    left_inorder = inorder[:root_index]
    right_inorder = inorder[root_index + 1:]

    left_postorder = postorder[:len(left_inorder)]
    right_postorder = postorder[len(left_inorder):-1]

    root = [root_val]
    root.extend(build_tree(left_inorder, left_postorder))
    root.extend(build_tree(right_inorder, right_postorder))

    return root


def main():
    inorder = input().strip()
    postorder = input().strip()
    preorder = build_tree(inorder, postorder)
    print(''.join(preorder))


if __name__ == "__main__":
    main()

```



```python
"""
å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ã€‚åœ¨è¿™ä¸ªé€’å½’å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å°†ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºå½“å‰çš„æ ¹èŠ‚ç‚¹ï¼Œç„¶ååœ¨ä¸­åºéå†åºåˆ—ä¸­æ‰¾åˆ°è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„ä½ç½®ï¼Œ
è¿™ä¸ªä½ç½®å°†ä¸­åºéå†åºåˆ—åˆ†ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘ã€‚
"""
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def buildTree(inorder, postorder):
    if not inorder or not postorder:
        return None

    # ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯å½“å‰çš„æ ¹èŠ‚ç‚¹
    root_val = postorder.pop()
    root = TreeNode(root_val)

    # åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®
    root_index = inorder.index(root_val)

    # æ„å»ºå³å­æ ‘å’Œå·¦å­æ ‘
    root.right = buildTree(inorder[root_index + 1:], postorder)
    root.left = buildTree(inorder[:root_index], postorder)

    return root


def preorderTraversal(root):
    result = []
    if root:
        result.append(root.val)
        result.extend(preorderTraversal(root.left))
        result.extend(preorderTraversal(root.right))
    return result


# è¯»å–è¾“å…¥
inorder = input().strip()
postorder = input().strip()

# æ„å»ºæ ‘
root = buildTree(list(inorder), list(postorder))

# è¾“å‡ºå‰åºéå†åºåˆ—
print(''.join(preorderTraversal(root)))
```







###### 2ï¼‰ç»ƒä¹ M22158: æ ¹æ®äºŒå‰æ ‘å‰ä¸­åºåºåˆ—å»ºæ ‘

http://cs101.openjudge.cn/practice/22158/

å‡è®¾äºŒå‰æ ‘çš„èŠ‚ç‚¹é‡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å­—æ¯éƒ½ä¸åŒã€‚

ç»™å®šäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—å’Œä¸­åºéå†åºåˆ—(é•¿åº¦å‡ä¸è¶…è¿‡26)ï¼Œè¯·è¾“å‡ºè¯¥äºŒå‰æ ‘çš„ååºéå†åºåˆ—

**è¾“å…¥**

å¤šç»„æ•°æ®
æ¯ç»„æ•°æ®2è¡Œï¼Œç¬¬ä¸€è¡Œæ˜¯å‰åºéå†åºåˆ—ï¼Œç¬¬äºŒè¡Œæ˜¯ä¸­åºéå†åºåˆ—

**è¾“å‡º**

å¯¹æ¯ç»„åºåˆ—å»ºæ ‘ï¼Œè¾“å‡ºè¯¥æ ‘çš„ååºéå†åºåˆ—

æ ·ä¾‹è¾“å…¥

```
DURPA
RUDPA
XTCNB
CTBNX
```

æ ·ä¾‹è¾“å‡º

```
RUAPD
CBNTX
```

æ¥æºï¼šéƒ­ç‚œ



The problem is asking to construct a binary tree from given preorder and inorder traversal sequences, and then output the postorder traversal sequence of the constructed tree.  

Here is a step-by-step plan:  
1.Create a TreeNode class to represent each node in the tree.
2.Create a function build_tree that takes the preorder and inorder sequences as input and returns the root of the constructed tree.
	The first character of the preorder sequence is the root of the tree.
	Find the position of the root in the inorder sequence.
	Recursively construct the left subtree using the left part of the inorder sequence and the corresponding part of the preorder sequence.
	Recursively construct the right subtree using the right part of the inorder sequence and the corresponding part of the preorder sequence.
3.Create a function postorder_traversal that takes the root of the tree as input and returns the postorder traversal sequence of the tree.
4.For each pair of preorder and inorder sequences, construct the tree and output the postorder traversal sequence.
Here is the Python code that implements this plan:

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def build_tree(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_value = preorder[0]
    root = TreeNode(root_value)
    root_index_inorder = inorder.index(root_value)
    root.left = build_tree(preorder[1:1+root_index_inorder], inorder[:root_index_inorder])
    root.right = build_tree(preorder[1+root_index_inorder:], inorder[root_index_inorder+1:])
    return root

def postorder_traversal(root):
    if root is None:
        return ''
    return postorder_traversal(root.left) + postorder_traversal(root.right) + root.value

while True:
    try:
        preorder = input().strip()
        inorder = input().strip()
        root = build_tree(preorder, inorder)
        print(postorder_traversal(root))
    except EOFError:
        break
```



###### 3ï¼‰ç»ƒä¹ M25145: çŒœäºŒå‰æ ‘ï¼ˆæŒ‰å±‚æ¬¡éå†ï¼‰

http://cs101.openjudge.cn/practice/25145/

ä¸€æ£µäºŒå‰æ ‘ï¼Œç»“ç‚¹éƒ½æ˜¯å¤§å†™è‹±æ–‡å­—æ¯ï¼Œä¸”ä¸é‡å¤ã€‚

ç»™å‡ºå®ƒçš„ä¸­åºéå†åºåˆ—å’Œååºéå†åºåˆ—ï¼Œæ±‚å…¶æŒ‰å±‚æ¬¡éå†çš„åºåˆ—ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°n, n <=30ï¼Œè¡¨ç¤ºæœ‰næ£µäºŒå‰æ ‘
æ¥ä¸‹æ¥æ¯ä¸¤è¡Œä»£è¡¨ä¸€æ£µäºŒå‰æ ‘ï¼Œç¬¬ä¸€è¡Œæ˜¯å…¶ä¸­åºéå†åºåˆ—ï¼Œç¬¬äºŒè¡Œæ˜¯ååºéå†åºåˆ—

**è¾“å‡º**

å¯¹æ¯æ£µäºŒå‰æ ‘è¾“å‡ºå…¶æŒ‰å±‚æ¬¡éå†åºåˆ—

æ ·ä¾‹è¾“å…¥

```
2
LZGD
LGDZ
BKTVQP
TPQVKB
```

æ ·ä¾‹è¾“å‡º

```
ZLDG
BKVTQP
```

æ¥æº: Guo Wei



```python
from collections import deque

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def build_tree(inorder, postorder):
    if inorder:
        root = Node(postorder.pop())
        root_index = inorder.index(root.data)
        root.right = build_tree(inorder[root_index+1:], postorder)
        root.left = build_tree(inorder[:root_index], postorder)
        return root

def level_order_traversal(root):
    if root is None:
        return []
    result = []
    queue = deque([root])
    while queue:
        node = queue.popleft()
        result.append(node.data)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return result

n = int(input())
for _ in range(n):
    inorder = list(input().strip())
    postorder = list(input().strip())
    root = build_tree(inorder, postorder)
    print(''.join(level_order_traversal(root)))
```



##### ç»ƒä¹ T20576: printExpï¼ˆé€†æ³¢å…°è¡¨è¾¾å¼å»ºæ ‘ï¼‰

http://cs101.openjudge.cn/practice/20576/

è¾“å‡ºä¸­ç¼€è¡¨è¾¾å¼ï¼ˆå»é™¤ä¸å¿…è¦çš„æ‹¬å·ï¼‰

**è¾“å…¥**

ä¸€ä¸ªå­—ä¸²

**è¾“å‡º**

ä¸€ä¸ªå­—ä¸²

æ ·ä¾‹è¾“å…¥

```
( not ( True or False ) ) and ( False or True and True )
```

æ ·ä¾‹è¾“å‡º

```
not ( True or False ) and ( False or True and True )
```



<mark>è¿™ä¸‰ä¸ªæ“ä½œç¬¦ï¼š`not`ï¼šä¼˜å…ˆçº§æœ€é«˜ï¼Œ`and`ï¼šå…¶æ¬¡ï¼Œ`or`ï¼šä¼˜å…ˆçº§æœ€ä½ã€‚</mark>

```python
class BinaryTree:
    def __init__(self, root, left=None, right=None):
        self.root = root
        self.leftChild = left
        self.rightChild = right

    def getrightchild(self):
        return self.rightChild

    def getleftchild(self):
        return self.leftChild

    def getroot(self):
        return self.root

def postorder(string):    #ä¸­ç¼€æ”¹åç¼€ Shunting yard algorightm
    opStack = []
    postList = []
    inList = string.split()
    prec = { '(': 0, 'or': 1,'and': 2,'not': 3}

    for word in inList:
        if word == '(':
            opStack.append(word)
        elif word == ')':
            topWord = opStack.pop()
            while topWord != '(':
                postList.append(topWord)
                topWord = opStack.pop()
        elif word == 'True' or word == 'False':
            postList.append(word)
        else:
            while opStack and prec[word] <= prec[opStack[-1]]:
                postList.append(opStack.pop())
            opStack.append(word)
    while opStack:
        postList.append(opStack.pop())
    return postList

def buildParseTree(infix):       #ä»¥åç¼€è¡¨è¾¾å¼ä¸ºåŸºç¡€å»ºæ ‘
    postList = postorder(infix)
    stack = []
    for word in postList:
        if word == 'not':
            newTree = BinaryTree(word)
            newTree.leftChild = stack.pop()
            stack.append(newTree)
        elif word == 'True' or word == 'False':
            stack.append(BinaryTree(word))
        else:
            right = stack.pop()
            left = stack.pop()
            newTree = BinaryTree(word)
            newTree.leftChild = left
            newTree.rightChild = right
            stack.append(newTree)
    currentTree = stack[-1]
    return currentTree

def printTree(parsetree: BinaryTree):
    if parsetree.getroot() == 'or':
        return printTree(parsetree.getleftchild()) + ['or'] + printTree(parsetree.getrightchild())
    elif parsetree.getroot() == 'not':
        return ['not'] + (
            ['('] + printTree(parsetree.getleftchild()) + [')']
            if parsetree.leftChild.getroot() not in ['True', 'False']
            else printTree(parsetree.getleftchild())
        )
    elif parsetree.getroot() == 'and':
        leftpart = (
            ['('] + printTree(parsetree.getleftchild()) + [')']
            if parsetree.leftChild.getroot() == 'or'
            else printTree(parsetree.getleftchild())
        )
        rightpart = (
            ['('] + printTree(parsetree.getrightchild()) + [')']
            if parsetree.rightChild.getroot() == 'or'
            else printTree(parsetree.getrightchild())
        )
        return leftpart + ['and'] + rightpart
    else:
        return [str(parsetree.getroot())]

def main():
    infix = input()
    Tree = buildParseTree(infix)
    print(' '.join(printTree(Tree)))

main()
```



`printTree`å‡½æ•°æ˜¯ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ª`BinaryTree`å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œç„¶åæ ¹æ®æ ‘çš„ç»“æ„å’ŒèŠ‚ç‚¹çš„å€¼ç”Ÿæˆä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ã€‚

å‡½æ•°çš„å·¥ä½œæ–¹å¼å¦‚ä¸‹ï¼š

1. é¦–å…ˆï¼Œæ£€æŸ¥æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ã€‚æ ¹æ®å€¼çš„ä¸åŒï¼Œå‡½æ•°ä¼šæ‰§è¡Œä¸åŒçš„æ“ä½œã€‚

2. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"or"ï¼Œå‡½æ•°ä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«æ¥å¤„ç†å·¦å­æ ‘å’Œå³å­æ ‘ï¼Œç„¶åå°†ç»“æœåˆå¹¶ï¼Œå¹¶åœ¨ä¸¤ä¸ªç»“æœä¹‹é—´æ’å…¥"or"ã€‚

3. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"not"ï¼Œå‡½æ•°ä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«æ¥å¤„ç†å·¦å­æ ‘ã€‚<mark>å¦‚æœå·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ä¸æ˜¯"True"æˆ–"False"ï¼Œåˆ™ä¼šåœ¨å·¦å­æ ‘çš„ç»“æœå‘¨å›´æ·»åŠ æ‹¬å·ã€‚</mark>

4. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"and"ï¼Œå‡½æ•°ä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«æ¥å¤„ç†å·¦å­æ ‘å’Œå³å­æ ‘ã€‚<mark>å¦‚æœå·¦å­æ ‘æˆ–å³å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ä¸º"or"ï¼Œåˆ™ä¼šåœ¨ç›¸åº”å­æ ‘çš„ç»“æœå‘¨å›´æ·»åŠ æ‹¬å·ã€‚</mark>

5. å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼ä¸º"True"æˆ–"False"ï¼Œå‡½æ•°ä¼šç›´æ¥è¿”å›ä¸€ä¸ªåŒ…å«è¯¥å€¼çš„åˆ—è¡¨ã€‚

6. æœ€åï¼Œå‡½æ•°ä¼šå°†ç”Ÿæˆçš„å­—ç¬¦ä¸²åˆ—è¡¨åˆå¹¶ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›ã€‚

> `printTree` å‡½æ•°çš„ç¡®æ˜¯è¿™ä¸ªç¨‹åºçš„å…³é”®éƒ¨åˆ†ï¼Œå®ƒè´Ÿè´£**æŠŠè¡¨è¾¾å¼æ ‘é‡æ–°è½¬æˆä¸­ç¼€è¡¨è¾¾å¼**ï¼Œè€Œä¸”åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­è¦**å»æ‰ä¸å¿…è¦çš„æ‹¬å·ï¼Œåªä¿ç•™å¿…è¦çš„æ‹¬å·**ï¼Œä»¥ä¿è¯è¡¨è¾¾å¼çš„ä¼˜å…ˆçº§æ­£ç¡®ã€‚
>
> æˆ‘ä»¬æ¥**ä¸€è¡Œè¡Œåˆ†æè¿™ä¸ªå‡½æ•°**ï¼Œå¹¶ä¸”ç»“åˆä¼˜å…ˆçº§è§„åˆ™æ¥è¯¦ç»†è§£é‡Šã€‚
>
> ---
>
> âœ… èƒŒæ™¯çŸ¥è¯†ï¼ˆéå¸¸é‡è¦ï¼‰
>
> æˆ‘ä»¬æœ‰ 3 ä¸ªæ“ä½œç¬¦ï¼š
>
> - `not`ï¼šä¼˜å…ˆçº§æœ€é«˜ï¼ˆ3ï¼‰
> - `and`ï¼šä¸­é—´ï¼ˆ2ï¼‰
> - `or`ï¼šæœ€ä½ï¼ˆ1ï¼‰
>
> æ‰€ä»¥å½“æˆ‘ä»¬é‡å»ºä¸­ç¼€è¡¨è¾¾å¼æ—¶ï¼Œå¦‚æœä½ä¼˜å…ˆçº§çš„æ“ä½œè¢«åµŒå¥—åœ¨é«˜ä¼˜å…ˆçº§çš„æ“ä½œé‡Œé¢ï¼Œé‚£å°±**éœ€è¦åŠ æ‹¬å·**æ¥ä¿æŒåŸæ¥çš„ä¼˜å…ˆé¡ºåºã€‚
>
> ---
>
> ğŸ’¡ å‡½æ•°ç­¾å
>
> ```python
> def printTree(parsetree: BinaryTree):
> ```
>
> è¿™æ˜¯ä¸€ä¸ªé€’å½’å‡½æ•°ã€‚æ¯æ¬¡è°ƒç”¨ä¼šå¤„ç†ä¸€ä¸ªå­æ ‘ï¼Œè¿”å›ä¸€ä¸ª**å­—ç¬¦ä¸²åˆ—è¡¨**ï¼ˆæœ€åç”¨ `' '.join()` ç»„åˆæˆç»“æœï¼‰ã€‚
>
> ---
>
> ğŸ§© æƒ…å†µ 1ï¼šå½“å‰èŠ‚ç‚¹æ˜¯ `or`
>
> ```python
> if parsetree.getroot() == 'or':
>     return printTree(parsetree.getleftchild()) + ['or'] + printTree(parsetree.getrightchild())
> ```
>
> - `or` æ˜¯æœ€ä½ä¼˜å…ˆçº§ï¼Œæ‰€ä»¥å®ƒ**æ°¸è¿œä¸ä¼šè¢«å…¶ä»–æ“ä½œåŒ…è£¹ä½**ï¼ˆä¸éœ€è¦åŠ æ‹¬å·ï¼‰
> - å·¦å³å­æ ‘åˆ†åˆ«å¤„ç†å°±å¥½ï¼Œä¸­é—´åŠ ä¸Š `'or'`
>
> ---
>
> ğŸ§© æƒ…å†µ 2ï¼šå½“å‰èŠ‚ç‚¹æ˜¯ `not`
>
> ```python
> elif parsetree.getroot() == 'not':
>     return ['not'] + (
>         ['('] + printTree(parsetree.getleftchild()) + [')']
>         if parsetree.leftChild.getroot() not in ['True', 'False']
>         else printTree(parsetree.getleftchild())
>     )
> ```
>
> - `not` æ˜¯å•ç›®æ“ä½œç¬¦ï¼ˆåªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼‰
>
> - å¦‚æœå®ƒçš„å­èŠ‚ç‚¹æ˜¯ `'True'` æˆ– `'False'`ï¼Œå°±ç›´æ¥å†™ï¼š
>
>   ```
>   not True
>   ```
>
> - ä½†å¦‚æœå­èŠ‚ç‚¹æ˜¯åƒ `True or False` è¿™æ ·çš„è¡¨è¾¾å¼ï¼Œéœ€è¦åŠ æ‹¬å·åŒ…ä½å®ƒï¼š
>
>   ```
>   not (True or False)
>   ```
>
> ğŸ‘‰ è¿™æ˜¯ä¸ºäº†é˜²æ­¢è¡¨è¾¾å¼ä¼˜å…ˆçº§å‡ºé”™ï¼
>
> ---
>
> ğŸ§© æƒ…å†µ 3ï¼šå½“å‰èŠ‚ç‚¹æ˜¯ `and`
>
> ```python
> elif parsetree.getroot() == 'and':
>     leftpart = (
>         ['('] + printTree(parsetree.getleftchild()) + [')']
>         if parsetree.leftChild.getroot() == 'or'
>         else printTree(parsetree.getleftchild())
>     )
>     rightpart = (
>         ['('] + printTree(parsetree.getrightchild()) + [')']
>         if parsetree.rightChild.getroot() == 'or'
>         else printTree(parsetree.getrightchild())
>     )
>     return leftpart + ['and'] + rightpart
> ```
>
> - `and` çš„ä¼˜å…ˆçº§é«˜äº `or`
>
> - å¦‚æœå®ƒçš„æŸä¸ªå­èŠ‚ç‚¹æ˜¯ `or`ï¼Œå°±å¿…é¡»åŠ æ‹¬å·ï¼š
>
>   ```
>   (A or B) and C
>   ```
>
> å¦åˆ™è¡¨è¾¾å¼ä¼˜å…ˆçº§å°±ä¼šé”™äº†ï¼
>
> **ä¾‹å­ï¼š**
>
> - æ­£ç¡®çš„ï¼š`(True or False) and True`
> - é”™è¯¯çš„ï¼š`True or False and True`ï¼ˆè¿™ä¸ªæ„æ€ä¸ä¸€æ ·ï¼‰
>
> ---
>
> ğŸ§© æƒ…å†µ 4ï¼šå¶å­èŠ‚ç‚¹ï¼ˆTrue æˆ– Falseï¼‰
>
> ```python
> else:
>     return [str(parsetree.getroot())]
> ```
>
> è¿™ä¸ªå°±æ˜¯é€’å½’åˆ°åº•äº†ï¼Œè¿”å›å¸ƒå°”å€¼ï¼ˆå­—ç¬¦ä¸²å½¢å¼ï¼‰
>
> ---
>
> ğŸ” æ€»ç»“ï¼šå¦‚ä½•åˆ¤æ–­åŠ ä¸åŠ æ‹¬å·ï¼Ÿ
>
> - `or` æœ€ä½ä¼˜å…ˆçº§ï¼Œä»ä¸åŠ æ‹¬å·ã€‚
> - `and` å¦‚æœæ“ä½œçš„æ˜¯ `or`ï¼Œè¦åŠ æ‹¬å·ã€‚
> - `not` å¦‚æœæ“ä½œçš„æ˜¯å¤æ‚è¡¨è¾¾å¼ï¼ˆä¸æ˜¯å¸ƒå°”å¸¸é‡ï¼‰ï¼Œè¦åŠ æ‹¬å·ã€‚
>
> ---
>
> âœ¨ä¸¾ä¸ªå®Œæ•´ä¾‹å­
>
> è¾“å…¥ï¼š
>
> ```plaintext
> ( not ( True or False ) ) and ( False or True and True )
> ```
>
> è¾“å‡ºï¼š
>
> ```plaintext
> not ( True or False ) and ( False or True and True )
> ```
>
> è¯´æ˜ï¼š
>
> - `not` æ“ä½œ `True or False` â†’ åŠ æ‹¬å· âœ…
> - `and` çš„å·¦å³ï¼š
>   - å·¦æ˜¯ `not (...)`ï¼šä¸éœ€è¦é¢å¤–æ‹¬å·
>   - å³æ˜¯ `False or True and True`ï¼ŒæŒ‰ä¼˜å…ˆçº§å°±æ˜¯ `False or (True and True)`ï¼Œä¸éœ€è¦é¢å¤–æ‹¬å·





### 4.3 éœå¤«æ›¼ç¼–ç Huffman code

> 2013-book-Data Structures And Algorithms In Python

åœ¨è¿™ä¸€èŠ‚ä¸­ï¼Œè€ƒè™‘ä¸€ä¸ªé‡è¦çš„æ–‡æœ¬å¤„ç†ä»»åŠ¡ï¼šæ–‡æœ¬å‹ç¼©ã€‚åœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªåœ¨æŸäº›å­—æ¯è¡¨ï¼ˆå¦‚ASCIIå­—ç¬¦é›†ï¼‰ä¸Šå®šä¹‰çš„å­—ç¬¦ä¸²Xï¼Œå¹¶å¸Œæœ›å°†å…¶é«˜æ•ˆåœ°ç¼–ç ä¸ºä¸€ä¸ªè¾ƒå°çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²Yï¼ˆä»…ä½¿ç”¨0å’Œ1å­—ç¬¦ï¼‰ã€‚æ–‡æœ¬å‹ç¼©åœ¨ä»»ä½•å¸Œæœ›å‡å°‘æ•°å­—é€šä¿¡å¸¦å®½çš„æƒ…å†µä¸‹éƒ½éå¸¸æœ‰ç”¨ï¼Œä»¥ä¾¿<mark>æœ€å°åŒ–ä¼ è¾“æ–‡æœ¬æ‰€éœ€çš„æ—¶é—´</mark>ã€‚åŒæ ·ï¼Œæ–‡æœ¬å‹ç¼©å¯¹äºæ›´é«˜æ•ˆåœ°å­˜å‚¨å¤§å‹æ–‡æ¡£ä¹Ÿå¾ˆæœ‰ç”¨ï¼Œä»è€Œ<mark>å…è®¸å›ºå®šå®¹é‡çš„å­˜å‚¨è®¾å¤‡åŒ…å«å°½å¯èƒ½å¤šçš„æ–‡æ¡£</mark>ã€‚

> In this section, we consider an important text-processing task, text compression. In this problem, we are given a string X defined over some alphabet, such as the ASCII  character sets, and we want to efficiently encode X into a small binary string Y (using only the characters 0 and 1). Text compression is useful in any situation where we wish to reduce bandwidth for digital communications, soas to minimize the time needed to transmit our text. Likewise, text compression is useful for storing large documents more efficiently, so as to allow a fixed-capacity storage device to contain as many documents as possible.

æœ¬èŠ‚æ¢è®¨çš„æ–‡æœ¬å‹ç¼©æ–¹æ³•æ˜¯**Huffman code**ã€‚åƒASCIIè¿™æ ·çš„æ ‡å‡†ç¼–ç æ–¹æ¡ˆä½¿ç”¨å›ºå®šé•¿åº¦çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²æ¥ç¼–ç å­—ç¬¦ï¼ˆåœ¨ä¼ ç»Ÿçš„æˆ–æ‰©å±•çš„ASCIIç³»ç»Ÿä¸­åˆ†åˆ«ä¸º7ä½æˆ–8ä½ï¼‰ã€‚Huffman codeé€šè¿‡<mark>ä½¿ç”¨è¾ƒçŸ­çš„ç å­—code-word å­—ç¬¦ä¸²ç¼–ç é«˜é¢‘å­—ç¬¦å’Œè¾ƒé•¿çš„ç å­—å­—ç¬¦ä¸²ç¼–ç ä½é¢‘å­—ç¬¦æ¥èŠ‚çœç©ºé—´ã€‚</mark>æ­¤å¤–ï¼ŒHuffman codeä½¿ç”¨ä¸“é—¨é’ˆå¯¹ç»™å®šå­—æ¯è¡¨ä¸Šçš„ä»»ä½•å­—ç¬¦ä¸²Xä¼˜åŒ–çš„å¯å˜é•¿åº¦ç¼–ç variable-length encodingã€‚è¿™ç§ä¼˜åŒ–åŸºäºå­—ç¬¦**é¢‘ç‡**çš„ä½¿ç”¨ï¼Œå¯¹äºæ¯ä¸ªå­—ç¬¦cï¼Œæœ‰ä¸€ä¸ªcåœ¨å­—ç¬¦ä¸²Xä¸­å‡ºç°æ¬¡æ•°çš„è®¡æ•°f(c)ã€‚

> The method for text compression explored in this section is the **Huffman code**. Standard encoding schemes, such as ASCII, use fixed-length binary strings to encode characters (with 7 or 8 bits in the traditional or extended ASCII systems, respectively). The Huffman code saves space over a fixed-length encoding by using short code-word strings to encode high-frequency characters and long code-word strings to encode low-frequency characters. Furthermore, the Huffman code uses a variable-length encoding specifically optimized for a given string X over any alphabet. The optimization is based on the use of character **frequencies**, where we have, for each character c, a count f(c) of the number of times c appears in the string X.

ä¸ºäº†ç¼–ç å­—ç¬¦ä¸²Xï¼Œå°†Xä¸­çš„æ¯ä¸ªå­—ç¬¦è½¬æ¢ä¸ºå¯å˜é•¿åº¦çš„ç å­—ï¼Œå¹¶æŒ‰é¡ºåºè¿æ¥æ‰€æœ‰è¿™äº›ç å­—ä»¥ç”ŸæˆXçš„ç¼–ç Yã€‚ä¸ºäº†é¿å…æ­§ä¹‰ï¼Œ<mark>åœ¨ç¼–ç ä¸­æ²¡æœ‰ä»»ä½•ç å­—æ˜¯å¦ä¸€ä¸ªç å­—çš„å‰ç¼€ã€‚è¿™æ ·çš„ç¼–ç è¢«ç§°ä¸º**å‰ç¼€ç¼–ç prefix code**ï¼Œå®ƒç®€åŒ–äº†å°†Yè§£ç å›Xçš„è¿‡ç¨‹</mark>ã€‚ï¼ˆå‚è§å›¾13.9ã€‚ï¼‰å³ä½¿æœ‰è¿™ä¸ªé™åˆ¶ï¼Œä½¿ç”¨å¯å˜é•¿åº¦å‰ç¼€ç æ‰€èƒ½è¾¾åˆ°çš„èŠ‚çœä¹Ÿæ˜¯éå¸¸æ˜¾è‘—çš„ï¼Œç‰¹åˆ«æ˜¯å¦‚æœå­—ç¬¦é¢‘ç‡å­˜åœ¨è¾ƒå¤§çš„å·®å¼‚æ—¶ï¼ˆå‡ ä¹æ¯ç§ä¹¦é¢è¯­è¨€çš„è‡ªç„¶è¯­è¨€æ–‡æœ¬éƒ½æ˜¯è¿™ç§æƒ…å†µï¼‰ã€‚

> To encode the string X, we convert each character in X to a variable-length code-word, and we concatenate all these code-words in order to produce the encoding Y for X. In order to avoid ambiguities, we insist that no code-word in our encoding be a prefix of another code-word in our encoding. Such a code is called a **prefix code**, and it simplifies the decoding of Y to retrieve X. (See Figure 13.9.) Even with this restriction, the savings produced by a variable-length prefix code can be significant, particularly if there is a wide variance in character frequencies (as is the case for natural language text in almost every written language).

ç”¨äºä¸ºXç”Ÿæˆæœ€ä¼˜å¯å˜é•¿åº¦å‰ç¼€ç çš„ Huffmanâ€™s algorithm åŸºäºæ„é€ è¡¨ç¤ºè¯¥ä»£ç çš„äºŒå‰æ ‘Tã€‚Tä¸­çš„æ¯æ¡è¾¹ä»£è¡¨ç å­—ä¸­çš„ä¸€ä½ï¼Œåˆ°å·¦å­©å­çš„è¾¹ä»£è¡¨â€œ0â€ï¼Œåˆ°å³å­©å­çš„è¾¹ä»£è¡¨â€œ1â€ã€‚æ¯ä¸ªå¶å­vä¸ç‰¹å®šå­—ç¬¦å…³è”ï¼Œè¯¥å­—ç¬¦çš„ç å­—ç”±ä»Tçš„æ ¹åˆ°vè·¯å¾„ä¸Šçš„è¾¹æ‰€å…³è”çš„æ¯”ç‰¹åºåˆ—å®šä¹‰ã€‚ï¼ˆå‚è§å›¾13.9ã€‚ï¼‰æ¯ä¸ªå¶å­véƒ½æœ‰ä¸€ä¸ªé¢‘ç‡f(v)ï¼Œå³ä¸vå…³è”çš„å­—ç¬¦åœ¨Xä¸­çš„é¢‘ç‡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬<mark>ç»™Tä¸­çš„æ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹vèµ‹äºˆä¸€ä¸ªé¢‘ç‡f(v)ï¼Œå®ƒæ˜¯ä»¥vä¸ºæ ¹çš„å­æ ‘ä¸­æ‰€æœ‰å¶å­çš„é¢‘ç‡ä¹‹å’Œã€‚</mark>

> Huffmanâ€™s algorithm for producing an optimal variable-length prefix code for X is based on the construction of a binary tree T that represents the code. Each edge in T represents a bit in a code-word, with an edge to a left child representing a â€œ0â€ and an edge to a right child representing a â€œ1.â€ Each leaf v is associated with a specific character, and the code-word for that character is defined by the sequence of bits associated with the edges in the path from the root of T to v. (See Figure 13.9.) Each leaf v has a frequency, f(v), which is simply the frequency in X of the character associated with v. In addition, we give each internal node v in T a frequency, f(v), that is the sum of the frequencies of all the leaves in the subtree rooted at v.

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240309111247017.png" alt="image-20240309111247017" style="zoom: 50%;" />



å›¾13.9ï¼šè¾“å…¥å­—ç¬¦ä¸²X = "a fast runner need never be afraid of the dark" çš„ä¸€ä¸ªHuffman codeç¤ºä¾‹è¯´æ˜ï¼š(a) Xä¸­æ¯ä¸ªå­—ç¬¦çš„é¢‘ç‡ï¼›(b) å­—ç¬¦ä¸²Xçš„éœå¤«æ›¼æ ‘Tã€‚å­—ç¬¦cçš„ç¼–ç æ˜¯é€šè¿‡ä»Tçš„æ ¹èŠ‚ç‚¹è¿½è¸ªåˆ°å­˜å‚¨cçš„å¶å­èŠ‚ç‚¹çš„è·¯å¾„è·å¾—çš„ï¼Œå…¶ä¸­å·¦å­©å­è¾¹ç”¨0è¡¨ç¤ºï¼Œå³å­©å­è¾¹ç”¨1è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦â€œrâ€çš„ç¼–ç æ˜¯011ï¼Œè€Œå­—ç¬¦â€œhâ€çš„ç¼–ç æ˜¯10111ã€‚

> Figure 13.9: An illustration of an example Huffman code for the input string X = "a fast runner need never be afraid of the dark": (a) frequency of each character of X; (b) Huffman tree T for string X. The code for a character c is obtained by tracing the path from the root of T to the leaf where c is stored, and associating a left child with 0 and a right child with 1. For example, the code for â€œrâ€ is 011, and the code for â€œhâ€ is 10111.



#### 4.3.1 The Huffman Coding Algorithm

éœå¤«æ›¼ç¼–ç ç®—æ³•ä»å­—ç¬¦ä¸²Xä¸­æ¯ä¸ªç‹¬ç‰¹çš„dä¸ªå­—ç¬¦å¼€å§‹ï¼Œæ¯ä¸ªå­—ç¬¦éƒ½æ˜¯å•èŠ‚ç‚¹äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ç®—æ³•ä»¥ä¸€ç³»åˆ—çš„è½®æ¬¡è¿›è¡Œã€‚åœ¨æ¯ä¸€è½®ä¸­ï¼Œç®—æ³•å°†å…·æœ‰æœ€å°é¢‘ç‡çš„ä¸¤æ£µäºŒå‰æ ‘åˆå¹¶ä¸ºä¸€æ£µäºŒå‰æ ‘ã€‚æ­¤è¿‡ç¨‹é‡å¤è¿›è¡Œï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€æ£µæ ‘ä¸ºæ­¢ã€‚

éœå¤«æ›¼ç®—æ³•ä¸­**while**å¾ªç¯çš„æ¯æ¬¡è¿­ä»£å¯ä»¥ä½¿ç”¨å †è¡¨ç¤ºçš„ä¼˜å…ˆé˜Ÿåˆ—åœ¨O(logd)æ—¶é—´å†…å®ç°ã€‚æ­¤å¤–ï¼Œæ¯æ¬¡è¿­ä»£ä»Qä¸­å–å‡ºä¸¤ä¸ªèŠ‚ç‚¹å¹¶æ·»åŠ ä¸€ä¸ªæ–°èŠ‚ç‚¹è¿›å»ï¼Œè¿™ä¸ªè¿‡ç¨‹å°†åœ¨Qä¸­ä»…å‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¹‹å‰é‡å¤d âˆ’ 1æ¬¡ã€‚å› æ­¤ï¼Œè¯¥ç®—æ³•çš„è¿è¡Œæ—¶é—´ä¸ºO(n+ d logd)ã€‚è™½ç„¶åœ¨æ­¤æˆ‘ä»¬æ— æ³•å®Œæ•´åœ°è¯æ˜è¯¥ç®—æ³•çš„æ­£ç¡®æ€§ï¼Œä½†å…¶ç›´è§‰æ¥æºäºä¸€ä¸ªç®€å•çš„æƒ³æ³•â€”â€”ä»»ä½•æœ€ä¼˜ç¼–ç éƒ½å¯ä»¥è½¬æ¢æˆä¸€ä¸ªæœ€ä¼˜ç¼–ç ï¼Œåœ¨è¿™ä¸ªç¼–ç ä¸­ï¼Œé¢‘ç‡æœ€ä½çš„ä¸¤ä¸ªå­—ç¬¦aå’Œbçš„ç å­—åªåœ¨æœ€åä¸€ä¸ªæ¯”ç‰¹ä½ä¸Šæœ‰æ‰€ä¸åŒã€‚å¯¹äºç”¨å­—ç¬¦cæ›¿æ¢aå’Œbåçš„å­—ç¬¦ä¸²é‡å¤è¿™ä¸€è®ºè¯ï¼Œå¾—åˆ°å¦‚ä¸‹ç»“è®ºï¼š

**å‘½é¢˜**ï¼šéœå¤«æ›¼ç®—æ³•åœ¨$O(n+d logd)$æ—¶é—´å†…ä¸ºé•¿åº¦ä¸ºnä¸”åŒ…å«dä¸ªä¸åŒå­—ç¬¦çš„å­—ç¬¦ä¸²æ„é€ äº†ä¸€ä¸ªæœ€ä¼˜å‰ç¼€ç ã€‚

> The Huffman coding algorithm begins with each of the d distinct characters of the string X to encode being the root node of a single-node binary tree. The algorithm proceeds in a series of rounds. In each round, the algorithm takes the two binary
> trees with the smallest frequencies and merges them into a single binary tree. It repeats this process until only one tree is left. 
>
> Each iteration of the **while** loop in Huffmanâ€™s algorithm can be implemented in O(logd) time using a priority queue represented with a heap. In addition, each iteration takes two nodes out of Q and adds one in, a process that will be repeated d âˆ’ 1 times before exactly one node is left in Q. Thus, this algorithm runs in O(n+ d logd) time. Although a full justification of this algorithmâ€™s correctness is beyond our scope here, we note that its intuition comes from a simple ideaâ€”any
> optimal code can be converted into an optimal code in which the code-words for the two lowest-frequency characters, a and b, differ only in their last bit. Repeating the argument for a string with a and b replaced by a character c, gives the following:
>
> **Proposition** : Huffmanâ€™s algorithm constructs an optimal prefix code for a string of length n with d distinct characters in $O(n+d logd)$â€‹ time.



#### 4.3.2 The Greedy Method

éœå¤«æ›¼ç®—æ³•ç”¨äºæ„å»ºæœ€ä¼˜ç¼–ç æ˜¯è¢«ç§°ä¸º<mark>**è´ªå¿ƒæ³•**çš„ä¸€ç§ç®—æ³•è®¾è®¡æ¨¡å¼çš„åº”ç”¨ç¤ºä¾‹ã€‚è¿™ç§è®¾è®¡æ¨¡å¼è¢«åº”ç”¨äºä¼˜åŒ–é—®é¢˜ï¼Œå…¶ä¸­æˆ‘ä»¬è¯•å›¾åœ¨æ„å»ºæŸç§ç»“æ„çš„åŒæ—¶æœ€å°åŒ–æˆ–æœ€å¤§åŒ–è¯¥ç»“æ„çš„æŸäº›å±æ€§ã€‚</mark>

è´ªå¿ƒæ³•æ¨¡å¼çš„é€šç”¨å…¬å¼å‡ ä¹ä¸è›®åŠ›æ³•ä¸€æ ·ç®€å•ã€‚ä¸ºäº†ä½¿ç”¨è´ªå¿ƒæ³•è§£å†³ç»™å®šçš„ä¼˜åŒ–é—®é¢˜ï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ç³»åˆ—é€‰æ‹©æ¥æ¨è¿›ã€‚è¿™ä¸ªåºåˆ—ä»æŸä¸ªæ˜“äºç†è§£çš„åˆå§‹æ¡ä»¶å¼€å§‹ï¼Œå¹¶è®¡ç®—è¯¥åˆå§‹æ¡ä»¶çš„æˆæœ¬ã€‚ç„¶åï¼Œè¯¥æ¨¡å¼è¦æ±‚æˆ‘ä»¬é€šè¿‡è¯†åˆ«å½“å‰æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©ä¸­èƒ½å¤Ÿå¸¦æ¥æœ€ä½³æˆæœ¬æ”¹è¿›çš„å†³ç­–ï¼Œè¿­ä»£åœ°åšå‡ºé¢å¤–çš„é€‰æ‹©ã€‚è¿™ç§æ–¹æ³•å¹¶ä¸æ€»æ˜¯èƒ½å¯¼è‡´æœ€ä¼˜è§£ã€‚

ä½†ç¡®å®æœ‰ä¸€äº›é—®é¢˜æ˜¯é€‚ç”¨çš„ï¼Œè¿™ç±»é—®é¢˜è¢«ç§°ä¸ºå…·æœ‰**è´ªå¿ƒé€‰æ‹©æ€§è´¨**ã€‚è¿™ç§æ€§è´¨æ˜¯æŒ‡ï¼Œå¯ä»¥é€šè¿‡ä¸€ç³»åˆ—å±€éƒ¨æœ€ä¼˜é€‰æ‹©ï¼ˆå³æ¯æ¬¡é€‰æ‹©éƒ½æ˜¯åœ¨å½“æ—¶å¯ç”¨çš„å¯èƒ½æ€§ä¸­å½“å‰æœ€ä¼˜çš„ï¼‰ä»ä¸€ä¸ªå®šä¹‰æ˜ç¡®çš„åˆå§‹æ¡ä»¶å‡ºå‘ï¼Œè¾¾åˆ°å…¨å±€æœ€ä¼˜æ¡ä»¶ã€‚<mark>è®¡ç®—æœ€ä¼˜å¯å˜é•¿åº¦å‰ç¼€ç¼–ç çš„é—®é¢˜æ­£æ˜¯å…·æœ‰è´ªå¿ƒé€‰æ‹©æ€§è´¨çš„ä¸€ä¸ªä¾‹å­ã€‚</mark>

> Huffmanâ€™s algorithm for building an optimal encoding is an example application of an algorithmic design pattern called the greedy method. This design pattern is applied to optimization problems, where we are trying to construct some structure
> while minimizing or maximizing some property of that structure. 
>
> The general formula for the greedy method pattern is almost as simple as that for the brute-force method. In order to solve a given optimization problem using the greedy method, we proceed by a sequence of choices. The sequence starts from some well-understood starting condition, and computes the cost for that initial condition. The pattern then asks that we iteratively make additional choices by identifying the decision that achieves the best cost improvement from all of the choices that are currently possible. This approach does not always lead to an optimal solution.
>
> But there are several problems that it does work for, and such problems are said to possess the **greedy-choice** property. This is the property that a global optimal condition can be reached by a series of locally optimal choices (that is, choices that are each the current best from among the possibilities available at the time), starting from a well-defined starting condition. The problem of computing an optimal variable-length prefix code is just one example of a problem that possesses the greedy-choice property.
>



#### 4.3.3 å“ˆå¤«æ›¼ç¼–ç å®ç°

è¦æ„å»ºä¸€ä¸ªæœ€ä¼˜çš„å“ˆå¤«æ›¼ç¼–ç æ ‘ï¼Œé¦–å…ˆéœ€è¦å¯¹ç»™å®šçš„å­—ç¬¦åŠå…¶æƒå€¼è¿›è¡Œæ’åºã€‚ç„¶åï¼Œé€šè¿‡é‡å¤åˆå¹¶æƒå€¼æœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼ˆæˆ–å­æ ‘ï¼‰ï¼Œç›´åˆ°æ‰€æœ‰èŠ‚ç‚¹éƒ½åˆå¹¶ä¸ºä¸€æ£µæ ‘ä¸ºæ­¢ã€‚

ä¸‹é¢æ˜¯ç”¨ Python å®ç°çš„ä»£ç ï¼š

```python
import heapq

class Node:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.freq < other.freq

def huffman_encoding(char_freq):
    heap = [Node(char, freq) for char, freq in char_freq.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(None, left.freq + right.freq) # note: åˆå¹¶ä¹‹å char å­—å…¸æ˜¯ç©º
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)

    return heap[0]

def external_path_length(node, depth=0):
    if node is None:
        return 0
    if node.left is None and node.right is None:
        return depth * node.freq
    return (external_path_length(node.left, depth + 1) +
            external_path_length(node.right, depth + 1))

def main():
    char_freq = {'a': 3, 'b': 4, 'c': 5, 'd': 6, 'e': 8, 'f': 9, 'g': 11, 'h': 12}
    huffman_tree = huffman_encoding(char_freq)
    external_length = external_path_length(huffman_tree)
    print("The weighted external path length of the Huffman tree is:", external_length)

if __name__ == "__main__":
    main()

# Output:
# The weighted external path length of the Huffman tree is: 169 
```

è¿™æ®µä»£ç é¦–å…ˆå®šä¹‰äº†ä¸€ä¸ª `Node` ç±»æ¥è¡¨ç¤ºå“ˆå¤«æ›¼æ ‘çš„èŠ‚ç‚¹ã€‚ç„¶åï¼Œä½¿ç”¨æœ€å°å †æ¥æ„å»ºå“ˆå¤«æ›¼æ ‘ï¼Œæ¯æ¬¡ä»å †ä¸­å–å‡ºä¸¤ä¸ªé¢‘ç‡æœ€å°çš„èŠ‚ç‚¹è¿›è¡Œåˆå¹¶ï¼Œç›´åˆ°å †ä¸­åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå³å“ˆå¤«æ›¼æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚æ¥ç€ï¼Œä½¿ç”¨é€’å½’æ–¹æ³•è®¡ç®—å“ˆå¤«æ›¼æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ï¼ˆweighted external path lengthï¼‰ã€‚æœ€åï¼Œè¾“å‡ºè®¡ç®—å¾—åˆ°çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ã€‚

ä½ å¯ä»¥è¿è¡Œè¿™æ®µä»£ç æ¥å¾—åˆ°è¯¥æœ€ä¼˜äºŒå‰ç¼–ç æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ã€‚



#### 4.3.4 ç¼–ç¨‹é¢˜ç›®

##### ç»ƒä¹ T22161: å“ˆå¤«æ›¼ç¼–ç æ ‘

http://cs101.openjudge.cn/practice/22161/

æ ¹æ®å­—ç¬¦ä½¿ç”¨é¢‘ç‡(æƒå€¼)ç”Ÿæˆä¸€æ£µå”¯ä¸€çš„å“ˆå¤«æ›¼ç¼–ç æ ‘ã€‚ç”Ÿæˆæ ‘æ—¶éœ€è¦éµå¾ªä»¥ä¸‹è§„åˆ™ä»¥ç¡®ä¿å”¯ä¸€æ€§ï¼š

é€‰å–æœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹åˆå¹¶æ—¶ï¼ŒèŠ‚ç‚¹æ¯”å¤§å°çš„è§„åˆ™æ˜¯:

1) æƒå€¼å°çš„èŠ‚ç‚¹ç®—å°ã€‚æƒå€¼ç›¸åŒçš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå­—ç¬¦é›†é‡Œæœ€å°å­—ç¬¦å°çš„ï¼Œç®—å°ã€‚

ä¾‹å¦‚ ï¼ˆ{'c','k'},12) å’Œ ({'b','z'},12)ï¼Œåè€…å°ã€‚

2) åˆå¹¶ä¸¤ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå°çš„èŠ‚ç‚¹å¿…é¡»ä½œä¸ºå·¦å­èŠ‚ç‚¹
3) è¿æ¥å·¦å­èŠ‚ç‚¹çš„è¾¹ä»£è¡¨0,è¿æ¥å³å­èŠ‚ç‚¹çš„è¾¹ä»£è¡¨1

ç„¶åå¯¹è¾“å…¥çš„ä¸²è¿›è¡Œç¼–ç æˆ–è§£ç 

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°nï¼Œè¡¨ç¤ºå­—ç¬¦é›†æœ‰nä¸ªå­—ç¬¦ã€‚
æ¥ä¸‹æ¥nè¡Œï¼Œæ¯è¡Œæ˜¯ä¸€ä¸ªå­—ç¬¦åŠå…¶ä½¿ç”¨é¢‘ç‡ï¼ˆæƒé‡ï¼‰ã€‚å­—ç¬¦éƒ½æ˜¯è‹±æ–‡å­—æ¯ã€‚
å†æ¥ä¸‹æ¥æ˜¯è‹¥å¹²è¡Œï¼Œæœ‰çš„æ˜¯å­—æ¯ä¸²ï¼Œæœ‰çš„æ˜¯01ç¼–ç ä¸²ã€‚

**è¾“å‡º**

å¯¹è¾“å…¥ä¸­çš„å­—æ¯ä¸²ï¼Œè¾“å‡ºè¯¥å­—ç¬¦ä¸²çš„ç¼–ç 
å¯¹è¾“å…¥ä¸­çš„01ä¸²,å°†å…¶è§£ç ï¼Œè¾“å‡ºåŸå§‹å­—ç¬¦ä¸²

æ ·ä¾‹è¾“å…¥

```
3
g 4
d 8
c 10
dc
110
```

æ ·ä¾‹è¾“å‡º

```
110
dc
```

æç¤º: æ•°æ®è§„æ¨¡å¾ˆå°ï¼Œä¸ç”¨åœ¨ä¹æ•ˆç‡

æ¥æº: éƒ­ç‚œ



å»ºæ ‘ï¼šä¸»è¦åˆ©ç”¨æœ€å°å †ï¼Œæ¯æ¬¡å–å‡ºweightæœ€å°çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œweightç›¸åŠ ååˆ›å»ºèŠ‚ç‚¹ï¼Œè¿æ¥å·¦å³å­©å­ï¼Œå†å…¥å †ï¼Œç›´è‡³å †ä¸­åªå‰©ä¸€ä¸ªèŠ‚ç‚¹.

ç¼–ç ï¼šè·Ÿè¸ªæ¯ä¸€æ­¥èµ°çš„æ˜¯å·¦è¿˜æ˜¯å³ï¼Œç”¨0å’Œ1è¡¨ç¤ºï¼Œç›´è‡³é‡åˆ°æœ‰charå€¼çš„èŠ‚ç‚¹ï¼Œè¯´æ˜åˆ°äº†å¶å­èŠ‚ç‚¹ï¼Œå°†01å­—ä¸²æ·»åŠ è¿›å­—å…¸.

è§£ç ï¼šæ ¹æ®01å­—ä¸²å†³å®šèµ°å·¦è¿˜æ˜¯å³ï¼Œç›´è‡³é‡åˆ°æœ‰charå€¼çš„èŠ‚ç‚¹ï¼Œå°†charå€¼å–å‡º.

```python
import heapq

class Node:
    def __init__(self, weight, char=None):
        self.weight = weight
        self.char = char
        self.left = None
        self.right = None

    def __lt__(self, other):
        if self.weight == other.weight:
            return self.char < other.char
        return self.weight < other.weight

def build_huffman_tree(characters):
    heap = []
    for char, weight in characters.items():
        heapq.heappush(heap, Node(weight, char))

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        #merged = Node(left.weight + right.weight) #note: åˆå¹¶åï¼Œchar å­—æ®µé»˜è®¤å€¼æ˜¯ç©º
        merged = Node(left.weight + right.weight, min(left.char, right.char))
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)

    return heap[0]

def encode_huffman_tree(root):
    codes = {}

    def traverse(node, code):
        #if node.char:
        if node.left is None and node.right is None:
            codes[node.char] = code
        else:
            traverse(node.left, code + '0')
            traverse(node.right, code + '1')

    traverse(root, '')
    return codes

def huffman_encoding(codes, string):
    encoded = ''
    for char in string:
        encoded += codes[char]
    return encoded

def huffman_decoding(root, encoded_string):
    decoded = ''
    node = root
    for bit in encoded_string:
        if bit == '0':
            node = node.left
        else:
            node = node.right

        #if node.char:
        if node.left is None and node.right is None:
            decoded += node.char
            node = root
    return decoded

# è¯»å–è¾“å…¥
n = int(input())
characters = {}
for _ in range(n):
    char, weight = input().split()
    characters[char] = int(weight)

#string = input().strip()
#encoded_string = input().strip()

# æ„å»ºå“ˆå¤«æ›¼ç¼–ç æ ‘
huffman_tree = build_huffman_tree(characters)

# ç¼–ç å’Œè§£ç 
codes = encode_huffman_tree(huffman_tree)

strings = []
while True:
    try:
        line = input()
        strings.append(line)

    except EOFError:
        break

results = []
#print(strings)
for string in strings:
    if string[0] in ('0','1'):
        results.append(huffman_decoding(huffman_tree, string))
    else:
        results.append(huffman_encoding(codes, string))

for result in results:
    print(result)
```







#### 4.3.5 ç¬”è¯•é¢˜ç›®

**Q:** ç”¨ Huffman ç®—æ³•æ„é€ ä¸€ä¸ªæœ€ä¼˜äºŒå‰ç¼–ç æ ‘ï¼Œå¾…ç¼–ç çš„å­—ç¬¦æƒå€¼åˆ†åˆ«ä¸º{3ï¼Œ4ï¼Œ5ï¼Œ6ï¼Œ8ï¼Œ9ï¼Œ11ï¼Œ12}ï¼Œè¯·é—®è¯¥æœ€ä¼˜äºŒå‰ç¼–ç æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ä¸ºï¼ˆ B ï¼‰ã€‚ï¼ˆè¡¥å……è¯´æ˜ï¼š<mark>æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦å®šä¹‰ä¸ºæ ‘ä¸­æ‰€æœ‰å¶å­ç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¹‹å’Œï¼›å…¶ä¸­ï¼Œç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦å®šä¹‰ä¸ºè¯¥ç»“ç‚¹åˆ°æ ‘æ ¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ä¸è¯¥ç»“ç‚¹æƒå€¼çš„ä¹˜ç§¯</mark>ï¼‰
Aï¼š58	Bï¼š169	Cï¼š72	Dï¼š18



è§£é‡Šï¼šä¸ºäº†æ„é€ å“ˆå¤«æ›¼æ ‘ï¼Œæˆ‘ä»¬éµå¾ªä¸€ä¸ªé‡å¤çš„é€‰æ‹©è¿‡ç¨‹ï¼Œæ¯æ¬¡é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œç›´åˆ°åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ­¢ã€‚æˆ‘ä»¬å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š

1. å°†ç»™å®šçš„æƒå€¼æ’åºï¼š{3, 4, 5, 6, 8, 9, 11, 12}ã€‚

2. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š3 å’Œ 4ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 7 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{5, 6, 7, 8, 9, 11, 12}ã€‚

3. å†æ¬¡é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š5 å’Œ 6ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 11 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{7, 8, 9, 11, 11, 12}ã€‚

4. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š7 å’Œ 8ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 15 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{9, 11, 11, 12, 15}ã€‚

5. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š9 å’Œ 11ï¼Œå°†å®ƒä»¬åˆå¹¶æˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 20 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{11, 12, 15, 20}ã€‚

6. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š11 å’Œ 12ï¼Œåˆå¹¶æˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 23 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{15, 20, 23}ã€‚

7. é€‰æ‹©ä¸¤ä¸ªæœ€å°çš„æƒå€¼ï¼š15 å’Œ 20ï¼Œåˆå¹¶æˆä¸€ä¸ªæ–°çš„æƒå€¼ä¸º 35 çš„èŠ‚ç‚¹ã€‚

   ç°åœ¨æƒå€¼å˜ä¸ºï¼š{23, 35}ã€‚

8. æœ€åï¼Œåˆå¹¶è¿™ä¸¤ä¸ªèŠ‚ç‚¹å¾—åˆ°æ ¹èŠ‚ç‚¹ï¼Œæƒå€¼ä¸º 23 + 35 = 58ã€‚

ç°åœ¨æˆ‘ä»¬å¯ä»¥è®¡ç®—å“ˆå¤«æ›¼æ ‘çš„å¸¦æƒå¤–éƒ¨è·¯å¾„é•¿åº¦ï¼ˆWPLï¼‰ã€‚

```
          (58)
        /      \
     (23)       (35)
     /  \       /   \
   (11)(12)  (20)    (15) 
             / \       / \
            (9)(11)   (7)(8)
                / \   / \  
               (5)(6)(3) (4)
```

ç°åœ¨è®©æˆ‘ä»¬è®¡ç®—æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ï¼š

- æƒå€¼ 3 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 3 * 4 = 12ã€‚
- æƒå€¼ 4 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 4 * 4 = 16ã€‚
- æƒå€¼ 5 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 5 * 4 = 20ã€‚
- æƒå€¼ 6 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 4ï¼ŒWPLéƒ¨åˆ†ä¸º 6 * 4 = 24ã€‚
- æƒå€¼ 9 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 3ï¼ŒWPLéƒ¨åˆ†ä¸º 9 * 3 = 27ã€‚
- æƒå€¼ 8 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 3ï¼ŒWPLéƒ¨åˆ†ä¸º 8 * 3 = 24ã€‚
- æƒå€¼ 11 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 2ï¼ŒWPLéƒ¨åˆ†ä¸º 11 * 2 = 22ã€‚
- æƒå€¼ 12 çš„èŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸º 2ï¼ŒWPLéƒ¨åˆ†ä¸º 12 * 2 = 24ã€‚

å°†æ‰€æœ‰éƒ¨åˆ†çš„ WPL ç›¸åŠ ï¼Œæˆ‘ä»¬å¾—åˆ°æ•´æ£µå“ˆå¤«æ›¼æ ‘çš„ WPLï¼š

WPL = 12 + 16 + 20 + 24 + 27 + 24 + 22 + 24 = 169



# ä¸‰ã€BinHeap, BST, AVL, Disjoint Set

## 5 åˆ©ç”¨äºŒå‰å †å®ç°ä¼˜å…ˆçº§é˜Ÿåˆ—

æˆ‘ä»¬å­¦ä¹ è¿‡é˜Ÿåˆ—è¿™ä¸€å…ˆè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ã€‚é˜Ÿåˆ—æœ‰ä¸€ä¸ªé‡è¦çš„å˜ä½“ï¼Œå«ä½œä¼˜å…ˆçº§é˜Ÿåˆ—ã€‚å’Œé˜Ÿåˆ—ä¸€æ ·ï¼Œä¼˜å…ˆçº§é˜Ÿåˆ—ä»å¤´éƒ¨ç§»é™¤å…ƒç´ ï¼Œä¸è¿‡å…ƒç´ çš„é€»è¾‘é¡ºåºæ˜¯ç”±ä¼˜å…ˆçº§å†³å®šçš„ã€‚ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ åœ¨æœ€å‰ï¼Œä¼˜å…ˆçº§æœ€ä½çš„å…ƒç´ åœ¨æœ€åã€‚å› æ­¤ï¼Œå½“ä¸€ä¸ªå…ƒç´ å…¥é˜Ÿæ—¶ï¼Œå®ƒå¯èƒ½ç›´æ¥è¢«ç§»åˆ°ä¼˜å…ˆçº§é˜Ÿåˆ—çš„å¤´éƒ¨ã€‚åç»­å­¦ä¹ å›¾ç›¸å…³å†…å®¹æ—¶ä¼šçœ‹åˆ°ï¼Œ<mark>å¯¹äºä¸€äº›å›¾ç®—æ³•æ¥è¯´ï¼Œä¼˜å…ˆçº§é˜Ÿåˆ—æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æ•°æ®ç»“æ„</mark>ã€‚

ä½ æˆ–è®¸å¯ä»¥æƒ³åˆ°ä¸€äº›ä½¿ç”¨æ’åºå‡½æ•°å’Œåˆ—è¡¨å®ç°ä¼˜å…ˆçº§é˜Ÿåˆ—çš„ç®€å•æ–¹æ³•ã€‚ä½†æ˜¯ï¼Œå°±æ—¶é—´å¤æ‚åº¦è€Œè¨€ï¼Œåˆ—è¡¨çš„æ’å…¥æ“ä½œæ˜¯ O(n) ï¼Œæ’åºæ“ä½œæ˜¯ $O(n\log n)$ ã€‚å…¶å®ï¼Œæ•ˆç‡å¯ä»¥æ›´é«˜ã€‚å®ç°ä¼˜å…ˆçº§é˜Ÿåˆ—çš„ç»å…¸æ–¹æ³•æ˜¯ä½¿ç”¨å«ä½œäºŒå‰å †çš„æ•°æ®ç»“æ„ã€‚äºŒå‰å †çš„å…¥é˜Ÿæ“ä½œå’Œå‡ºé˜Ÿæ“ä½œå‡å¯è¾¾åˆ° $O(\log n) $ã€‚

äºŒå‰å †å­¦èµ·æ¥å¾ˆæœ‰æ„æ€ï¼Œå®ƒç”»å‡ºæ¥å¾ˆåƒä¸€æ£µæ ‘ï¼Œä½†å®ç°æ—¶åªç”¨ä¸€ä¸ªåˆ—è¡¨ä½œä¸ºå†…éƒ¨è¡¨ç¤ºã€‚æˆ‘ä»¬å°†å®ç°æœ€å°å †ï¼ˆæœ€å°çš„å…ƒç´ ä¸€ç›´åœ¨é˜Ÿé¦–ï¼‰ã€‚

### 5.1 äºŒå‰å †çš„å®ç°

1. ç»“æ„æ€§

ä¸ºäº†ä½¿äºŒå‰å †èƒ½é«˜æ•ˆåœ°å·¥ä½œï¼Œæˆ‘ä»¬åˆ©ç”¨æ ‘çš„å¯¹æ•°æ€§è´¨æ¥è¡¨ç¤ºå®ƒã€‚ä¸ºäº†ä¿è¯å¯¹æ•°æ€§èƒ½ï¼Œå¿…é¡»ç»´æŒæ ‘çš„å¹³è¡¡ã€‚å¹³è¡¡çš„äºŒå‰æ ‘æ˜¯æŒ‡ï¼Œå…¶æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘å«æœ‰æ•°é‡å¤§è‡´ç›¸ç­‰çš„èŠ‚ç‚¹ã€‚åœ¨å®ç°äºŒå‰å †æ—¶ï¼Œæˆ‘ä»¬é€šè¿‡åˆ›å»ºä¸€æ£µ**å®Œå…¨äºŒå‰æ ‘complete binary tree**æ¥ç»´æŒæ ‘çš„å¹³è¡¡ã€‚<mark>åœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚ï¼Œå…¶ä»–æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½æ˜¯æ»¡çš„ã€‚</mark>åœ¨æœ€åº•å±‚ï¼Œæˆ‘ä»¬ä»å·¦å¾€å³å¡«å……èŠ‚ç‚¹ã€‚å›¾ 1 å±•ç¤ºäº†å®Œå…¨äºŒå‰æ ‘çš„ä¸€ä¸ªä¾‹å­ã€‚

![image](https://raw.githubusercontent.com/GMyhf/img/main/img/compTree.png)

<center>å›¾ 1 å®Œå…¨äºŒå‰æ ‘</center>



å®Œå…¨äºŒå‰æ ‘çš„å¦ä¸€ä¸ªæœ‰è¶£ä¹‹å¤„åœ¨äºï¼Œ<u>å¯ä»¥ç”¨ä¸€ä¸ªåˆ—è¡¨æ¥è¡¨ç¤ºå®ƒ</u>ï¼Œè€Œä¸éœ€è¦é‡‡ç”¨â€œåˆ—è¡¨ä¹‹åˆ—è¡¨â€æˆ–â€œèŠ‚ç‚¹ä¸å¼•ç”¨â€è¡¨ç¤ºæ³•ã€‚ç”±äºæ ‘æ˜¯å®Œå…¨çš„ï¼Œå› æ­¤å¯¹äºåœ¨åˆ—è¡¨ä¸­å¤„äºä½ç½® p çš„èŠ‚ç‚¹æ¥è¯´ï¼Œå®ƒçš„å·¦å­èŠ‚ç‚¹æ­£å¥½å¤„äºä½ç½® 2pï¼›åŒç†ï¼Œå³å­èŠ‚ç‚¹å¤„äºä½ç½® 2p+1ã€‚è‹¥è¦æ‰¾åˆ°æ ‘ä¸­ä»»æ„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œåªéœ€ä½¿ç”¨ Python çš„æ•´æ•°é™¤æ³•å³å¯ã€‚ç»™å®šåˆ—è¡¨ä¸­ä½ç½® n å¤„çš„èŠ‚ç‚¹ï¼Œå…¶çˆ¶èŠ‚ç‚¹çš„ä½ç½®å°±æ˜¯ n/2ã€‚å›¾ 2 å±•ç¤ºäº†ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œå¹¶ç»™å‡ºäº†åˆ—è¡¨è¡¨ç¤ºã€‚æ ‘çš„åˆ—è¡¨è¡¨ç¤ºâ€”â€”åŠ ä¸Šè¿™ä¸ªâ€œå®Œå…¨â€çš„ç»“æ„æ€§è´¨â€”â€”è®©æˆ‘ä»¬å¾—ä»¥é€šè¿‡ä¸€äº›ç®€å•çš„æ•°å­¦è¿ç®—éå†å®Œå…¨äºŒå‰æ ‘ã€‚æˆ‘ä»¬ä¼šçœ‹åˆ°ï¼Œè¿™ä¹Ÿæœ‰åŠ©äºé«˜æ•ˆåœ°å®ç°äºŒå‰å †ã€‚

![image](https://raw.githubusercontent.com/GMyhf/img/main/img/heapOrder.png)

<center>å›¾ 2 ä¸€æ£µå®Œå…¨äºŒå‰æ ‘åŠå…¶åˆ—è¡¨è¡¨ç¤º</center>



2. å †çš„æœ‰åºæ€§

æˆ‘ä»¬ç”¨æ¥å­˜å‚¨å †å…ƒç´ çš„æ–¹æ³•ä¾èµ–äºå †çš„æœ‰åºæ€§ã€‚ <mark>å †çš„æœ‰åºæ€§æ˜¯æŒ‡ï¼šå¯¹äºå †ä¸­ä»»æ„å…ƒç´  x åŠå…¶çˆ¶å…ƒç´  pï¼Œ p éƒ½ä¸å¤§äº xã€‚</mark>å›¾ 6-15 ä¹Ÿå±•ç¤ºå‡ºå®Œå…¨äºŒå‰æ ‘å…·å¤‡å †çš„æœ‰åºæ€§ã€‚

3. å †æ“ä½œ

é¦–å…ˆå®ç°äºŒå‰å †çš„æ„é€ æ–¹æ³•ã€‚æ—¢ç„¶ç”¨ä¸€ä¸ªåˆ—è¡¨å°±å¯ä»¥è¡¨ç¤ºæ•´ä¸ªäºŒå‰å †ï¼Œé‚£ä¹ˆæ„é€ æ–¹æ³•è¦åšçš„å°±æ˜¯åˆå§‹åŒ–è¿™ä¸ªåˆ—è¡¨ä¸å±æ€§ currentSizeï¼Œç”¨äºè®°å½•å †çš„å½“å‰å¤§å°ã€‚ä»£ç æ¸…å• 6-17 ç»™å‡ºäº†æ„é€ æ–¹æ³•çš„ Python ä»£ç ã€‚åˆ—è¡¨ heapList çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ 0ï¼Œå®ƒçš„å”¯ä¸€ç”¨é€”æ˜¯ä¸ºäº†ä½¿åç»­çš„æ–¹æ³•å¯ä»¥ä½¿ç”¨æ•´æ•°é™¤æ³•ã€‚

```python
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0
```

æ¥ä¸‹æ¥å®ç°insertæ–¹æ³•ã€‚å°†å…ƒç´ åŠ å…¥åˆ—è¡¨çš„æœ€ç®€å•ã€æœ€é«˜æ•ˆçš„æ–¹æ³•å°±æ˜¯å°†å…ƒç´ è¿½åŠ åˆ°åˆ—è¡¨çš„æœ«å°¾ã€‚è¿½åŠ æ“ä½œçš„ä¼˜ç‚¹åœ¨äºï¼Œå®ƒèƒ½ä¿è¯å®Œå…¨æ ‘çš„æ€§è´¨ï¼Œä½†ç¼ºç‚¹æ˜¯å¾ˆå¯èƒ½ä¼šç ´åå †çš„ç»“æ„æ€§è´¨ã€‚ä¸è¿‡å¯ä»¥å†™ä¸€ä¸ªæ–¹æ³•ï¼Œé€šè¿‡æ¯”è¾ƒæ–°å…ƒç´ ä¸å…¶çˆ¶å…ƒç´ æ¥é‡æ–°è·å¾—å †çš„ç»“æ„æ€§è´¨ã€‚å¦‚æœæ–°å…ƒç´ å°äºå…¶çˆ¶å…ƒç´ ï¼Œå°±å°†äºŒè€…äº¤æ¢ã€‚å›¾3å±•ç¤ºäº†å°†æ–°å…ƒç´ æ”¾åˆ°æ­£ç¡®ä½ç½®ä¸Šæ‰€éœ€çš„ä¸€ç³»åˆ—äº¤æ¢æ“ä½œã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/percUp.png" alt="image" style="zoom:67%;" />

<center>å›¾3 å°†æ–°å…ƒç´ å¾€ä¸Šç§»åˆ°æ­£ç¡®ä½ç½® Percolate the New Node up to Its Proper Position</center>

æ³¨æ„ï¼Œå°†å…ƒç´ å¾€ä¸Šç§»æ—¶ï¼Œå…¶å®æ˜¯åœ¨æ–°å…ƒç´ åŠå…¶çˆ¶å…ƒç´ ä¹‹é—´é‡å»ºå †çš„ç»“æ„æ€§è´¨ã€‚æ­¤å¤–ï¼Œä¹Ÿä¿ç•™äº†å…„å¼Ÿå…ƒç´ ä¹‹é—´çš„å †æ€§è´¨ã€‚å½“ç„¶ï¼Œå¦‚æœæ–°å…ƒç´ å¾ˆå°ï¼Œéœ€è¦ç»§ç»­å¾€ä¸Šä¸€å±‚äº¤æ¢ã€‚ä»£ç æ¸…å•6-18ç»™å‡ºäº†percUpæ–¹æ³•çš„ä»£ç ï¼Œè¯¥æ–¹æ³•å°†å…ƒç´ ä¸€ç›´æ²¿ç€æ ‘å‘ä¸Šç§»åŠ¨ï¼Œç›´åˆ°é‡è·å †çš„ç»“æ„æ€§è´¨ã€‚æ­¤æ—¶ï¼ŒheapListä¸­çš„å…ƒç´ 0æ­£å¥½èƒ½å‘æŒ¥é‡è¦ä½œç”¨ã€‚æˆ‘ä»¬ä½¿ç”¨æ•´æ•°é™¤æ³•è®¡ç®—ä»»æ„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚å°±å½“å‰èŠ‚ç‚¹è€Œè¨€ï¼Œçˆ¶èŠ‚ç‚¹çš„ä¸‹æ ‡å°±æ˜¯å½“å‰èŠ‚ç‚¹çš„ä¸‹æ ‡é™¤ä»¥2ã€‚

ä»£ç æ¸…å•6-18 percUpæ–¹æ³•

```python
def percUp(self,i):
    while i // 2 > 0:
      if self.heapList[i] < self.heapList[i // 2]:
         tmp = self.heapList[i // 2]
         self.heapList[i // 2] = self.heapList[i]
         self.heapList[i] = tmp
      i = i // 2
```

ç°åœ¨å‡†å¤‡å¥½ç¼–å†™insertæ–¹æ³•äº†ã€‚ä»£ç æ¸…å•6-19ç»™å‡ºäº†è¯¥æ–¹æ³•çš„Pythonä»£ç ã€‚å…¶å®ï¼Œinsertæ–¹æ³•çš„å¤§éƒ¨åˆ†å·¥ä½œæ˜¯ç”±percUpæ–¹æ³•å®Œæˆçš„ã€‚å½“å…ƒç´ è¢«è¿½åŠ åˆ°æ ‘ä¸­ä¹‹åï¼ŒpercUpæ–¹æ³•å°†å…¶ç§»åˆ°æ­£ç¡®çš„ä½ç½®ã€‚

ä»£ç æ¸…å•6-19 å‘äºŒå‰å †ä¸­æ–°åŠ å…ƒç´ 

```python
def insert(self,k):
    self.heapList.append(k)
    self.currentSize = self.currentSize + 1
    self.percUp(self.currentSize)
```

æ­£ç¡®å®šä¹‰insertæ–¹æ³•åï¼Œå°±å¯ä»¥ç¼–å†™delMinæ–¹æ³•ã€‚æ—¢ç„¶å †çš„æœ‰åºæ€§è´¨è¦æ±‚æ ¹èŠ‚ç‚¹æ˜¯æ ‘çš„æœ€å°å…ƒç´ ï¼Œé‚£ä¹ˆæŸ¥æ‰¾æœ€å°å€¼å°±å¾ˆç®€å•ã€‚delMinæ–¹æ³•çš„éš¾ç‚¹åœ¨äºï¼Œå¦‚ä½•åœ¨ç§»é™¤æ ¹èŠ‚ç‚¹ä¹‹åé‡è·å †çš„ç»“æ„æ€§è´¨å’Œæœ‰åºæ€§ã€‚<mark>å¯ä»¥åˆ†ä¸¤æ­¥é‡å»ºå †ã€‚ç¬¬ä¸€æ­¥ï¼Œå–å‡ºåˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå°†å…¶ç§»åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®ã€‚ç§»åŠ¨æœ€åä¸€ä¸ªå…ƒç´ ä¿è¯äº†å †çš„ç»“æ„æ€§è´¨ï¼Œä½†å¯èƒ½ä¼šç ´åäºŒå‰å †çš„æœ‰åºæ€§ã€‚ç¬¬äºŒæ­¥ï¼Œå°†æ–°çš„æ ¹èŠ‚ç‚¹æ²¿ç€æ ‘æ¨åˆ°æ­£ç¡®çš„ä½ç½®ï¼Œä»¥é‡è·å †çš„æœ‰åºæ€§ã€‚å›¾4å±•ç¤ºäº†å°†æ–°çš„æ ¹èŠ‚ç‚¹ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®æ‰€éœ€çš„ä¸€ç³»åˆ—äº¤æ¢æ“ä½œã€‚</mark>

> äºŒå‰å †BinHeapï¼Œæ˜æ˜¾å¯ä»¥æ’åºHeapsortï¼Œæ ‘çš„ç‰¹ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸å½’å¹¶æ’åºMergesortä¸€è‡´ã€‚å–æœ€å°å…ƒç´ åï¼Œä¸ºäº†æ¢å¤æœ‰åºæ€§ï¼Œå †é¡¶ä¸åˆ—è¡¨æœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ï¼Œè¿™ç§è¿œè·ç¦»çš„äº¤æ¢ï¼Œè‡ªç„¶æ˜¯ ä¸ç¨³å®šNoStable çš„æ’åºã€‚
>
> 
>
> |    Name    |  Best   | Average |  Worst  | Memory | Stable |  Method   |                         Other notes                          |
> | :--------: | :-----: | :-----: | :-----: | :----: | :----: | :-------: | :----------------------------------------------------------: |
> |  Heapsort  | $nlogn$ | $nlogn$ | $nlogn$ |   1    |   No   | Selection |                                                              |
> | Merge sort | $nlogn$ | $nlogn$ | $nlogn$ |  *n*   |  Yes   |  Merging  | Highly parallelizable (up to *O*(log *n*) using the Three Hungarian's Algorithm) |
>
> 



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/percDown.png" alt="image" style="zoom:67%;" />



å›¾4 Percolating the Root Node down the Tree



ä»£ç æ¸…å•6-20 percDownæ–¹æ³•å’ŒminChildæ–¹æ³•

```python
def percDown(self,i):
    while (i * 2) <= self.currentSize:
        mc = self.minChild(i)
        if self.heapList[i] > self.heapList[mc]:
            tmp = self.heapList[i]
            self.heapList[i] = self.heapList[mc]
            self.heapList[mc] = tmp
        i = mc

def minChild(self,i):
    if i * 2 + 1 > self.currentSize:
        return i * 2
    else:
        if self.heapList[i*2] < self.heapList[i*2+1]:
            return i * 2
        else:
            return i * 2 + 1
```



delMinæ–¹æ³•å¦‚ä»£ç æ¸…å•6-21æ‰€ç¤ºã€‚åŒæ ·ï¼Œä¸»è¦å·¥ä½œä¹Ÿç”±è¾…åŠ©å‡½æ•°å®Œæˆã€‚æœ¬ä¾‹ä¸­çš„è¾…åŠ©å‡½æ•°æ˜¯percDownã€‚

ä»£ç æ¸…å•6-21 ä»äºŒå‰å †ä¸­åˆ é™¤æœ€å°çš„å…ƒç´ 

```python
def delMin(self):
    retval = self.heapList[1]
    self.heapList[1] = self.heapList[self.currentSize]
    self.currentSize = self.currentSize - 1
    self.heapList.pop()
    self.percDown(1)
    return retval
```



å…³äºäºŒå‰å †ï¼Œè¿˜æœ‰æœ€åä¸€ç‚¹éœ€è¦è®¨è®ºã€‚æˆ‘ä»¬æ¥çœ‹çœ‹æ ¹æ®å…ƒç´ åˆ—è¡¨æ„å»ºæ•´ä¸ªå †çš„æ–¹æ³•ã€‚ç„¶è€Œï¼Œå¦‚æœä»å®Œæ•´çš„åˆ—è¡¨å¼€å§‹ï¼Œæ„å»ºæ•´ä¸ªå †åªéœ€O(n) ï¼Œhttps://oi-wiki.org/ds/binary-heap/ã€‚ä»£ç æ¸…å•6-22ç»™å‡ºäº†æ„å»ºæ•´ä¸ªå †çš„ä»£ç ã€‚

ä»£ç æ¸…å•6-22 æ ¹æ®å…ƒç´ åˆ—è¡¨æ„å»ºå †

```python
def buildHeap(self,alist):
    i = len(alist) // 2  # è¶…è¿‡ä¸­ç‚¹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹
    self.currentSize = len(alist)
    self.heapList = [0] + alist[:]
    while (i > 0):
        self.percDown(i)
        i = i - 1
```



å›¾5å±•ç¤ºäº†buildHeapæ–¹æ³•è¿›è¡Œçš„äº¤æ¢è¿‡ç¨‹ï¼Œå®ƒå°†å„èŠ‚ç‚¹ä»æœ€åˆçŠ¶æ€ç§»åˆ°å„è‡ªçš„æ­£ç¡®ä½ç½®ä¸Šã€‚å°½ç®¡ä»æ ‘çš„ä¸­é—´å¼€å§‹ï¼Œå‘æ ¹çš„æ–¹å‘æ“ä½œï¼Œä½†æ˜¯percDownæ–¹æ³•ä¿è¯äº†æœ€å¤§çš„èŠ‚ç‚¹æ€»æ˜¯æ²¿ç€æ ‘å‘ä¸‹ç§»åŠ¨ã€‚<u>åœ¨è¿™æ£µå®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œè¶…è¿‡ä¸­ç‚¹çš„èŠ‚ç‚¹éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œæ²¡æœ‰ä»»ä½•å­èŠ‚ç‚¹</u>ã€‚å½“i = 1æ—¶ï¼Œä»æ ‘çš„æ ¹èŠ‚ç‚¹å¾€ä¸‹ç§»ï¼Œå¯èƒ½éœ€è¦ç»è¿‡å¤šæ¬¡äº¤æ¢ã€‚å¦‚ä½ æ‰€è§ï¼Œ9å…ˆè¢«ç§»å‡ºæ ¹èŠ‚ç‚¹ï¼Œç„¶åpercDownä¼šæ²¿ç€æ ‘æ£€æŸ¥å­èŠ‚ç‚¹ï¼Œä»¥ç¡®ä¿å°½é‡å°†å®ƒå¾€ä¸‹ç§»ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œ9çš„ç¬¬2æ¬¡äº¤æ¢å¯¹è±¡æ˜¯3ã€‚è¿™æ ·ä¸€æ¥ï¼Œ9å°±ç§»åˆ°äº†æ ‘çš„åº•å±‚ï¼Œä¸éœ€è¦å†åšäº¤æ¢äº†ã€‚æ¯”è¾ƒä¸€ç³»åˆ—äº¤æ¢æ“ä½œåçš„åˆ—è¡¨è¡¨ç¤ºå°†æœ‰åŠ©äºç†è§£ï¼Œå¦‚å›¾5æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/buildheap.png" alt="image" style="zoom:67%;" />

<center>å›¾5 æ ¹æ®åˆ—è¡¨[9, 6, 5, 2, 3]æ„å»ºå †</center>



```python
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self, i):
        while i // 2 > 0:
            if self.heapList[i] < self.heapList[i // 2]:
                tmp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = tmp
            i = i // 2

    def insert(self, k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self, i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self, i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self, alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            print(f'i = {i}, {self.heapList}')
            self.percDown(i)
            i = i - 1
        print(f'i = {i}, {self.heapList}')



bh = BinHeap()
bh.buildHeap([9, 5, 6, 2, 3])
"""
i = 2, [0, 9, 5, 6, 2, 3]
i = 1, [0, 9, 2, 6, 5, 3]
i = 0, [0, 2, 3, 6, 5, 9]
"""

for _ in range(bh.currentSize):
    print(bh.delMin())
"""
2
3
5
6
9
"""
```



å‰é¢è¯´è¿‡ï¼Œ<mark>æ„å»ºå †çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n)</mark>ï¼Œè¿™ä¹ä¸€å¬å¯èƒ½å¾ˆéš¾ç†è§£ï¼Œè¯æ˜åœ¨ https://oi-wiki.org/ds/binary-heap/ ã€‚ä¸è¿‡ï¼Œè¦ç‚¹åœ¨äºï¼Œå› å­log næ˜¯ç”±æ ‘çš„é«˜åº¦å†³å®šçš„ã€‚åœ¨buildHeapçš„å¤§éƒ¨åˆ†å·¥ä½œä¸­ï¼Œæ ‘çš„é«˜åº¦ä¸è¶³log nã€‚



åˆ©ç”¨å»ºå †çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)è¿™ä¸€ç‚¹ï¼Œå¯ä»¥æ„é€ ä¸€ä¸ªä½¿ç”¨å †ä¸ºåˆ—è¡¨æ’åºçš„ç®—æ³•ï¼Œä½¿å®ƒçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n\log n)$ã€‚





### 5.2 ç¼–ç¨‹é¢˜ç›®

#### M04078: å®ç°å †ç»“æ„

http://cs101.openjudge.cn/practice/04078/

å®šä¹‰ä¸€ä¸ªæ•°ç»„ï¼Œåˆå§‹åŒ–ä¸ºç©ºã€‚åœ¨æ•°ç»„ä¸Šæ‰§è¡Œä¸¤ç§æ“ä½œï¼š

1ã€å¢æ·»1ä¸ªå…ƒç´ ï¼ŒæŠŠ1ä¸ªæ–°çš„å…ƒç´ æ”¾å…¥æ•°ç»„ã€‚

2ã€è¾“å‡ºå¹¶åˆ é™¤æ•°ç»„ä¸­æœ€å°çš„æ•°ã€‚

ä½¿ç”¨å †ç»“æ„å®ç°ä¸Šè¿°åŠŸèƒ½çš„é«˜æ•ˆç®—æ³•ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°nï¼Œä»£è¡¨æ“ä½œçš„æ¬¡æ•°ã€‚
æ¯æ¬¡æ“ä½œé¦–å…ˆè¾“å…¥ä¸€ä¸ªæ•´æ•°typeã€‚
å½“type=1ï¼Œå¢æ·»æ“ä½œï¼Œæ¥ç€è¾“å…¥ä¸€ä¸ªæ•´æ•°uï¼Œä»£è¡¨è¦æ’å…¥çš„å…ƒç´ ã€‚
å½“type=2ï¼Œè¾“å‡ºåˆ é™¤æ“ä½œï¼Œè¾“å‡ºå¹¶åˆ é™¤æ•°ç»„ä¸­æœ€å°çš„å…ƒç´ ã€‚
1<=n<=100000ã€‚

**è¾“å‡º**

æ¯æ¬¡åˆ é™¤æ“ä½œè¾“å‡ºè¢«åˆ é™¤çš„æ•°å­—ã€‚

æ ·ä¾‹è¾“å…¥

```
4
1 5
1 1
1 7
2
```

æ ·ä¾‹è¾“å‡º

```
1
```

æç¤º

æ¯ç»„æµ‹è¯•æ•°æ®çš„å¤æ‚åº¦ä¸ºO(nlogn)çš„ç®—æ³•æ‰èƒ½é€šè¿‡æœ¬æ¬¡ï¼Œå¦åˆ™ä¼šè¿”å›TLE(è¶…æ—¶)
éœ€è¦ä½¿ç”¨æœ€å°å †ç»“æ„æ¥å®ç°æœ¬é¢˜çš„ç®—æ³•



è¿™é¢˜ç›®æœ¬æ„æ˜¯ç»ƒä¹ è‡ªå·±å†™ä¸ªBinHeapã€‚å½“ç„¶æœºè€ƒæ—¶å€™ï¼Œå¦‚æœé‡åˆ°è¿™æ ·é¢˜ç›®ï¼Œç›´æ¥import heapqã€‚

æ‰‹æ“æ ˆã€é˜Ÿåˆ—ã€å †ã€AVLç­‰ï¼Œè€ƒè¯•å‰éœ€è¦æ“ä¸ªéã€‚

```python
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self, i):
        while i // 2 > 0:
            if self.heapList[i] < self.heapList[i // 2]:
                tmp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = tmp
            i = i // 2

    def insert(self, k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self, i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self, i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self, alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            #print(f'i = {i}, {self.heapList}')
            self.percDown(i)
            i = i - 1
        #print(f'i = {i}, {self.heapList}')


n = int(input().strip())
bh = BinHeap()
for _ in range(n):
    inp = input().strip()
    if inp[0] == '1':
        bh.insert(int(inp.split()[1]))
    else:
        print(bh.delMin())
```



#### æ™´é—®9.7: å‘ä¸‹è°ƒæ•´æ„å»ºå¤§é¡¶å †

https://sunnywhy.com/sfbj/9/7

ç°æœ‰ä¸ªä¸åŒçš„æ­£æ•´æ•°ï¼Œå°†å®ƒä»¬æŒ‰å±‚åºç”Ÿæˆå®Œå…¨äºŒå‰æ ‘ï¼Œç„¶åä½¿ç”¨**å‘ä¸‹è°ƒæ•´**çš„æ–¹å¼æ„å»ºä¸€ä¸ªå®Œæ•´çš„å¤§é¡¶å †ã€‚æœ€åæŒ‰å±‚åºè¾“å‡ºå †ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°$n (1 \le n \le 10^3)$ï¼Œè¡¨ç¤ºæ­£æ•´æ•°çš„ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œ n ä¸ªæ•´æ•°$a_i (1 \le a_i \le 10^4) $â€‹ï¼Œè¡¨ç¤ºæ­£æ•´æ•°åºåˆ—ã€‚

**è¾“å‡º**

è¾“å‡º n ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå †çš„å±‚åºåºåˆ—ï¼Œä¸­é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥

```
6
3 2 6 5 8 7
```

è¾“å‡º

```
8 5 7 3 2 6
```

è§£é‡Š

è°ƒæ•´å‰çš„å®Œå…¨äºŒå‰æ ‘å’Œè°ƒæ•´åçš„å †å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403210116556.png" alt="å‘ä¸‹è°ƒæ•´æ„å»ºå¤§é¡¶å †.png" style="zoom:67%;" />



```python
class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self, i):
        while i // 2 > 0:
            if self.heapList[i] < self.heapList[i // 2]:
                tmp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = tmp
            i = i // 2

    def insert(self, k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self, i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self, i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self, alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            #print(f'i = {i}, {self.heapList}')
            self.percDown(i)
            i = i - 1
        #print(f'i = {i}, {self.heapList}')


n = int(input().strip())
heap = list(map(int, input().strip().split())) # [9, 5, 6, 2, 3]
heap = [-x for x in heap]

bh = BinHeap()
bh.buildHeap(heap)
ans = [-x for x in bh.heapList[1:]]
print(*ans)
```





#### E18164: å‰ªç»³å­

greedy/huffman, http://cs101.openjudge.cn/practice/18164/

å°å¼ è¦å°†ä¸€æ ¹é•¿åº¦ä¸ºLçš„ç»³å­å‰ªæˆNæ®µã€‚å‡†å¤‡å‰ªçš„ç»³å­çš„é•¿åº¦ä¸ºL1,L2,L3...,LNï¼Œæœªå‰ªçš„ç»³å­é•¿åº¦æ°å¥½ä¸ºå‰ªåæ‰€æœ‰ç»³å­é•¿åº¦çš„å’Œã€‚ 

æ¯æ¬¡å‰ªæ–­ç»³å­æ—¶ï¼Œéœ€è¦çš„å¼€é”€æ˜¯æ­¤æ®µç»³å­çš„é•¿åº¦ã€‚

æ¯”å¦‚ï¼Œé•¿åº¦ä¸º10çš„ç»³å­è¦å‰ªæˆé•¿åº¦ä¸º2,3,5çš„ä¸‰æ®µç»³å­ã€‚é•¿åº¦ä¸º10çš„ç»³å­åˆ‡æˆ5å’Œ5çš„ä¸¤æ®µç»³å­æ—¶ï¼Œå¼€é”€ä¸º10ã€‚å†å°†5åˆ‡æˆé•¿åº¦ä¸º2å’Œ3çš„ç»³å­ï¼Œå¼€é”€ä¸º5ã€‚å› æ­¤æ€»å¼€é”€ä¸º15ã€‚


è¯·æŒ‰ç…§ç›®æ ‡è¦æ±‚å°†ç»³å­å‰ªå®Œæœ€å°çš„å¼€é”€æ—¶å¤šå°‘ã€‚

å·²çŸ¥ï¼Œ1<=N <= 20000ï¼Œ0<=Li<= 50000

**è¾“å…¥**

ç¬¬ä¸€è¡Œï¼šNï¼Œå°†ç»³å­å‰ªæˆçš„æ®µæ•°ã€‚
ç¬¬äºŒè¡Œï¼šå‡†å¤‡å‰ªæˆçš„å„æ®µç»³å­çš„é•¿åº¦ã€‚

**è¾“å‡º**

æœ€å°å¼€é”€

æ ·ä¾‹è¾“å…¥

```
3
2 3 5
```

æ ·ä¾‹è¾“å‡º

```
15
```

æ¥æºï¼šcs101-2017 æœŸæœ«æœºè€ƒå¤‡é€‰



ä¸ 05333: Fence Repair ä¸€æ ·ã€‚http://cs101.openjudge.cn/practice/05333

æ€è·¯ï¼š å‰ªç»³å­ï¼Œå®é™…ä¸Šæ˜¯ Huffmanç¼–ç /æ ‘ï¼Œhttps://zhuanlan.zhihu.com/p/42238580

```python
# OJ18164
import sys
try: fin = open('test.in','r').readline
except: fin = sys.stdin.readline

n = int(fin())
import heapq
a = list(map(int, fin().split()))
heapq.heapify(a)
ans = 0
for i in range(n-1):
    x = heapq.heappop(a)
    y = heapq.heappop(a)
    z = x + y
    heapq.heappush(a, z)
    ans += z
print(ans)
```





### 5.3 ç¬”è¯•é¢˜ç›®

**Q**: ä¸‹å›¾æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘:
1)è¯·æ ¹æ®åˆå§‹å»ºå †ç®—æ³•å¯¹è¯¥å®Œå…¨äºŒå‰æ ‘å»ºå †ï¼Œè¯·ç”»å‡ºæ„å»ºçš„å°æ ¹å †(2åˆ†);

2)åŸºäº(1)ä¸­å¾—åˆ°çš„å †ï¼Œåˆ é™¤å…¶ä¸­çš„æœ€å°å…ƒç´ ï¼Œè¯·ç”¨å›¾ç»™å‡ºå †çš„è°ƒæ•´è¿‡ç¨‹(2åˆ†);

3)åŸºäº(1)ä¸­å¾—åˆ°çš„å †ï¼Œå‘å…¶ä¸­æ’å…¥å…ƒç´ 2ï¼Œè¯·ç»™å‡ºå †çš„è°ƒæ•´è¿‡ç¨‹(2åˆ†)ã€‚

æ³¨:æ¯ç§»åŠ¨ä¸€ä¸ªå…ƒç´ è§†ä¸ºä¸€ä¸ªæ‰§è¡Œæ­¥éª¤ï¼Œç”»å‡ºæ‰€æœ‰æ‰§è¡Œæ­¥éª¤ã€‚



```
          (31)
        /      \
      (8)       (53)
     /   \      /  \
   (10)  (20)  (7) (15) 
   / \    / 
 (3)(20) (1)
```





è¯´æ˜ï¼šæ ¹æ®äºŒå‰å †çš„â€œå®Œå…¨äºŒå‰æ ‘â€ç»“æ„æ€§è´¨å»ºå †ã€‚ä»å®Œå…¨äºŒå‰æ ‘çš„æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œå‘ä¸Šéå†æ¯ä¸ªèŠ‚ç‚¹ã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œè¿›è¡Œä¸‹æ²‰æ“ä½œï¼Œå°†èŠ‚ç‚¹ä¸å…¶å­èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶äº¤æ¢ä½ç½®ç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚é‡å¤æ­¥éª¤ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ã€‚



GPT3.5:

1ï¼‰åˆå§‹å»ºå †ç®—æ³•çš„æ­¥éª¤å¦‚ä¸‹ï¼š

- ä»å®Œå…¨äºŒå‰æ ‘çš„æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œå‘ä¸Šéå†æ¯ä¸ªèŠ‚ç‚¹ã€‚
- å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œè¿›è¡Œä¸‹æ²‰æ“ä½œï¼Œå°†èŠ‚ç‚¹ä¸å…¶å­èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶äº¤æ¢ä½ç½®ç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚
- é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ã€‚



æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹æ˜¯(20)ã€‚ï¼ˆè¯·åŒå­¦éªŒè¯æ˜¯å¦æ­£ç¡®ï¼Ÿï¼‰

```
          (31)
        /      \
      (8)       (53)
     /   \      /  \
   (10)  (1)  (7) (15) 
   / \    / 
 (3)(20) (20)
```





```
          (31)
        /      \
      (8)       (53)
     /   \      /  \
   (3)    (1)  (7) (15) 
   / \    / 
 (10)(20) (20)
```





```
          (31)
        /      \
      (8)       (7)
     /    \      /  \
   (3)    (1)  (53) (15) 
   / \     / 
 (10)(20) (20)
```



```
          (31)
        /      \
      (1)       (7)
     /    \      /  \
   (3)    (8)  (53) (15) 
   / \     / 
 (10)(20) (20)
```





```
          (1)
        /      \
      (3)       (7)
     /    \      /  \
   (10)    (8)  (53) (15) 
   / \     / 
 (31)(20) (20)
```



2ï¼‰åˆ é™¤æœ€å°å…ƒç´ çš„å †è°ƒæ•´è¿‡ç¨‹ï¼š

- é¦–å…ˆï¼Œå°†æ ¹èŠ‚ç‚¹ä¸æœ€åä¸€ä¸ªå¶å­èŠ‚ç‚¹äº¤æ¢ä½ç½®ã€‚
- ç„¶åï¼Œå°†æ ¹èŠ‚ç‚¹è¿›è¡Œä¸‹æ²‰æ“ä½œï¼Œä¸å…¶å­èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒå¹¶äº¤æ¢ä½ç½®ï¼Œç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚



åˆ é™¤æœ€å°å…ƒç´ åï¼Œå°†æœ€åä¸€ä¸ªå…ƒç´ 20 ç§»åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åè¿›è¡Œå †çš„è°ƒæ•´ã€‚

```
          (20)
        /      \
      (3)       (7)
     /    \      /  \
   (10)    (8)  (53) (15) 
   / \     
 (31)(20) 
```

ç»§ç»­è°ƒæ•´å †ï¼š

```
          (3)
        /      \
      (8)       (7)
     /    \      /  \
   (10)    (20)  (53) (15) 
   / \     
 (31)(20) 
```





3ï¼‰æ’å…¥å…ƒç´ çš„å †è°ƒæ•´è¿‡ç¨‹ï¼š

- é¦–å…ˆï¼Œå°†æ–°å…ƒç´ æ’å…¥åˆ°å®Œå…¨äºŒå‰æ ‘çš„æœ€åä¸€ä¸ªä½ç½®ã€‚
- ç„¶åï¼Œå°†æ–°å…ƒç´ è¿›è¡Œä¸Šæµ®æ“ä½œï¼Œä¸å…¶çˆ¶èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒå¹¶äº¤æ¢ä½ç½®ï¼Œç›´åˆ°æ»¡è¶³å°æ ¹å †çš„æ€§è´¨ã€‚



é¦–å…ˆå°†å…ƒç´ 2æ’å…¥åˆ°å †çš„æœ«å°¾ï¼Œç„¶åå‘ä¸Šè°ƒæ•´å †ã€‚

```
          (1)
        /      \
      (3)       (7)
     /    \      /  \
   (10)    (8)  (53) (15) 
   / \     /  \
 (31)(20) (20) (2)
```

ç»§ç»­è°ƒæ•´å †ï¼š

```
          (1)
        /      \
      (2)       (7)
     /    \      /  \
   (10)    (3)  (53) (15) 
   / \     /  \
 (31)(20) (20) (8)
```



## 6 å †æ’åºç®—æ³•

**å †æ’åº**ï¼šåˆ©ç”¨æœ€å¤§å †çš„æ€§è´¨ï¼Œå°†åˆ—è¡¨ä»å°åˆ°å¤§æ’åºã€‚

```python
class Node:
    def __init__(self, key):
        self.key = key

# ç¡®ä¿ä»¥ç´¢å¼• i ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘æ»¡è¶³æœ€å¤§å †çš„æ€§è´¨ï¼ˆçˆ¶èŠ‚ç‚¹çš„å€¼å¤§äºç­‰äºå­èŠ‚ç‚¹çš„å€¼ï¼‰ã€‚
def adjust_heap(lst, i, size): 
    lchild = 2 * i + 1
    rchild = 2 * i + 2
    max = i
    if i < size // 2:
        if lchild < size and lst[lchild].key > lst[max].key:
            max = lchild
        if rchild < size and lst[rchild].key > lst[max].key:
            max = rchild
        if max != i:
            lst[max], lst[i] = lst[i], lst[max]
            adjust_heap(lst, max, size)


def build_heap(lst):
    size = len(lst)
    for i in range(0, (size // 2))[::-1]: # ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œé€ä¸ªå‘ä¸Šè°ƒæ•´ï¼Œä½¿æ•´ä¸ªåˆ—è¡¨æˆä¸ºä¸€ä¸ªæœ€å¤§å †ã€‚
        adjust_heap(lst, i, size)


def heap_sort(lst):
    size = len(lst)
    build_heap(lst)
    for i in range(0, size)[::-1]:
        lst[0], lst[i] = lst[i], lst[0]
        adjust_heap(lst, 0, i)


def print_list(lst):
    return [node.key for node in lst]


if __name__ == "__main__":
    lst = [Node(5), Node(9), Node(3), Node(8), Node(7)]
    # æ‰“å°æ’åºå‰çš„åˆ—è¡¨
    print("Before sorting:", print_list(lst))

    # è°ƒç”¨å †æ’åº
    heap_sort(lst)

    # æ‰“å°æ’åºåçš„åˆ—è¡¨
    print("After sorting:", print_list(lst))

"""
Before sorting: [5, 9, 3, 8, 7]
After sorting: [3, 5, 7, 8, 9]
"""
```

 **æ€»ç»“**

1. **æ—¶é—´å¤æ‚åº¦**ï¼š
   - æ„å»ºå †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€‚
   - æ¯æ¬¡è°ƒæ•´å †çš„æ—¶é—´å¤æ‚åº¦ä¸º O(logâ¡n)ï¼Œæ€»å…±éœ€è¦ n æ¬¡è°ƒæ•´ã€‚
   - å› æ­¤ï¼Œå †æ’åºçš„æ€»ä½“æ—¶é—´å¤æ‚åº¦ä¸º O(nlogâ¡n)ã€‚
2. **ç©ºé—´å¤æ‚åº¦**ï¼š
   - å †æ’åºæ˜¯åŸåœ°æ’åºç®—æ³•ï¼Œç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚
3. **ç¨³å®šæ€§**ï¼š
   - å †æ’åºæ˜¯ä¸€ç§**ä¸ç¨³å®šæ’åº**ï¼Œå› ä¸ºåœ¨äº¤æ¢å…ƒç´ æ—¶å¯èƒ½ä¼šæ”¹å˜ç›¸åŒå€¼å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚
4. **é€‚ç”¨åœºæ™¯**ï¼š
   - é€‚ç”¨äºéœ€è¦é«˜æ•ˆæ’åºä¸”å†…å­˜æœ‰é™çš„åœºæ™¯ï¼Œä¾‹å¦‚åµŒå…¥å¼ç³»ç»Ÿæˆ–å¤§è§„æ¨¡æ•°æ®æ’åºã€‚



## 7 äºŒå‰æœç´¢æ ‘

äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼ŒBSTï¼‰ï¼Œå®ƒæ˜¯æ˜ å°„çš„å¦ä¸€ç§å®ç°ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„ä¸æ˜¯å…ƒç´ åœ¨æ ‘ä¸­çš„ç¡®åˆ‡ä½ç½®ï¼Œè€Œæ˜¯<mark>å¦‚ä½•åˆ©ç”¨äºŒå‰æ ‘ç»“æ„æä¾›é«˜æ•ˆçš„æœç´¢ã€‚</mark>

äºŒå‰æœç´¢æ ‘ä¾èµ–äºè¿™æ ·ä¸€ä¸ªæ€§è´¨ï¼š<mark>å°äºçˆ¶èŠ‚ç‚¹çš„é”®éƒ½åœ¨å·¦å­æ ‘ä¸­ï¼Œå¤§äºçˆ¶èŠ‚ç‚¹çš„é”®åˆ™éƒ½åœ¨å³å­æ ‘ä¸­ã€‚æˆ‘ä»¬ç§°è¿™ä¸ªæ€§è´¨ä¸ºäºŒå‰æœç´¢æ€§ã€‚</mark>



### 7.1 ç¼–ç¨‹é¢˜ç›®

##### ç»ƒä¹ M22275: äºŒå‰æœç´¢æ ‘çš„éå†

http://cs101.openjudge.cn/practice/22275/

ç»™å‡ºä¸€æ£µäºŒå‰æœç´¢æ ‘çš„å‰åºéå†ï¼Œæ±‚å®ƒçš„ååºéå†

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•°nï¼ˆn<=2000ï¼‰è¡¨ç¤ºè¿™æ£µäºŒå‰æœç´¢æ ‘çš„ç»“ç‚¹ä¸ªæ•°
ç¬¬äºŒè¡Œnä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºè¿™æ£µäºŒå‰æœç´¢æ ‘çš„å‰åºéå†
ä¿è¯ç¬¬äºŒè¡Œçš„nä¸ªæ­£æ•´æ•°ä¸­ï¼Œ1~nçš„æ¯ä¸ªå€¼åˆšå¥½å‡ºç°ä¸€æ¬¡

**è¾“å‡º**

ä¸€è¡Œnä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºè¿™æ£µäºŒå‰æœç´¢æ ‘çš„ååºéå†

æ ·ä¾‹è¾“å…¥

```
5
4 2 1 3 5
```

æ ·ä¾‹è¾“å‡º

```
1 3 2 5 4
```

æç¤º

æ ‘çš„å½¢çŠ¶ä¸º
   4  
  / \ 
  2  5 
 / \  
 1  3  



```python
"""
ç‹æ˜Š å…‰åç®¡ç†å­¦é™¢ã€‚æ€è·¯ï¼š
å»ºæ ‘æ€è·¯ï¼šæ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹ï¼Œç´§è·Ÿç€æ˜¯å°äºæ ¹èŠ‚ç‚¹å€¼çš„èŠ‚ç‚¹ï¼Œåœ¨æ ¹èŠ‚ç‚¹å·¦ä¾§ï¼Œç›´è‡³é‡åˆ°å¤§äºæ ¹èŠ‚ç‚¹å€¼çš„èŠ‚ç‚¹ï¼Œ
åç»­èŠ‚ç‚¹éƒ½åœ¨æ ¹èŠ‚ç‚¹å³ä¾§ï¼ŒæŒ‰ç…§è¿™ä¸ªæ€è·¯é€’å½’å³å¯
"""
class Node():
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


def buildTree(preorder):
    if len(preorder) == 0:
        return None

    node = Node(preorder[0])

    idx = len(preorder)
    for i in range(1, len(preorder)):
        if preorder[i] > preorder[0]:
            idx = i
            break
    node.left = buildTree(preorder[1:idx])
    node.right = buildTree(preorder[idx:])

    return node


def postorder(node):
    if node is None:
        return []
    output = []
    output.extend(postorder(node.left))
    output.extend(postorder(node.right))
    output.append(str(node.val))

    return output


n = int(input())
preorder = list(map(int, input().split()))
print(' '.join(postorder(buildTree(preorder))))
```



```python
# ç®¡éªæ° ç”Ÿå‘½ç§‘å­¦å­¦é™¢
# ä¸­åºéå†å°±æ˜¯é¡ºåºæ’åˆ—ï¼Œè¿›è€Œé€šè¿‡ä¸Šæ¬¡ä½œä¸šçš„æ€è·¯æ ¹æ®å‰åºä¸­åºæ¨å‡ºååº
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


def build(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_val = preorder[0]
    root = Node(root_val)
    root_index = inorder.index(root_val)
    root.left = build(preorder[1:root_index + 1], inorder[:root_index])
    root.right = build(preorder[root_index + 1:], inorder[root_index + 1:])
    return root


def postorder(root):
    if not root:
        return []
    if root.left is None and root.right is None:
        return [root.val]
    result = []
    result += postorder(root.left)
    result += postorder(root.right)
    result += [root.val]
    return result


input()
preorder = list(map(int, input().split()))
inorder = sorted(preorder)
root = build(preorder, inorder)
result = postorder(root)
print(' '.join(map(str, result)))
```



```python
def post_order(pre_order):
    if not pre_order:
        return []
    root = pre_order[0]
    left_subtree = [x for x in pre_order if x < root]
    right_subtree = [x for x in pre_order if x > root]
    return post_order(left_subtree) + post_order(right_subtree) + [root]

n = int(input())
pre_order = list(map(int, input().split()))
print(' '.join(map(str, post_order(pre_order))))
```



##### ç»ƒä¹ M05455: äºŒå‰æœç´¢æ ‘çš„å±‚æ¬¡éå†

http://cs101.openjudge.cn/practice/05455/

äºŒå‰æœç´¢æ ‘åœ¨åŠ¨æ€æŸ¥è¡¨ä¸­æœ‰ç‰¹åˆ«çš„ç”¨å¤„ï¼Œä¸€ä¸ªæ— åºåºåˆ—å¯ä»¥é€šè¿‡æ„é€ ä¸€æ£µäºŒå‰æœç´¢æ ‘å˜æˆä¸€ä¸ªæœ‰åºåºåˆ—ï¼Œ

æ„é€ æ ‘çš„è¿‡ç¨‹å³ä¸ºå¯¹æ— åºåºåˆ—è¿›è¡Œæ’åºçš„è¿‡ç¨‹ã€‚æ¯æ¬¡æ’å…¥çš„æ–°çš„ç»“ç‚¹éƒ½æ˜¯äºŒå‰æœç´¢æ ‘ä¸Šæ–°çš„å¶å­ç»“ç‚¹ï¼Œåœ¨è¿›è¡Œ

æ’å…¥æ“ä½œæ—¶ï¼Œä¸å¿…ç§»åŠ¨å…¶å®ƒç»“ç‚¹ï¼Œåªéœ€æ”¹åŠ¨æŸä¸ªç»“ç‚¹çš„æŒ‡é’ˆï¼Œç”±ç©ºå˜ä¸ºéç©ºå³å¯ã€‚

è¿™é‡Œï¼Œæˆ‘ä»¬æƒ³æ¢ç©¶äºŒå‰æ ‘çš„å»ºç«‹å’Œå±‚æ¬¡è¾“å‡ºã€‚

**è¾“å…¥**

åªæœ‰ä¸€è¡Œï¼ŒåŒ…å«è‹¥å¹²ä¸ªæ•°å­—ï¼Œä¸­é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚ï¼ˆæ•°å­—å¯èƒ½ä¼šæœ‰é‡å¤ï¼Œå¯¹äºé‡å¤çš„æ•°å­—ï¼Œåªè®¡å…¥ä¸€ä¸ªï¼‰

**è¾“å‡º**

è¾“å‡ºä¸€è¡Œï¼Œå¯¹è¾“å…¥æ•°å­—å»ºç«‹äºŒå‰æœç´¢æ ‘åè¿›è¡ŒæŒ‰å±‚æ¬¡å‘¨æ¸¸çš„ç»“æœã€‚

æ ·ä¾‹è¾“å…¥

```
51 45 59 86 45 4 15 76 60 20 61 77 62 30 2 37 13 82 19 74 2 79 79 97 33 90 11 7 29 14 50 1 96 59 91 39 34 6 72 7
```

æ ·ä¾‹è¾“å‡º

```
51 45 59 4 50 86 2 15 76 97 1 13 20 60 77 90 11 14 19 30 61 82 96 7 29 37 62 79 91 6 33 39 74 34 72
```

æç¤º

è¾“å…¥è¾“å‡ºçš„æœ€åéƒ½ä¸å¸¦ç©ºæ ¼å’Œå›è½¦æ¢è¡Œ



The problem is asking to construct a binary search tree (BST) from a sequence of numbers and then perform a level order traversal (also known as breadth-first search) on the BST.

Here is a step-by-step plan:

1. Create a TreeNode class to represent each node in the tree.
2. Create a function `insert` that takes a node and a value as input and inserts the value into the BST rooted at the node.
3. Create a function `level_order_traversal` that takes the root of the tree as input and returns the level order traversal of the tree.
   - Use a queue to store the nodes to be visited.
   - While the queue is not empty, dequeue a node, visit it, and enqueue its children.
4. Read the sequence of numbers from the input, construct the BST, perform the level order traversal, and output the result.

Here is the Python code that implements this plan:

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def insert(node, value):
    if node is None:
        return TreeNode(value)
    if value < node.value:
        node.left = insert(node.left, value)
    elif value > node.value:
        node.right = insert(node.right, value)
    return node

def level_order_traversal(root):
    queue = [root]
    traversal = []
    while queue:
        node = queue.pop(0)
        traversal.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return traversal

numbers = list(map(int, input().strip().split()))
numbers = list(dict.fromkeys(numbers))  # remove duplicates
root = None
for number in numbers:
    root = insert(root, number)
traversal = level_order_traversal(root)
print(' '.join(map(str, traversal)))
```

This code reads the sequence of numbers from the input, removes duplicates, constructs the BST, performs the level order traversal, and prints the result.



### 7.2 äºŒå‰æœç´¢æ ‘å®ç°å¿«æ’

å¿«é€Ÿæ’åºæ˜¯ä¸€ç§åŸºäºåˆ†æ²»æ³•çš„æ’åºç®—æ³•ï¼Œå®ƒé€šè¿‡é€‰æ‹©ä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†ï¼ˆpivotï¼‰ï¼Œå°†æ•°ç»„åˆ†å‰²ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œå…¶ä¸­ä¸€ä¸ªå­æ•°ç»„çš„å…ƒç´ éƒ½å°äºåŸºå‡†ï¼Œå¦ä¸€ä¸ªå­æ•°ç»„çš„å…ƒç´ éƒ½å¤§äºåŸºå‡†ã€‚ç„¶åï¼Œå¯¹ä¸¤ä¸ªå­æ•°ç»„é€’å½’åœ°åº”ç”¨ç›¸åŒçš„æ’åºè¿‡ç¨‹ï¼Œç›´åˆ°æ’åºå®Œæˆã€‚

äºŒå‰æœç´¢æ ‘æ˜¯ä¸€ç§æœ‰åºçš„äºŒå‰æ ‘ï¼Œå®ƒæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

- å·¦å­æ ‘ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å°äºæ ¹èŠ‚ç‚¹çš„å€¼ã€‚
- å³å­æ ‘ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å¤§äºæ ¹èŠ‚ç‚¹çš„å€¼ã€‚
- å·¦å­æ ‘å’Œå³å­æ ‘ä¹Ÿåˆ†åˆ«æ˜¯äºŒå‰æœç´¢æ ‘ã€‚

å¯ä»¥ä½¿ç”¨äºŒå‰æœç´¢æ ‘æ¥å®ç°å¿«é€Ÿæ’åºçš„è¿‡ç¨‹ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š

1. é€‰æ‹©æ•°ç»„ä¸­çš„ä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†ã€‚
2. åˆ›å»ºä¸€ä¸ªç©ºçš„äºŒå‰æœç´¢æ ‘ã€‚
3. å°†æ•°ç»„ä¸­çš„å…¶ä»–å…ƒç´ é€ä¸ªæ’å…¥äºŒå‰æœç´¢æ ‘ä¸­ã€‚
4. æŒ‰ç…§äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ï¼ˆå·¦å­æ ‘ã€æ ¹èŠ‚ç‚¹ã€å³å­æ ‘ï¼‰å¾—åˆ°æ’åºåçš„ç»“æœã€‚

è¿™ç§æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n log n)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚æ¯æ¬¡æ’å…¥æ“ä½œéƒ½éœ€è¦ O(log n) çš„æ—¶é—´å¤æ‚åº¦ï¼Œæ€»å…±è¿›è¡Œ n-1 æ¬¡æ’å…¥æ“ä½œã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒäºŒå‰æœç´¢æ ‘çš„æ€§èƒ½å–å†³äºæ ‘çš„å¹³è¡¡æ€§ã€‚å¦‚æœäºŒå‰æœç´¢æ ‘å˜å¾—ä¸å¹³è¡¡ï¼Œæ€§èƒ½å¯èƒ½ä¼šä¸‹é™åˆ° O(n^2) çš„æ—¶é—´å¤æ‚åº¦ã€‚å› æ­¤ï¼Œåœ¨å®é™…åº”ç”¨ä¸­ï¼Œä¸ºäº†ç¡®ä¿æ€§èƒ½ï¼Œé€šå¸¸ä¼šä½¿ç”¨å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆå¦‚çº¢é»‘æ ‘ã€AVLæ ‘ï¼‰æ¥å®ç°å¿«é€Ÿæ’åºã€‚

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def insert(root, val):
    if root is None:
        return TreeNode(val)
    if val < root.val:
        root.left = insert(root.left, val)
    else:
        root.right = insert(root.right, val)
    return root

def inorder_traversal(root, result):
    if root:
        inorder_traversal(root.left, result)
        result.append(root.val)
        inorder_traversal(root.right, result)

def quicksort(nums):
    if not nums:
        return []
    root = TreeNode(nums[0])
    for num in nums[1:]:
        insert(root, num)
    result = []
    inorder_traversal(root, result)
    return result

# ç¤ºä¾‹è¾“å…¥
nums = [5, 2, 7, 1, 8, 3]

# ä½¿ç”¨äºŒå‰æœç´¢æ ‘å®ç°å¿«é€Ÿæ’åº
sorted_nums = quicksort(nums)

# æ‰“å°æ’åºç»“æœ
print(sorted_nums)
```



## 8 å¹³è¡¡äºŒå‰æœç´¢æ ‘

å½“äºŒå‰æœç´¢æ ‘ä¸å¹³è¡¡æ—¶ï¼Œgetå’Œputç­‰æ“ä½œçš„æ€§èƒ½å¯èƒ½é™åˆ°O(n)ã€‚æœ¬èŠ‚å°†ä»‹ç»ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æœç´¢æ ‘ï¼Œå®ƒèƒ½è‡ªåŠ¨ç»´æŒå¹³è¡¡ã€‚è¿™ç§æ ‘å«ä½œ AVLæ ‘ï¼Œä»¥å…¶å‘æ˜è€…G. M. Adelson-Velskiiå’ŒE. M. Landisçš„å§“æ°å‘½åã€‚

> AVL å¹³è¡¡æ ‘çš„å…¨ç§°æ˜¯ Adelson-Velsky and Landis å¹³è¡¡æ ‘ã€‚å®ƒæ˜¯ç”±ä¸¤ä½å‰è‹è”çš„è®¡ç®—æœºç§‘å­¦å®¶ï¼Œå³Ğ“ĞµĞ¾Ñ€Ğ³Ğ¸Ğ¹ ĞœĞ°ĞºÑĞ¸Ğ¼Ğ¾Ğ²Ğ¸Ñ‡ ĞĞ´ĞµĞ»ÑŒÑĞ¾Ğ½-Ğ’ĞµĞ»ÑŒÑĞºĞ¸Ğ¹ï¼ˆGeorgy Maximovich Adelson-Velskyï¼‰å’ŒĞ•Ğ²Ğ³ĞµĞ½Ğ¸Ğ¹ ĞœĞ¸Ñ…Ğ°Ğ¹Ğ»Ğ¾Ğ²Ğ¸Ñ‡ Ğ›Ğ°Ğ½Ğ´Ğ¸Ñï¼ˆEvgenii Mikhailovich Landisï¼‰äº1962å¹´æå‡ºçš„ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚
>
> è¿™ç§æ ‘çš„åç§°å–è‡ªè¿™ä¸¤ä½ç§‘å­¦å®¶çš„å§“æ°çš„é¦–å­—æ¯ç¼©å†™ã€‚AVL å¹³è¡¡æ ‘é€šè¿‡åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸Šç»´æŠ¤ä¸€ä¸ªå¹³è¡¡å› å­ï¼ˆbalance factorï¼‰æ¥å®ç°å¹³è¡¡ã€‚<mark>å¹³è¡¡å› å­æ˜¯æŒ‡èŠ‚ç‚¹çš„å·¦å­æ ‘é«˜åº¦ä¸å³å­æ ‘é«˜åº¦ä¹‹å·®çš„ç»å¯¹å€¼ã€‚</mark>é€šè¿‡ä¸æ–­è°ƒæ•´æ ‘çš„ç»“æ„ï¼ŒAVL æ ‘èƒ½å¤Ÿä¿æŒæ ‘çš„å¹³è¡¡ï¼Œä½¿å¾—åœ¨æœ€åæƒ…å†µä¸‹çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¿æŒåœ¨ O(log n)ã€‚
>
> AVL å¹³è¡¡æ ‘çš„ç‰¹ç‚¹æ˜¯åœ¨æ¯æ¬¡æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œä¼šé€šè¿‡æ—‹è½¬æ“ä½œæ¥è°ƒæ•´æ ‘çš„ç»“æ„ï¼Œä½¿å¾—å¹³è¡¡å› å­åœ¨ç‰¹å®šçš„èŒƒå›´å†…ï¼Œé€šå¸¸æ˜¯ -1ã€0ã€1ã€‚è¿™æ ·çš„å¹³è¡¡çŠ¶æ€èƒ½å¤Ÿä¿è¯æ ‘çš„é«˜åº¦å§‹ç»ˆä¿æŒåœ¨è¾ƒå°çš„èŒƒå›´å†…ï¼Œæä¾›äº†è¾ƒå¿«çš„æŸ¥æ‰¾å’Œæ›´æ–°æ“ä½œã€‚
>
> æ€»ç»“èµ·æ¥ï¼ŒAVL å¹³è¡¡æ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œé€šè¿‡è°ƒæ•´æ ‘çš„ç»“æ„æ¥ä¿æŒæ ‘çš„å¹³è¡¡æ€§ï¼Œä»¥æä¾›é«˜æ•ˆçš„æŸ¥æ‰¾å’Œæ›´æ–°æ“ä½œã€‚

AVLæ ‘å®ç°æ˜ å°„æŠ½è±¡æ•°æ®ç±»å‹çš„æ–¹å¼ä¸æ™®é€šçš„äºŒå‰æœç´¢æ ‘ä¸€æ ·ï¼Œå”¯ä¸€çš„å·®åˆ«å°±æ˜¯æ€§èƒ½ã€‚å®ç°AVLæ ‘æ—¶ï¼Œè¦è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ã€‚æˆ‘ä»¬é€šè¿‡æŸ¥çœ‹æ¯ä¸ªèŠ‚ç‚¹å·¦å³å­æ ‘çš„é«˜åº¦æ¥å®ç°è¿™ä¸€ç‚¹ã€‚æ›´æ­£å¼åœ°è¯´ï¼Œå°†å¹³è¡¡å› å­å®šä¹‰ä¸ºå·¦å³å­æ ‘çš„é«˜åº¦ä¹‹å·®ã€‚

$balance Factor = height (left SubTree) - height(right SubTree)$

æ ¹æ®ä¸Šè¿°å®šä¹‰ï¼Œå¦‚æœå¹³è¡¡å› å­å¤§äºé›¶ï¼Œç§°ä¹‹ä¸ºå·¦å€¾ï¼›å¦‚æœå¹³è¡¡å› å­å°äºé›¶ï¼Œå°±æ˜¯å³å€¾ï¼›å¦‚æœå¹³è¡¡å› å­ç­‰äºé›¶ï¼Œé‚£ä¹ˆæ ‘å°±æ˜¯å®Œå…¨å¹³è¡¡çš„ã€‚ä¸ºäº†å®ç°AVLæ ‘å¹¶åˆ©ç”¨å¹³è¡¡æ ‘çš„ä¼˜åŠ¿ï¼Œå°†å¹³è¡¡å› å­ä¸º-1ã€0å’Œ1çš„æ ‘éƒ½å®šä¹‰ä¸º**å¹³è¡¡æ ‘**ã€‚ä¸€æ—¦æŸä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­è¶…å‡ºè¿™ä¸ªèŒƒå›´ï¼Œå°±éœ€è¦é€šè¿‡ä¸€ä¸ªè¿‡ç¨‹è®©æ ‘æ¢å¤å¹³è¡¡ã€‚å›¾1å±•ç¤ºäº†ä¸€æ£µå³å€¾æ ‘åŠå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ã€‚

![../_images/unbalanced.png](https://raw.githubusercontent.com/GMyhf/img/main/img/unbalanced.png)

<center>å›¾1 å¸¦å¹³è¡¡å› å­çš„å³å€¾æ ‘</center>

### 8.1 AVLæ ‘çš„æ€§èƒ½

å…ˆçœ‹çœ‹é™å®šå¹³è¡¡å› å­å¸¦æ¥çš„ç»“æœã€‚ä¿è¯æ ‘çš„å¹³è¡¡å› å­ä¸º-1ã€0æˆ–1ï¼Œå¯ä»¥ä½¿å…³é”®æ“ä½œè·å¾—æ›´å¥½çš„å¤§ O æ€§èƒ½ã€‚é¦–å…ˆè€ƒè™‘å¹³è¡¡å› å­å¦‚ä½•æ”¹å–„æœ€åæƒ…å†µã€‚æœ‰å·¦å€¾ä¸å³å€¾è¿™ä¸¤ç§å¯èƒ½æ€§ã€‚å¦‚æœè€ƒè™‘é«˜åº¦ä¸º0ã€1ã€2å’Œ3çš„æ ‘ï¼Œå›¾2å±•ç¤ºäº†åº”ç”¨æ–°è§„åˆ™åæœ€ä¸å¹³è¡¡çš„å·¦å€¾æ ‘ã€‚

![../_images/worstAVL.png](https://raw.githubusercontent.com/GMyhf/img/main/img/worstAVL.png)

<center>å›¾2 å·¦å€¾AVLæ ‘çš„æœ€åæƒ…å†µ</center>



æŸ¥çœ‹æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ä¹‹åå¯çŸ¥ï¼Œé«˜åº¦ä¸º0æ—¶æœ‰1ä¸ªèŠ‚ç‚¹ï¼Œé«˜åº¦ä¸º1æ—¶æœ‰2ä¸ªèŠ‚ç‚¹ï¼ˆ1 + 1 = 2ï¼‰ï¼Œé«˜åº¦ä¸º2æ—¶æœ‰4ä¸ªèŠ‚ç‚¹ï¼ˆ1 + 1 + 2 = 4ï¼‰ï¼Œé«˜åº¦ä¸º3æ—¶æœ‰7ä¸ªèŠ‚ç‚¹ï¼ˆ1 + 2 + 4 = 7ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“é«˜åº¦ä¸ºhæ—¶ï¼ŒèŠ‚ç‚¹æ•°$N_h$æ˜¯ï¼š

$N_h = 1 + N_{h-1} + N_{h-2}$â€‹

ä½ æˆ–è®¸è§‰å¾—è¿™ä¸ªå…¬å¼å¾ˆçœ¼ç†Ÿï¼Œå› ä¸ºå®ƒä¸<mark>æ–æ³¢é‚£å¥‘æ•°åˆ—</mark>å¾ˆç›¸ä¼¼ã€‚



#### 8.1.1 ç¼–ç¨‹é¢˜ç›®

##### M27625: AVLæ ‘è‡³å°‘æœ‰å‡ ä¸ªç»“ç‚¹

> http://cs101.openjudge.cn/practice/27625/
>
> è¾“å…¥n (0<n<50), è¾“å‡ºä¸€ä¸ªnå±‚çš„AVLæ ‘è‡³å°‘æœ‰å¤šå°‘ä¸ªç»“ç‚¹ã€‚
>
> **è¾“å…¥**
>
> n
>
> **è¾“å‡º**
>
> ç­”æ¡ˆ
>
> æ ·ä¾‹è¾“å…¥
>
> ```
> 4
> ```
>
> æ ·ä¾‹è¾“å‡º
>
> ```
> 7
> ```
>
> æ¥æºï¼šGuo Wei
>
> 
>
> ```python
> from functools import lru_cache
> 
> @lru_cache(maxsize=None)
> def avl_min_nodes(n):
>     if n == 0:
>           return 0
>     elif n == 1:
>           return 1
>     else:
>           return avl_min_nodes(n-1) + avl_min_nodes(n-2) + 1
> 
> n = int(input())
> min_nodes = avl_min_nodes(n)
> print(min_nodes)
> ```
>
> 
>
> ```python
> def avl_min_nodes(n, memo):
>     if n == 0:
>           return 0
>     elif n == 1:
>           return 1
>     elif memo[n] != 0:  # å¦‚æœå·²ç»è®¡ç®—è¿‡ï¼Œç›´æ¥è¿”å›ä¿å­˜çš„ç»“æœ
>           return memo[n]
>     else:
>           memo[n] = avl_min_nodes(n-1, memo) + avl_min_nodes(n-2, memo) + 1
>           return memo[n]
> 
> n = int(input())
> memo = [0] * (n+1)  # åˆ›å»ºä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜å·²è®¡ç®—çš„ç»“æœ
> min_nodes = avl_min_nodes(n, memo)
> print(min_nodes)
> ```





##### M27626: AVLæ ‘æœ€å¤šæœ‰å‡ å±‚

> http://cs101.openjudge.cn/practice/27626/
>
> nä¸ªç»“ç‚¹çš„AVLæ ‘æœ€å¤šæœ‰å¤šå°‘å±‚ï¼Ÿ
>
> **è¾“å…¥**
>
> æ•´æ•°n ã€‚ 0< n < 50,000,000
>
> **è¾“å‡º**
>
> AVLæ ‘æœ€å¤šæœ‰å¤šå°‘å±‚
>
> æ ·ä¾‹è¾“å…¥
>
> ```
> 20
> ```
>
> æ ·ä¾‹è¾“å‡º
>
> ```
> 6
> ```
>
> æ¥æºï¼šGuo Wei
>
> 
>
> AVLæ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦æœ€å¤šç›¸å·®1ã€‚ä¸ºäº†ç¡®å®šå…·æœ‰`n`ä¸ªèŠ‚ç‚¹çš„AVLæ ‘çš„æœ€å¤§é«˜åº¦ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªé€’å½’å…³ç³»ï¼Œè¯¥å…³ç³»æè¿°äº†ç»™å®šé«˜åº¦çš„AVLæ ‘æ‰€èƒ½åŒ…å«çš„æœ€å°‘èŠ‚ç‚¹æ•°ã€‚
>
> è®¾`N(h)`è¡¨ç¤ºé«˜åº¦ä¸º`h`çš„AVLæ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ï¼Œé‚£ä¹ˆæœ‰å¦‚ä¸‹é€’å½’å…³ç³»ï¼š
>
> ```
> N(h) = N(h-1) + N(h-2) + 1
> ```
>
> è¿™é‡Œï¼Œ`N(h-1)`æ˜¯è¾ƒé«˜å­æ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ï¼Œ`N(h-2)`æ˜¯è¾ƒçŸ®å­æ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ï¼Œ`+1`æ˜¯æ ¹èŠ‚ç‚¹è‡ªèº«ã€‚
>
> åŸºæœ¬æƒ…å†µæ˜¯ï¼š
>
> ```
> N(1) = 1  ï¼ˆå•ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼‰
> N(0) = 0  ï¼ˆç©ºæ ‘ï¼‰
> ```
>
> å¯ä»¥ä½¿ç”¨è¿™ä¸ªé€’å½’å…³ç³»æ¥è®¡ç®—ä»»ä½•é«˜åº¦çš„AVLæ ‘çš„æœ€å°‘èŠ‚ç‚¹æ•°ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é€’å¢é«˜åº¦ï¼Œç›´åˆ°è®¡ç®—å‡ºçš„èŠ‚ç‚¹æ•°è¶…è¿‡è¾“å…¥çš„`n`ï¼Œæ¥æ‰¾å‡ºå…·æœ‰`n`ä¸ªèŠ‚ç‚¹çš„AVLæ ‘çš„æœ€å¤§é«˜åº¦ã€‚
>
> ç”¨äºè®¡ç®—å…·æœ‰`n`ä¸ªèŠ‚ç‚¹çš„AVLæ ‘çš„æœ€å¤§é«˜åº¦ï¼š
>
> ```python
> from functools import lru_cache
> 
> @lru_cache(maxsize=None)
> def min_nodes(h):
>     if h == 0: return 0
>     if h == 1: return 1
>     return min_nodes(h-1) + min_nodes(h-2) + 1
> 
> def max_height(n):
>      h = 0
>      while min_nodes(h) <= n:
>           h += 1
>     return h - 1
> 
> n = int(input())
> print(max_height(n))
> ```



å› ä¸ºä¸æ–æ³¢é‚£å¥‘æ•°åˆ—å¾ˆç›¸ä¼¼ï¼Œå¯ä»¥æ ¹æ®å®ƒæ¨å¯¼å‡ºç”±AVLæ ‘çš„èŠ‚ç‚¹æ•°è®¡ç®—é«˜åº¦çš„å…¬å¼ã€‚åœ¨æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­ï¼Œç¬¬iä¸ªæ•°æ˜¯ï¼š

$\begin{split}F_0 = 0 \\
F_1 = 1 \\
F_i = F_{i-1} + F_{i-2}  \text{ for all } i \ge 2\end{split}$â€‹



ä¸€ä¸ªé‡è¦çš„äº‹å®æ˜¯ï¼Œéšç€æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å¢é•¿ï¼Œ$F_i/F_{i-1}$é€æ¸é€¼è¿‘é»„é‡‘åˆ†å‰²æ¯”ä¾‹$\Phi$ï¼Œ$ \Phi = \frac{1 + \sqrt{5}}{2}$ã€‚å¦‚æœä½ å¥½å¥‡è¿™ä¸ªç­‰å¼çš„æ¨å¯¼è¿‡ç¨‹ï¼Œå¯ä»¥æ‰¾ä¸€æœ¬æ•°å­¦ä¹¦çœ‹çœ‹ã€‚æˆ‘ä»¬åœ¨æ­¤ç›´æ¥ä½¿ç”¨è¿™ä¸ªç­‰å¼ï¼Œå°†$F_i$è¿‘ä¼¼ä¸º$F_i =
\Phi^i/\sqrt{5}$ã€‚

> ```python
> def fibonacci_recursive(n):
>  if n <= 1:
>      return n
>  else:
>      return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
> 
> 
> def fibonacci_iterative(n):
>  if n <= 1:
>      return n
>  else:
>      a, b = 0, 1
>      for _ in range(2, n+1):
>          a, b = b, a + b
>      return b
> 
> 
> phi = (1+5**0.5)/2
> 
> dp = [0]
> print("The ith Fibonacci number, \t With golden ratio approximation")
> for i in range(10):
>  result_recursive = fibonacci_recursive(i)
>  print(f"F{i}: {result_recursive}, ", end='')
>  print(f'{phi**i/(5**0.5)}')
> 
> """
> The ith Fibonacci number, 	 With golden ratio approximation
> F0: 0, 0.4472135954999579
> F1: 1, 0.7236067977499789
> F2: 1, 1.1708203932499368
> F3: 2, 1.8944271909999157
> F4: 3, 3.065247584249853
> F5: 5, 4.959674775249769
> F6: 8, 8.024922359499623
> F7: 13, 12.984597134749393
> F8: 21, 21.009519494249016
> F9: 34, 33.99411662899841
> """
> ```
>
> 

$\begin{split} N_0 = 1 \\
N_1 = 2 \quad F_3 = 3 \\
N_2 = 4 \quad F_4 = 5 \\
N_3 = 7 \quad F_5 = 8 
\end{split}$



ç”±æ­¤ï¼Œå¯ä»¥å°†$N_h$çš„ç­‰å¼é‡å†™ä¸ºï¼š

$N_h = F_{h+2} - 1, h \ge 1$

ç”¨é»„é‡‘åˆ†å‰²è¿‘ä¼¼æ›¿æ¢ï¼Œå¾—åˆ°ï¼š

$N_h = \frac{\Phi^{h+2}}{\sqrt{5}} - 1$

ç§»é¡¹ï¼Œä¸¤è¾¹ä»¥2ä¸ºåº•å–å¯¹æ•°ï¼Œæ±‚hï¼Œå¾—åˆ°ï¼š

$\begin{split}\log{(N_h+1)} = (h+2)\log{\Phi} - \frac{1}{2} \log{5} \\
h = \frac{\log{(N_h+1)} - 2 \log{\Phi} + \frac{1}{2} \log{5}}{\log{\Phi}} \\
h = 1.44 \log{N_h}\end{split}$â€‹â€‹â€‹â€‹

åœ¨ä»»ä½•æ—¶é—´ï¼ŒAVLæ ‘çš„é«˜åº¦éƒ½ç­‰äºèŠ‚ç‚¹æ•°å–å¯¹æ•°å†ä¹˜ä»¥ä¸€ä¸ªå¸¸æ•°ï¼ˆ1.44ï¼‰ã€‚å¯¹äºæœç´¢AVLæ ‘æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ä»¶å¥½äº‹ï¼Œå› ä¸ºæ—¶é—´å¤æ‚åº¦è¢«é™åˆ¶ä¸º$O(\log{N})$â€‹ã€‚



### 8.2 AVLæ ‘çš„å®ç°

å·²ç»è¯æ˜ï¼Œä¿æŒAVLæ ‘çš„å¹³è¡¡ä¼šå¸¦æ¥å¾ˆå¤§çš„æ€§èƒ½ä¼˜åŠ¿ï¼Œç°åœ¨çœ‹çœ‹å¦‚ä½•å¾€æ ‘ä¸­æ’å…¥ä¸€ä¸ªé”®ã€‚æ‰€æœ‰æ–°é”®éƒ½æ˜¯ä»¥å¶å­èŠ‚ç‚¹æ’å…¥çš„ï¼Œå› ä¸ºæ–°å¶å­èŠ‚ç‚¹çš„å¹³è¡¡å› å­æ˜¯é›¶ï¼Œæ‰€ä»¥æ–°æ’èŠ‚ç‚¹æ²¡æœ‰ä»€ä¹ˆé™åˆ¶æ¡ä»¶ã€‚ä½†æ’å…¥æ–°èŠ‚ç‚¹åï¼Œå¿…é¡»æ›´æ–°çˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­ã€‚æ–°çš„å¶å­èŠ‚ç‚¹å¯¹å…¶çˆ¶èŠ‚ç‚¹å¹³è¡¡å› å­çš„å½±å“å–å†³äºå®ƒæ˜¯å·¦å­èŠ‚ç‚¹è¿˜æ˜¯å³å­èŠ‚ç‚¹ã€‚å¦‚æœæ˜¯å³å­èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­å‡ä¸€ã€‚å¦‚æœæ˜¯å·¦å­èŠ‚ç‚¹ï¼Œåˆ™çˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­åŠ ä¸€ã€‚

å‡è®¾ç°åœ¨å·²æœ‰ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘ï¼Œé‚£ä¹ˆå¯ä»¥é¢„è§åˆ°ï¼Œåœ¨å¾€å…¶ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œä¸€å®šä¼šæœ‰ç»“ç‚¹çš„å¹³è¡¡å› å­å‘ç”Ÿå˜åŒ–ï¼Œæ­¤æ—¶å¯èƒ½ä¼šæœ‰ç»“ç‚¹çš„å¹³è¡¡å› å­çš„ç»å¯¹å€¼å¤§äº 1ï¼ˆè¿™äº›å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 2 æˆ–è€… -2)ï¼Œè¿™æ ·ä»¥è¯¥ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘å°±æ˜¯å¤±è¡¡çš„ï¼Œéœ€è¦è¿›è¡Œè°ƒæ•´ã€‚æ˜¾ç„¶ï¼Œåªæœ‰åœ¨ä»æ ¹ç»“ç‚¹åˆ°è¯¥æ’å…¥ç»“ç‚¹çš„è·¯å¾„ä¸Šçš„ç»“ç‚¹æ‰å¯èƒ½å‘ç”Ÿå¹³è¡¡å› å­å˜åŒ–ï¼Œå› æ­¤åªéœ€å¯¹è¿™æ¡è·¯å¾„ä¸Šå¤±è¡¡çš„ç»“ç‚¹è¿›è¡Œè°ƒæ•´ã€‚å¯ä»¥è¯æ˜ï¼Œ<mark>åªè¦æŠŠæœ€é è¿‘æ’å…¥ç»“ç‚¹çš„å¤±è¡¡ç»“ç‚¹è°ƒæ•´åˆ°æ­£å¸¸ï¼Œè·¯å¾„ä¸Šçš„æ‰€æœ‰ç»“ç‚¹å°±éƒ½ä¼šå¹³è¡¡</mark>ã€‚

å½“å¹³è¡¡çš„äºŒå‰æ’åºæ ‘å› æ’å…¥ç»“ç‚¹è€Œå¤±å»å¹³è¡¡æ—¶ï¼Œä»…éœ€å¯¹æœ€å°ä¸å¹³è¡¡å­æ ‘è¿›è¡Œå¹³è¡¡æ—‹è½¬å¤„ç†å³å¯ã€‚å› ä¸ºç»è¿‡æ—‹è½¬å¤„ç†ä¹‹åçš„å­æ ‘æ·±åº¦å’Œæ’å…¥ä¹‹å‰ç›¸åŒï¼Œå› è€Œä¸å½±å“æ’å…¥è·¯å¾„ä¸Šæ‰€æœ‰ç¥–å…ˆç»“ç‚¹çš„å¹³è¡¡åº¦ã€‚



> å¦‚æœéœ€è¦è¿›è¡Œå†å¹³è¡¡ï¼Œè¯¥æ€ä¹ˆåšå‘¢ï¼Ÿé«˜æ•ˆçš„å†å¹³è¡¡æ˜¯è®©AVLæ ‘å‘æŒ¥ä½œç”¨åŒæ—¶ä¸æŸæ€§èƒ½çš„å…³é”®ã€‚ä¸ºäº†è®©AVLæ ‘æ¢å¤å¹³è¡¡ï¼Œéœ€è¦åœ¨æ ‘ä¸Šè¿›è¡Œä¸€æ¬¡æˆ–å¤šæ¬¡æ—‹è½¬ã€‚
>
> è¦ç†è§£ä»€ä¹ˆæ˜¯æ—‹è½¬ï¼Œæ¥çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚è€ƒè™‘å›¾3ä¸­å·¦è¾¹çš„æ ‘ã€‚è¿™æ£µæ ‘å¤±è¡¡äº†ï¼Œå¹³è¡¡å› å­æ˜¯-2ã€‚è¦è®©å®ƒæ¢å¤å¹³è¡¡ï¼Œæˆ‘ä»¬å›´ç»•ä»¥èŠ‚ç‚¹Aä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘åšä¸€æ¬¡å·¦æ—‹ã€‚
>
> ![../_images/simpleunbalanced.png](https://raw.githubusercontent.com/GMyhf/img/main/img/simpleunbalanced.png)
>
> <center>å›¾3 é€šè¿‡å·¦æ—‹è®©å¤±è¡¡çš„æ ‘æ¢å¤å¹³è¡¡</center>
>
> æœ¬è´¨ä¸Šï¼Œå·¦æ—‹åŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ã€‚
>
> â å°†å³å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Bï¼‰æå‡ä¸ºå­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
> â å°†æ—§æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Aï¼‰ä½œä¸ºæ–°æ ¹èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ã€‚
> â å¦‚æœæ–°æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Bï¼‰å·²ç»æœ‰ä¸€ä¸ªå·¦å­èŠ‚ç‚¹ï¼Œå°†å…¶ä½œä¸ºæ–°å·¦å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Aï¼‰çš„å³å­èŠ‚ç‚¹ã€‚æ³¨æ„ï¼Œ<mark>å› ä¸ºèŠ‚ç‚¹Bä¹‹å‰æ˜¯èŠ‚ç‚¹Açš„å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ­¤æ—¶èŠ‚ç‚¹Aå¿…ç„¶æ²¡æœ‰å³å­èŠ‚ç‚¹ã€‚</mark>å› æ­¤ï¼Œå¯ä»¥ä¸ºå®ƒæ·»åŠ æ–°çš„å³å­èŠ‚ç‚¹ï¼Œè€Œæ— é¡»è¿‡å¤šè€ƒè™‘ã€‚
>
> æ¥çœ‹ä¸€æ£µç¨å¾®å¤æ‚ä¸€ç‚¹çš„æ ‘ï¼Œå¹¶ç†è§£å³æ—‹è¿‡ç¨‹ã€‚å›¾4å·¦è¾¹çš„æ˜¯ä¸€æ£µå·¦å€¾çš„æ ‘ï¼Œæ ¹èŠ‚ç‚¹çš„å¹³è¡¡å› å­æ˜¯2ã€‚å³æ—‹æ­¥éª¤å¦‚ä¸‹ã€‚
>
> ![../_images/rightrotate1.png](https://raw.githubusercontent.com/GMyhf/img/main/img/rightrotate1.png)
>
> <center>å›¾4 é€šè¿‡å³æ—‹è®©å¤±è¡¡çš„æ ‘æ¢å¤å¹³è¡¡</center>
>
> â å°†å·¦å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Cï¼‰æå‡ä¸ºå­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
> â å°†æ—§æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Eï¼‰ä½œä¸ºæ–°æ ¹èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ã€‚
> â å¦‚æœæ–°æ ¹èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Cï¼‰å·²ç»æœ‰ä¸€ä¸ªå³å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Dï¼‰ï¼Œå°†å…¶ä½œä¸ºæ–°å³å­èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹Eï¼‰çš„å·¦å­èŠ‚ç‚¹ã€‚æ³¨æ„ï¼Œ<mark>å› ä¸ºèŠ‚ç‚¹Cä¹‹å‰æ˜¯èŠ‚ç‚¹Eçš„å·¦å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ­¤æ—¶èŠ‚ç‚¹Eå¿…ç„¶æ²¡æœ‰å·¦å­èŠ‚ç‚¹ã€‚</mark>å› æ­¤ï¼Œå¯ä»¥ä¸ºå®ƒæ·»åŠ æ–°çš„å·¦å­èŠ‚ç‚¹ï¼Œè€Œæ— é¡»è¿‡å¤šè€ƒè™‘ã€‚



å‡è®¾æœ€é è¿‘æ’å…¥ç»“ç‚¹çš„å¤±è¡¡ç»“ç‚¹æ˜¯ Aï¼Œæ˜¾ç„¶å®ƒçš„å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 2 æˆ–è€… -2ã€‚å¾ˆå®¹æ˜“å‘ç°è¿™ä¸¤ç§æƒ…å†µå®Œå…¨å¯¹ç§°ï¼Œå› æ­¤ä¸»è¦è®¨è®ºç»“ç‚¹ A çš„å¹³è¡¡å› å­æ˜¯ 2 çš„æƒ…å½¢ã€‚

ç”±äºç»“ç‚¹ A çš„å¹³è¡¡å› å­æ˜¯ 2ï¼Œå› æ­¤å·¦å­æ ‘çš„é«˜åº¦æ¯”å³å­æ ‘å¤§ 2ï¼Œäºæ˜¯ä»¥ç»“ç‚¹ A ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘ä¸€å®šæ˜¯å›¾4çš„ä¸¤ç§å½¢æ€ LL å‹ä¸ LR å‹ä¹‹ä¸€ï¼ˆ**æ³¨æ„ï¼šLL å’Œ LR åªè¡¨ç¤ºæ ‘å‹ï¼Œä¸æ˜¯å·¦å³æ—‹çš„æ„æ€**ï¼‰ï¼Œå…¶ä¸­â˜†ã€â˜…ã€â—‡ã€â—†æ˜¯å›¾ä¸­ç›¸åº”ç»“ç‚¹çš„ AVL å­æ ‘ï¼Œç»“ç‚¹ Aã€Bã€C çš„æƒå€¼æ»¡è¶³ A > B > Cã€‚å¯ä»¥å‘ç°ï¼Œ**å½“ç»“ç‚¹ A çš„å·¦å­©å­çš„å¹³è¡¡å› å­æ˜¯ 1 æ—¶ä¸º LL å‹ï¼Œæ˜¯ -1 æ—¶ä¸º LR å‹**ã€‚é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆç»“ç‚¹ A çš„å·¦å­©å­çš„å¹³è¡¡å› å­åªå¯èƒ½æ˜¯ 1 æˆ–è€… -1 ï¼Œè€Œä¸å¯èƒ½æ˜¯ 0 å‘¢?è¿™æ˜¯å› ä¸ºè¿™ç§æƒ…å†µæ— æ³•ç”±å¹³è¡¡äºŒå‰æ ‘æ’å…¥ä¸€ä¸ªç»“ç‚¹å¾—åˆ°ã€‚(ä¸ä¿¡ä¸¾ä¸ªåä¾‹ï¼Ÿ)



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403221922941.png" alt="image-20240322192203776" style="zoom:50%;" />

<center>å›¾4 æ ‘å‹ä¹‹ LL å‹ä¸ LR å‹ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



è¡¥å……è¯´æ˜ï¼Œé™¤äº†â˜†ã€â˜…ã€â—‡ã€â—†å‡ä¸ºç©ºæ ‘çš„æƒ…å†µä»¥å¤–ï¼Œå…¶ä»–ä»»ä½•æƒ…å†µå‡æ»¡è¶³åœ¨æ’å…¥å‰åº•å±‚ä¸¤æ£µå­æ ‘çš„é«˜åº¦æ¯”å¦å¤–ä¸¤æ£µå­æ ‘çš„é«˜åº¦å° 1ï¼Œä¸”æ’å…¥æ“ä½œä¸€å®šå‘ç”Ÿåœ¨åº•å±‚ä¸¤æ£µå­æ ‘ä¸Šã€‚ä¾‹å¦‚å¯¹LLå‹æ¥è¯´ï¼Œæ’å…¥å‰å­æ ‘çš„é«˜åº¦æ»¡è¶³â˜† = â˜… = â—†-1 = â—‡-1ï¼Œè€Œåœ¨â˜†æˆ–â˜…ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹åå¯¼è‡´â˜†æˆ–â˜…çš„é«˜åº¦åŠ  1ï¼Œä½¿å¾—ç»“ç‚¹Aä¸å¹³è¡¡ã€‚ï¼ˆè¾…åŠ©ç†è§£ï¼Œä¸éœ€è¦è®°ä½ï¼‰ç°åœ¨è€ƒè™‘æ€æ ·è°ƒæ•´è¿™ä¸¤ç§æ ‘å‹ï¼Œæ‰èƒ½ä½¿æ ‘å¹³è¡¡ã€‚

å…ˆè€ƒè™‘ LL å‹ï¼Œå¯ä»¥æŠŠä»¥ C ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘çœ‹ä½œä¸€ä¸ªæ•´ä½“ï¼Œç„¶åä»¥ç»“ç‚¹ A ä½œä¸º root è¿›è¡Œå³æ—‹ï¼Œä¾¿å¯ä»¥è¾¾åˆ°å¹³è¡¡ï¼Œå¦‚å›¾5 æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403221936655.png" alt="image-20240322193648365" style="zoom:50%;" />



<center>å›¾5 LL å‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



ç„¶åè€ƒè™‘ LR å‹ï¼Œå¯ä»¥å…ˆå¿½ç•¥ç»“ç‚¹ Aï¼Œä»¥ç»“ç‚¹ C ä¸ºroot è¿›è¡Œå·¦æ—‹ï¼Œå°±å¯ä»¥æŠŠæƒ…å†µè½¬åŒ–ä¸º LL å‹ï¼Œç„¶åæŒ‰ä¸Šé¢ LL å‹çš„åšæ³•è¿›è¡Œä¸€æ¬¡å³æ—‹å³å¯ï¼Œå¦‚å›¾6 æ‰€ç¤ºã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403221938907.png" alt="image-20240322193842032" style="zoom:50%;" />

<center>å›¾6 LRå‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



è‡³æ­¤,ç»“ç‚¹ A çš„å¹³è¡¡å› å­æ˜¯ 2 çš„æƒ…å†µå·²ç»è®¨è®ºæ¸…æ¥š,ä¸‹é¢ç®€è¦è¯´æ˜å¹³è¡¡å› å­æ˜¯ -2 çš„æƒ…å†µï¼Œæ˜¾ç„¶ä¸¤ç§æƒ…å†µæ˜¯å®Œå…¨å¯¹ç§°çš„ã€‚
ç”±äºç»“ç‚¹ A çš„å¹³è¡¡å› å­ä¸º -2ï¼Œå› æ­¤å³å­æ ‘çš„é«˜åº¦æ¯”å·¦å­æ ‘å¤§ 2ï¼Œäºæ˜¯ä»¥ç»“ç‚¹Aä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘ä¸€å®šæ˜¯å›¾7 çš„ä¸¤ç§å½¢æ€ RR å‹ä¸ RL å‹ä¹‹ä¸€ã€‚æ³¨æ„ï¼Œç”±äºå’Œä¸Šé¢è®¨è®ºçš„ LL å‹å’Œ LR å‹å¯¹ç§°ï¼Œæ­¤å¤„ç»“ç‚¹ Aã€Bã€C çš„æƒå€¼æ»¡è¶³A < B < Cã€‚å¯ä»¥å‘ç°ï¼Œ**å½“ç»“ç‚¹ A çš„å³å­©å­çš„å¹³è¡¡å› å­æ˜¯ -1 æ—¶ä¸º RR å‹ï¼Œæ˜¯1æ—¶ä¸º RL å‹**ã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240327180845393.png" alt="image-20240327180845393" style="zoom: 25%;" />

<center>å›¾7 æ ‘å‹ä¹‹ RRå‹ä¸RLå‹ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



å¯¹ RR å‹æ¥è¯´ï¼Œå¯ä»¥æŠŠä»¥ C ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘çœ‹ä½œä¸€ä¸ªæ•´ä½“ï¼Œç„¶åä»¥ç»“ç‚¹ A ä½œä¸º root è¿›è¡Œå·¦æ—‹ï¼Œä¾¿å¯ä»¥è¾¾åˆ°å¹³è¡¡ï¼Œå¦‚å›¾8 æ‰€ç¤ºã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240327181005318.png" alt="image-20240327181005318" style="zoom:25%;" />

<center>å›¾8 RR å‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



å¯¹ RL å‹æ¥è¯´ï¼Œå¯ä»¥å…ˆå¿½ç•¥ç»“ç‚¹ Aï¼Œä»¥ç»“ç‚¹ C ä¸º root è¿›è¡Œå³æ—‹ï¼Œå°±å¯ä»¥æŠŠæƒ…å†µè½¬åŒ–ä¸º RR ç„¶åæŒ‰ä¸Šé¢ RR å‹çš„åšæ³•è¿›è¡Œä¸€æ¬¡å·¦æ—‹å³å¯ï¼Œå¦‚å›¾9 æ‰€ç¤ºã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240327181120393.png" alt="image-20240327181120393" style="zoom:25%;" />

<center>å›¾9 RLå‹è°ƒæ•´ç¤ºæ„å›¾ï¼ˆæ•°å­—ä»£è¡¨å¹³è¡¡å› å­ï¼‰</center>



è‡³æ­¤ï¼Œå¯¹LL å‹ã€LR å‹ã€RR å‹ã€RLå‹çš„è°ƒæ•´æ–¹æ³•éƒ½å·²ç»è®¨è®ºæ¸…æ¥šã€‚

é€šè¿‡ç»´æŒæ ‘çš„å¹³è¡¡ï¼Œå¯ä»¥ä¿è¯getæ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(\log_2(n))$ã€‚ä½†è¿™ä¼šç»™putæ“ä½œçš„æ€§èƒ½å¸¦æ¥å¤šå¤§å½±å“å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹çœ‹putæ“ä½œã€‚å› ä¸ºæ–°èŠ‚ç‚¹ä½œä¸ºå¶å­èŠ‚ç‚¹æ’å…¥ï¼Œæ‰€ä»¥æ›´æ–°æ‰€æœ‰çˆ¶èŠ‚ç‚¹çš„å¹³è¡¡å› å­æœ€å¤šéœ€è¦$\log_2(n)$æ¬¡æ“ä½œâ€”â€”æ¯ä¸€å±‚ä¸€æ¬¡ã€‚å¦‚æœæ ‘å¤±è¡¡äº†ï¼Œæ¢å¤å¹³è¡¡æœ€å¤šéœ€è¦æ—‹è½¬ä¸¤æ¬¡ã€‚æ¯æ¬¡æ—‹è½¬çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(1)ï¼Œæ‰€ä»¥putæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä»ç„¶æ˜¯$O(log_2(n))$â€‹ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†ä¸€æ£µå¯ç”¨çš„AVLæ ‘ã€‚äº†è§£æ—‹è½¬çš„åŸºæœ¬åŸç†ä¹‹åï¼Œæ¥çœ‹ç¼–ç¨‹é¢˜ç›®ã€‚



#### 8.2.1 ç¼–ç¨‹é¢˜ç›®

##### æ™´é—®9.5: å¹³è¡¡äºŒå‰æ ‘çš„å»ºç«‹

https://sunnywhy.com/sfbj/9/5/359

å°† n ä¸ªäº’ä¸ç›¸åŒçš„æ­£æ•´æ•°å…ˆåæ’å…¥åˆ°ä¸€æ£µç©ºçš„AVLæ ‘ä¸­ï¼Œæ±‚æœ€åç”Ÿæˆçš„AVLæ ‘çš„å…ˆåºåºåˆ—ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° $n (1 \le n \le 50)$ï¼Œè¡¨ç¤ºAVLæ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œ n ä¸ªæ•´æ•°$a_i (1 \le a_i \le 100)$ï¼Œè¡¨ç¤ºè¡¨ç¤ºæ’å…¥åºåˆ—ã€‚

**è¾“å‡º**

è¾“å‡º n ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå…ˆåºéå†åºåˆ—ï¼Œä¸­é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5
5 2 3 6 8
```

è¾“å‡º

```
3 2 6 5 8
```

è§£é‡Š

æ’å…¥çš„è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202403210041932.png" alt="å¹³è¡¡äºŒå‰æ ‘çš„å»ºç«‹.png" style="zoom:67%;" />



To solve this problem, you can follow these steps:

1. Read the input sequence.
2. Insert the values into an AVL tree. An AVL tree is a self-balancing binary search tree, and the heights of the two child subtrees of any node differ by at most one.
3. Perform a preorder traversal of the AVL tree and print the result.

Here is the Python code that implements this plan:

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
        self.height = 1

class AVL:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = Node(value)
        else:
            self.root = self._insert(value, self.root)

    def _insert(self, value, node):
        if not node:
            return Node(value)
        elif value < node.value:
            node.left = self._insert(value, node.left)
        else:
            node.right = self._insert(value, node.right)

        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))

        balance = self._get_balance(node)

        if balance > 1:
            if value < node.left.value:	# æ ‘å½¢æ˜¯ LL
                return self._rotate_right(node)
            else:	# æ ‘å½¢æ˜¯ LR
                node.left = self._rotate_left(node.left)
                return self._rotate_right(node)

        if balance < -1:
            if value > node.right.value:	# æ ‘å½¢æ˜¯ RR
                return self._rotate_left(node)
            else:	# æ ‘å½¢æ˜¯ RL
                node.right = self._rotate_right(node.right)
                return self._rotate_left(node)

        return node

    def _get_height(self, node):
        if not node:
            return 0
        return node.height

    def _get_balance(self, node):
        if not node:
            return 0
        return self._get_height(node.left) - self._get_height(node.right)

    def _rotate_left(self, z):
        y = z.right
        T2 = y.left
        y.left = z
        z.right = T2
        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        return y

    def _rotate_right(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))
        x.height = 1 + max(self._get_height(x.left), self._get_height(x.right))
        return x

    def preorder(self):
        return self._preorder(self.root)

    def _preorder(self, node):
        if not node:
            return []
        return [node.value] + self._preorder(node.left) + self._preorder(node.right)

n = int(input().strip())
sequence = list(map(int, input().strip().split()))

avl = AVL()
for value in sequence:
    avl.insert(value)

print(' '.join(map(str, avl.preorder())))
```

This code reads the sequence from the input, inserts its values into an AVL tree, performs a preorder traversal of the AVL tree, and then prints the result.



#### 8.2.2 AVLæ ‘ä¸­åˆ é™¤èŠ‚ç‚¹

è¦å®ç°ä»AVLæ ‘ä¸­åˆ é™¤èŠ‚ç‚¹ï¼Œéœ€è¦æ·»åŠ ä¸€ä¸ªåˆ é™¤æ–¹æ³•ï¼Œå¹¶ç¡®ä¿åœ¨åˆ é™¤èŠ‚ç‚¹åé‡æ–°å¹³è¡¡æ ‘ã€‚

ä¸‹é¢æ˜¯æ›´æ–°åçš„ä»£ç ï¼ŒåŒ…æ‹¬åˆ é™¤æ–¹æ³• `_delete`ï¼š

```python
class AVL:
    # Existing code...
    
    def delete(self, value):
        self.root = self._delete(value, self.root)

    def _delete(self, value, node):
        if not node:
            return node

        if value < node.value:
            node.left = self._delete(value, node.left)
        elif value > node.value:
            node.right = self._delete(value, node.right)
        else:
            if not node.left:
                temp = node.right
                node = None
                return temp
            elif not node.right:
                temp = node.left
                node = None
                return temp

            temp = self._min_value_node(node.right)
            node.value = temp.value
            node.right = self._delete(temp.value, node.right)

        if not node:
            return node

        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))

        balance = self._get_balance(node)

        # Rebalance the tree
        if balance > 1:
            if self._get_balance(node.left) >= 0:
                return self._rotate_right(node)
            else:
                node.left = self._rotate_left(node.left)
                return self._rotate_right(node)

        if balance < -1:
            if self._get_balance(node.right) <= 0:
                return self._rotate_left(node)
            else:
                node.right = self._rotate_right(node.right)
                return self._rotate_left(node)

        return node

    def _min_value_node(self, node):
        current = node
        while current.left:
            current = current.left
        return current

    # Existing code...
```

è¿™æ®µä»£ç ä¸­çš„ `_delete` æ–¹æ³•ç”¨äºåˆ é™¤èŠ‚ç‚¹ã€‚å®ƒé¦–å…ˆæ£€æŸ¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œç„¶åæ ¹æ®èŠ‚ç‚¹çš„å·¦å³å­æ ‘æƒ…å†µæ‰§è¡Œç›¸åº”çš„æ“ä½œï¼Œä»¥ä¿æŒAVLæ ‘çš„å¹³è¡¡ã€‚

åœ¨ AVL æ ‘ä¸­ï¼Œåˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œå½“è¢«åˆ é™¤çš„èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹æ—¶ï¼Œéœ€è¦ä¸€äº›é¢å¤–çš„æ­¥éª¤æ¥ä¿æŒæ ‘çš„å¹³è¡¡æ€§ã€‚è®©æˆ‘ä»¬è¯¦ç»†è®²è§£ `else` åˆ†æ”¯ä¸­çš„æƒ…å†µï¼š

```python
else:
    if not node.left:
        temp = node.right
        node = None
        return temp
    elif not node.right:
        temp = node.left
        node = None
        return temp

    temp = self._min_value_node(node.right)
    node.value = temp.value
    node.right = self._delete(temp.value, node.right)
```

1. å¦‚æœè¦åˆ é™¤çš„èŠ‚ç‚¹ `node` æ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¿”å›å…¶å³å­èŠ‚ç‚¹ã€‚è¿™æ˜¯å› ä¸ºå³å­èŠ‚ç‚¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰å°†å æ® `node` çš„ä½ç½®ï¼Œè€Œä¸ä¼šå½±å“æ ‘çš„å¹³è¡¡æ€§ã€‚æ‰€ä»¥æˆ‘ä»¬å°† `node` è®¾ç½®ä¸º `None`ï¼Œç„¶åè¿”å›å…¶å³å­èŠ‚ç‚¹å³å¯ã€‚

2. å¦‚æœè¦åˆ é™¤çš„èŠ‚ç‚¹ `node` æ²¡æœ‰å³å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¿”å›å…¶å·¦å­èŠ‚ç‚¹ã€‚è¿™ä¸ä¸Šè¿°æƒ…å†µç±»ä¼¼ã€‚

3. å¦‚æœè¦åˆ é™¤çš„èŠ‚ç‚¹ `node` æ—¢æœ‰å·¦å­èŠ‚ç‚¹åˆæœ‰å³å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ‰¾åˆ° `node` çš„å³å­æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶å€¼æ›¿æ¢åˆ° `node` ä¸­ï¼Œç„¶ååœ¨å³å­æ ‘ä¸­åˆ é™¤è¿™ä¸ªæœ€å°å€¼èŠ‚ç‚¹ã€‚è¿™æ˜¯å› ä¸ºå³å­æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹æ˜¯å¤§äºå·¦å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹å€¼ä¸”å°äºå³å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹å€¼çš„èŠ‚ç‚¹ï¼Œå®ƒåœ¨æ›¿ä»£è¢«åˆ é™¤èŠ‚ç‚¹åèƒ½å¤Ÿä¿æŒæ ‘çš„å¹³è¡¡æ€§ã€‚

å‡½æ•° `_min_value_node` ç”¨äºæ‰¾åˆ°æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹ï¼Œå…¶å®ç°å¦‚ä¸‹ï¼š

```python
def _min_value_node(self, node):
    current = node
    while current.left:
        current = current.left
    return current
```

è¿™æ ·ï¼Œå½“æˆ‘ä»¬åˆ é™¤å¸¦æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬é€‰æ‹©å°†å³å­æ ‘ä¸­çš„æœ€å°å€¼èŠ‚ç‚¹çš„å€¼æ›¿æ¢åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹ä¸­ï¼Œç„¶åé€’å½’åœ°åœ¨å³å­æ ‘ä¸­åˆ é™¤è¿™ä¸ªæœ€å°å€¼èŠ‚ç‚¹ã€‚



### 8.3 æ˜ å°„å®ç°æ€»ç»“

ç”¨æ¥å®ç°æ˜ å°„è¿™ä¸€æŠ½è±¡æ•°æ®ç±»å‹çš„å¤šç§æ•°æ®ç»“æ„ï¼ŒåŒ…æ‹¬æœ‰åºåˆ—è¡¨ã€æ•£åˆ—è¡¨ã€äºŒå‰æœç´¢æ ‘ä»¥åŠAVLæ ‘ã€‚è¡¨6-1æ€»ç»“äº†æ¯ä¸ªæ•°æ®ç»“æ„çš„æ€§èƒ½ã€‚

è¡¨6-1 æ˜ å°„çš„ä¸åŒå®ç°é—´çš„æ€§èƒ½å¯¹æ¯”

| operation | Sorted List    | Hash Table | Binary Search Tree | AVL Tree       |
| :-------- | :------------- | :--------- | :----------------- | :------------- |
| put       | $O(n)$         | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |
| get       | $O(\log_2{n})$ | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |
| in        | $O(\log_2{n})$ | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |
| del       | $O(n)$         | $O(1)$     | $O(n)$             | $O(\log_2{n})$ |





## 9 å¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰

> é€šå¸¸æƒ…å†µä¸‹ï¼Œä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰å’Œå‰ç¼€æ ‘ï¼ˆTrie Treeï¼‰æ˜¯æ¯”è¾ƒå¸¸è§çš„åšæ³•ã€‚
>
> 1. **å¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰**ï¼šåœ¨å¹¶æŸ¥é›†ä¸­ï¼Œæ¯ä¸ªå…ƒç´ éƒ½å±äºä¸€ä¸ªé›†åˆï¼Œå¹¶ä¸”è¿™äº›é›†åˆä¹‹é—´æ˜¯ä¸ç›¸äº¤çš„ã€‚ä¸ºäº†é«˜æ•ˆåœ°å®ç°å¹¶æŸ¥é›†æ“ä½œï¼Œé€šå¸¸ä¼šä½¿ç”¨æ ‘å½¢ç»“æ„æ¥è¡¨ç¤ºé›†åˆä¹‹é—´çš„å…³ç³»ã€‚æ¯ä¸ªé›†åˆå¯ä»¥ç”¨ä¸€ä¸ªæ ‘è¡¨ç¤ºï¼Œå…¶ä¸­æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯é›†åˆçš„ä»£è¡¨å…ƒç´ ã€‚ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºè¿™ç§æ ‘å½¢ç»“æ„æ˜¯ä¸€ç§å¸¸è§çš„åšæ³•ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å…¶çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
>
> 2. **å‰ç¼€æ ‘ï¼ˆTrie Treeï¼‰**ï¼šå‰ç¼€æ ‘æ˜¯ä¸€ç§ç”¨äºå­˜å‚¨å­—ç¬¦ä¸²é›†åˆçš„æ•°æ®ç»“æ„ï¼Œé€šå¸¸ç”¨äºå¿«é€Ÿåœ°è¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…å’Œæœç´¢ã€‚åœ¨å‰ç¼€æ ‘ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ä¸ºäº†è¡¨ç¤ºå­—ç¬¦ä¸²çš„ç»“æ„ï¼Œé€šå¸¸ä¼šä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå‰ç¼€æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸€ä¸ªå­—ç¬¦ä»¥åŠæŒ‡å‘å­èŠ‚ç‚¹çš„æŒ‡é’ˆåˆ—è¡¨ã€‚
>
> ä½¿ç”¨é‚»æ¥è¡¨è¡¨ç¤ºå¹¶æŸ¥é›†å’Œå‰ç¼€æ ‘å¯ä»¥é«˜æ•ˆåœ°æ”¯æŒå„ç§æ“ä½œï¼Œå¦‚å¹¶æŸ¥é›†çš„åˆå¹¶å’ŒæŸ¥æ‰¾æ“ä½œï¼Œä»¥åŠå‰ç¼€æ ‘çš„æ’å…¥ã€æœç´¢å’Œåˆ é™¤æ“ä½œã€‚åŒæ—¶ï¼Œé‚»æ¥è¡¨ä¹Ÿèƒ½å¤Ÿæ¯”è¾ƒç›´è§‚åœ°è¡¨ç¤ºæ•°æ®ç»“æ„ä¹‹é—´çš„å…³ç³»ï¼Œä¾¿äºç†è§£å’Œå®ç°ã€‚



Disjoint Set (Union-Find Algorithm)

https://www.geeksforgeeks.org/introduction-to-disjoint-set-data-structure-or-union-find-algorithm/

**What is a Disjoint set data structure?**

> Two sets are called **disjoint sets** if they donâ€™t have any element in common, the intersection of sets is a null set.

A data structure that stores non overlapping or disjoint subset of elements is called disjoint set data structure. The disjoint set data structure supports following operations:

- Adding new sets to the disjoint set.
- Merging disjoint sets to a single disjoint set using **Union** operation.
- Finding representative of a disjoint set using **Find** operation.
- Check if two sets are disjoint or not. 

Consider a situation with a number of persons and the following tasks to be performed on them:

- Add a **new friendship relation**, i.e. a person x becomes the friend of another person y i.e adding new element to a set.
- Find whether individual **x is a friend of individual y** (direct or indirect friend)

**Examples:** 

> We are given 10 individuals say, a, b, c, d, e, f, g, h, i, j
>
> Following are relationships to be added:
> a <-> b  
> b <-> d
> c <-> f
> c <-> i
> j <-> e
> g <-> j
>
> Given queries like whether a is a friend of d or not. We basically need to create following 4 groups and maintain a quickly accessible connection among group items:
> G1 = {a, b, d}
> G2 = {c, f, i}
> G3 = {e, g, j}
> G4 = {h}



**Find whether x and y belong to the same group or not, i.e. to find if x and y are direct/indirect friends.**

Partitioning the individuals into different sets according to the groups in which they fall. This method is known as a **Disjoint set Union** which maintains a collection of **Disjoint sets** and each set is represented by one of its members.

**To answer the above question two key points to be considered are:**

- **How to Resolve sets?** Initially, all elements belong to different sets. After working on the given relations, we select a member as a **representative**. There can be many ways to select a representative, a simple one is to select with the biggest index.
- **Check if 2 persons are in the same group?** If representatives of two individuals are the same, then theyâ€™ll become friends.



**Data Structures used are:** 

**Array:** An array of integers is called **Parent[]**. If we are dealing with **N** items, iâ€™th element of the array represents the iâ€™th item. More precisely, the iâ€™th element of the Parent[] array is the parent of the iâ€™th item. These relationships create one or more virtual trees.

**Tree:** It is a **Disjoint set**. If two elements are in the same tree, then they are in the same **Disjoint set**. The root node (or the topmost node) of each tree is called the **representative** of the set. There is always a single **unique representative** of each set. A simple rule to identify a representative is if â€˜iâ€™ is the representative of a set, then **Parent[i] = i**. If i is not the representative of his set, then it can be found by traveling up the tree until we find the representative.



### 9.1 Operations on Disjoint Set

æ“ä½œåŒ…æ‹¬ Find å’Œ Unionã€‚

#### 9.1.1 Find

Can be implemented by recursively traversing the parent array until we hit a node that is the parent of itself.



```python
# Finds the representative of the set
# that i is an element of

def find(i):

	# If i is the parent of itself
	if (parent[i] == i):

		# Then i is the representative of
		# this set
		return i
	else:

		# Else if i is not the parent of
		# itself, then i is not the
		# representative of his set. So we
		# recursively call Find on its parent
		return find(parent[i])

# The code is contributed by Nidhi goel

```



**Time complexity**: This approach is inefficient and can take O(n) time in worst case.



#### 9.1.2 Union 

It takes **two elements** as input and finds the representatives of their sets using the **Find** operation, and finally puts either one of the trees (representing the set) under the root node of the other tree.

```python
# Unites the set that includes i
# and the set that includes j

def union(parent, rank, i, j):
	# Find the representatives
	# (or the root nodes) for the set
	# that includes i
	irep = find(parent, i)
	
	# And do the same for the set
	# that includes j
	jrep = find(parent, j)
	
	# Make the parent of iâ€™s representative
	# be jâ€™s representative effectively
	# moving all of iâ€™s set into jâ€™s set)
	
	parent[irep] = jrep

```

**Time complexity**: This approach is inefficient and could lead to tree of length O(n) in worst case.



### 9.2 Optimizations (Union by Rank/Size and Path Compression)

The efficiency depends heavily on which tree get attached to the other. There are 2 ways in which it can be done. <mark>First is Union by Rank, which considers height of the tree as the factor and Second is Union by Size, which considers size of the tree as the factor while attaching one tree to the other .</mark> This method along with Path Compression gives complexity of nearly constant time.



#### 9.2.1 Path Compression

Modifications to Find()):

It speeds up the data structure by **compressing the height** of the trees. It can be achieved by inserting a small caching mechanism into the **Find** operation. Take a look at the code for more details:

```python
# Finds the representative of the set that i
# is an element of.


def find(i):

	# If i is the parent of itself
	if Parent[i] == i:

		# Then i is the representative 
		return i
	else:

		# Recursively find the representative.
		result = find(Parent[i])

		# We cache the result by moving iâ€™s node 
		# directly under the representative of this
		# set
		Parent[i] = result
	
		# And then we return the result
		return result

# The code is contributed by Arushi Jindal. 

```



**Time Complexity**: O(log n) on average per call.



#### 9.2.2 Union by Rank

First of all, we need a new array of integers called **rank[]**. The size of this array is the same as the parent array **Parent[]**. If i is a representative of a set, **rank[i]** is the height of the tree representing the set. 
Now recall that in the Union operation, it doesnâ€™t matter which of the two trees is moved under the other. Now what we want to do is minimize the height of the resulting tree. If we are uniting two trees (or sets), letâ€™s call them left and right, then it all depends on the **rank of left** and the **rank of right**. 

- If the rank of **left** is less than the rank of **right**, then itâ€™s best to move **left under right**, because that wonâ€™t change the rank of right (while moving right under left would increase the height). In the same way, if the rank of right is less than the rank of left, then we should move right under left.
- If the ranks are equal, it doesnâ€™t matter which tree goes under the other, but the rank of the result will always be one greater than the rank of the trees.



#### 9.2.3 Path compression and union by rank

Below is the complete implementation of disjoint set with path compression and union by rank.

```python
class DisjSet:
	def __init__(self, n):
		# Constructor to create and initialize sets of n items
		self.rank = [1] * n
		self.parent = [i for i in range(n)]


	# Finds set of given item x
	def find(self, x):
		
		# Finds the representative of the set that x is an element of
		if (self.parent[x] != x):
			
			# if x is not the parent of itself
			# Then x is not the representative of its set
			self.parent[x] = self.find(self.parent[x])
			
			# so we recursively call Find on its parent
			# and move i's node directly under the
			# representative of this set

		return self.parent[x]


	# Do union of two sets represented by x and y.
	def Union(self, x, y):
		
		# Find current sets of x and y
		xset = self.find(x)
		yset = self.find(y)

		# If they are already in same set
		if xset == yset:
			return

		# Put smaller ranked item under
		# bigger ranked item if ranks are different
		if self.rank[xset] < self.rank[yset]:
			self.parent[xset] = yset

		elif self.rank[xset] > self.rank[yset]:
			self.parent[yset] = xset

		# If ranks are same, then move y under x (doesn't matter
    # which one goes where) and increment rank of x's tree
		else:
			self.parent[yset] = xset
			self.rank[xset] = self.rank[xset] + 1

# Driver code
obj = DisjSet(5)
obj.Union(0, 2)
obj.Union(4, 2)
obj.Union(3, 1)
if obj.find(4) == obj.find(0):
	print('Yes')
else:
	print('No')
if obj.find(1) == obj.find(0):
	print('Yes')
else:
	print('No')


"""
Yes
No
"""
```



**Time complexity**: O(n) for creating n single item sets . The two techniques -path compression with the union by rank/size, the time complexity will reach nearly constant time. It turns out, that the final[ amortized time complexity](https://www.geeksforgeeks.org/introduction-to-amortized-analysis/) is O(Î±(n)), where Î±(n) is the inverse Ackermann function, which grows very steadily (it does not even exceed for $n<10^{600}$  approximately).

**Space complexity:** O(n) because we need to store n elements in the Disjoint Set Data Structure.



#### 9.2.4 Union by Size

Again, we need a new array of integers called **size[]**. The size of this array is the same as the parent array **Parent[]**. If i is a representative of a set, **size[i]** is the number of the elements in the tree representing the set. 
Now we are uniting two trees (or sets), letâ€™s call them left and right, then in this case it all depends on the **size of left** and the **size of right** tree (or set).

- If the size of **left** is less than the size of **right**, then itâ€™s best to move **left under right** and increase size of right by size of left. In the same way, if the size of right is less than the size of left, then we should move right under left. and increase size of left by size of right.
- If the sizes are equal, it doesnâ€™t matter which tree goes under the other.

```python
class UnionFind:
	def __init__(self, n):
		self.Parent = list(range(n))
		self.Size = [1] * n

	# Function to find the representative (or the root node) for the set that includes i
	def find(self, i):
		if self.Parent[i] != i:
			# Path compression: Make the parent of i the root of the set
			self.Parent[i] = self.find(self.Parent[i])
		return self.Parent[i]

	# Unites the set that includes i and the set that includes j by size
	def unionBySize(self, i, j):
		# Find the representatives (or the root nodes) for the set that includes i
		irep = self.find(i)

		# And do the same for the set that includes j
		jrep = self.find(j)

		# Elements are in the same set, no need to unite anything.
		if irep == jrep:
			return

		# Get the size of iâ€™s tree
		isize = self.Size[irep]

		# Get the size of jâ€™s tree
		jsize = self.Size[jrep]

		# If iâ€™s size is less than jâ€™s size
		if isize < jsize:
			# Then move i under j
			self.Parent[irep] = jrep

			# Increment j's size by i's size
			self.Size[jrep] += self.Size[irep]
		# Else if jâ€™s size is less than iâ€™s size
		else:
			# Then move j under i
			self.Parent[jrep] = irep

			# Increment i's size by j's size
			self.Size[irep] += self.Size[jrep]

# Example usage
n = 5
unionFind = UnionFind(n)

# Perform union operations
unionFind.unionBySize(0, 1)
unionFind.unionBySize(2, 3)
unionFind.unionBySize(0, 4)

# Print the representative of each element after unions
for i in range(n):
	print("Element {}: Representative = {}".format(i, unionFind.find(i)))

# This code is contributed by Susobhan Akhuli

"""
Element 0: Representative = 0
Element 1: Representative = 0
Element 2: Representative = 2
Element 3: Representative = 2
Element 4: Representative = 0
"""
```



**Time complexity**: O(log n) without Path Compression.





### 9.3 ç¼–ç¨‹é¢˜ç›®

#### æ™´é—®9.6.1 å­¦æ ¡çš„ç­çº§ä¸ªæ•°ï¼ˆ1ï¼‰

https://sunnywhy.com/sfbj/9/6/360

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œå¹¶ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ï¼Œé—®æ€»å…±æœ‰å¤šå°‘ä¸ªç­çº§ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $mã€n (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n, a \ne b)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

**è¾“å‡º**

è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç­çº§ä¸ªæ•°ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 3
4 2
1 3
2 5
```

è¾“å‡º

```
2
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤å…±æœ‰ä¸¤ä¸ªç­çº§ã€‚



To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. The number of disjoint sets at the end will be the number of classes.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. For each student relationship, unite their sets using the union operation.
3. Count the number of unique parents. This will be the number of classes.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x: # å¦‚æœä¸æ˜¯æ ¹ç»“ç‚¹ï¼Œç»§ç»­å¾ªç¯
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))	# parent[i] == iï¼Œåˆ™è¯´æ˜å…ƒç´ iæ˜¯è¯¥é›†åˆçš„æ ¹ç»“ç‚¹

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

classes = set(find(x) for x in range(1, n + 1))
print(len(classes))
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, and then counts and prints the number of unique classes.





#### æ™´é—®9.6.2 å­¦æ ¡çš„ç­çº§äººæ•°ï¼ˆ2ï¼‰

https://sunnywhy.com/sfbj/9/6/361

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œå¹¶ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ï¼Œé—®æ€»å…±æœ‰å¤šå°‘ä¸ªç­çº§ï¼Œå¹¶æŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„äººæ•°ã€‚

è¾“å…¥

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $mã€n (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n, a \ne b)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

è¾“å‡º

ç¬¬ä¸€è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç­çº§ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œè‹¥å¹²ä¸ªæ•´æ•°ï¼ŒæŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„äººæ•°ã€‚æ•´æ•°ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 3
4 2
1 3
2 5
```

è¾“å‡º

```
2
3 2
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤å…±æœ‰ä¸¤ä¸ªç­çº§ï¼Œäººæ•°åˆ†åˆ«æ˜¯`3`å’Œ`2`ã€‚





To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. The number of disjoint sets at the end will be the number of classes. You can also maintain a count of the number of students in each class.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. Initialize an array `size` of size `n+1` where `size[i]` is initially `1`. This means each class initially has one student.
3. For each student relationship, unite their sets using the union operation and update the size of the new set.
4. Count the number of unique parents. This will be the number of classes.
5. Print the sizes of the classes in descending order.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x != root_y:
        parent[root_x] = root_y
        size[root_y] += size[root_x]

n, m = map(int, input().split())
parent = list(range(n + 1))
size = [1] * (n + 1)

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

#classes = [size[find(x)] for x in range(1, n + 1) if x == parent[x]]
classes = [size[x] for x in range(1, n + 1) if x == parent[x]]
print(len(classes))
print(' '.join(map(str, sorted(classes, reverse=True))))
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, counts and prints the number of unique classes, and prints the sizes of the classes in descending order.





#### æ™´é—®9.6.3 æ˜¯å¦ç›¸åŒç­çº§

https://sunnywhy.com/sfbj/9/6/362

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œå¹¶ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ã€‚ç„¶åç»™å‡º k ä¸ªæŸ¥è¯¢ï¼Œæ¯ä¸ªæŸ¥è¯¢è¯¢é—®ä¸¤ä¸ªå­¦ç”Ÿæ˜¯å¦åœ¨åŒä¸€ä¸ªç­çº§ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $nã€m (1 \le n \le 10^5, 1 \le m \le 10^5)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n, a \ne b)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç„¶åä¸€ä¸ªæ•´æ•° $k (1 \le k \le 10^3)$ï¼Œè¡¨ç¤ºæŸ¥è¯¢ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥ k è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n)$ï¼Œè¡¨ç¤ºè¯¢é—®ç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿæ˜¯å¦åœ¨åŒä¸€ä¸ªç­çº§ã€‚

**è¾“å‡º**

æ¯ä¸ªæŸ¥è¯¢è¾“å‡ºä¸€è¡Œï¼Œå¦‚æœåœ¨åŒä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆè¾“å‡º`Yes`ï¼Œå¦åˆ™è¾“å‡º`No`ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 3
4 2
1 3
2 5
2
4 5
1 2
```

è¾“å‡º

```
Yes
No
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤ç¼–å·`4`å’Œ`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`å’Œ`2`çš„å­¦ç”Ÿä¸åœ¨åŒä¸€ä¸ªç­çº§ã€‚





To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. For each query, you check if the two students are in the same set.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. For each student relationship, unite their sets using the union operation.
3. For each query, check if the two students are in the same set using the find operation.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

k = int(input())
for _ in range(k):
    a, b = map(int, input().split())
    if find(a) == find(b):
        print('Yes')
    else:
        print('No')
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, and then for each query, checks and prints whether the two students are in the same class.



#### æ™´é—®9.6.4 è¿·å®«è¿é€šæ€§

https://sunnywhy.com/sfbj/9/6/363

ç°æœ‰ä¸€ä¸ªè¿·å®«ï¼Œè¿·å®«ä¸­æœ‰ n ä¸ªæˆ¿é—´ï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œæˆ¿é—´ä¸æˆ¿é—´ä¹‹é—´å¯èƒ½è¿é€šã€‚å¦‚æœæˆ¿é—´`A`å’Œæˆ¿é—´`B`è¿é€šï¼Œæˆ¿é—´`B`å’Œæˆ¿é—´`C`è¿é€šï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°æˆ¿é—´`A`å’Œæˆ¿é—´`C`ä¹Ÿè¿é€šã€‚ç»™å®š m ç»„è¿é€šå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªæˆ¿é—´è¿é€šï¼‰ï¼Œé—®è¿·å®«ä¸­çš„æ‰€æœ‰æˆ¿é—´æ˜¯å¦è¿é€šã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•°$nã€m (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºæˆ¿é—´ä¸ªæ•°ã€è¿é€šå…³ç³»ä¸ªæ•°ï¼›

æ¥ä¸‹æ¥è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„æˆ¿é—´å’Œç¼–å·ä¸º`b`çš„æˆ¿é—´æ˜¯è¿é€šçš„ã€‚

**è¾“å‡º**

å¦‚æœæ‰€æœ‰æˆ¿é—´è¿é€šï¼Œé‚£ä¹ˆè¾“å‡º`Yes`ï¼Œå¦åˆ™è¾“å‡º`No`ã€‚

æ ·ä¾‹1

è¾“å…¥

```
5 4
4 2
1 3
2 5
1 5
```

è¾“å‡º

```
Yes
```

è§£é‡Š

æ‰€æœ‰æˆ¿é—´éƒ½è¿é€šï¼Œå› æ­¤è¾“å‡º`Yes`ã€‚

æ ·ä¾‹2

è¾“å…¥

```
5 3
4 2
1 3
2 5
```

è¾“å‡º

```
No
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„æˆ¿é—´äº’ç›¸è¿é€šï¼Œç¼–å·`1`ã€`3`çš„æˆ¿é—´äº’ç›¸è¿é€šï¼Œå› æ­¤æ²¡æœ‰å…¨éƒ¨äº’ç›¸è¿é€šï¼Œè¾“å‡º`No`ã€‚



To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each room is initially in its own set. When a connection between two rooms is given, you unite their sets. If at the end there is only one set, then all rooms are connected.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each room is in its own set.
2. For each connection, unite their sets using the union operation.
3. Check if all rooms are in the same set.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    parent[find(x)] = find(y)

n, m = map(int, input().split())
parent = list(range(n + 1))

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

sets = set(find(x) for x in range(1, n + 1))
if len(sets) == 1:
    print('Yes')
else:
    print('No')
```

This code reads the number of rooms and connections from the input, initializes each room to be in its own set, unites the sets of each pair of rooms that have a connection, and then checks and prints whether all rooms are in the same set.





#### æ™´é—®9.6.5 ç­çº§æœ€é«˜åˆ†

https://sunnywhy.com/sfbj/9/6/364

ç°æœ‰ä¸€ä¸ªå­¦æ ¡ï¼Œå­¦æ ¡ä¸­æœ‰è‹¥å¹²ä¸ªç­çº§ï¼Œæ¯ä¸ªç­çº§ä¸­æœ‰è‹¥å¹²ä¸ªå­¦ç”Ÿï¼Œæ¯ä¸ªå­¦ç”Ÿåªä¼šå­˜åœ¨äºä¸€ä¸ªç­çº§ä¸­ã€‚å¦‚æœå­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`B`å¤„äºä¸€ä¸ªç­çº§ï¼Œå­¦ç”Ÿ`B`å’Œå­¦ç”Ÿ`C`å¤„äºä¸€ä¸ªç­çº§ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å­¦ç”Ÿ`A`å’Œå­¦ç”Ÿ`C`ä¹Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

ç°å·²çŸ¥å­¦æ ¡ä¸­å…± n ä¸ªå­¦ç”Ÿï¼ˆç¼–å·ä¸ºä»`1`åˆ°`n`ï¼‰ï¼Œæ¯ä¸ªå­¦ç”Ÿæœ‰ä¸€ä¸ªè€ƒè¯•åˆ†æ•°ï¼Œå†ç»™å‡º m ç»„å­¦ç”Ÿå…³ç³»ï¼ˆæŒ‡å®šä¸¤ä¸ªå­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ï¼‰ï¼Œé—®æ€»å…±æœ‰å¤šå°‘ä¸ªç­çº§ï¼Œå¹¶æŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„æœ€é«˜è€ƒè¯•åˆ†æ•°ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•° $nã€m (1 \le n \le 100, 1 \le m \le 100)$ï¼Œåˆ†åˆ«è¡¨ç¤ºå­¦ç”Ÿä¸ªæ•°ã€å­¦ç”Ÿå…³ç³»ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œä¸ºç”¨ç©ºæ ¼éš”å¼€çš„ n ä¸ªæ•´æ•°ï¼ˆ$0 \le æ¯ä¸ªæ•´æ•° \le 100$ï¼‰ï¼Œè¡¨ç¤ºä¸ªå­¦ç”Ÿçš„è€ƒè¯•åˆ†æ•°ï¼›

æ¥ä¸‹æ¥ m è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° a å’Œ b $ (1 \le a \le n, 1 \le b \le n)$ï¼Œè¡¨ç¤ºç¼–å·ä¸º`a`çš„å­¦ç”Ÿå’Œç¼–å·ä¸º`b`çš„å­¦ç”Ÿå¤„äºä¸€ä¸ªç­çº§ã€‚

**è¾“å‡º**

ç¬¬ä¸€è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç­çº§ä¸ªæ•°ï¼›

ç¬¬äºŒè¡Œè‹¥å¹²ä¸ªæ•´æ•°ï¼ŒæŒ‰é™åºç»™å‡ºæ¯ä¸ªç­çº§çš„æœ€é«˜è€ƒè¯•åˆ†æ•°ã€‚æ•´æ•°ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«ä¸å…è®¸æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚

æ ·ä¾‹1

è¾“å…¥



```
5 3
88 90 86 92 95
4 2
1 3
2 5
```

è¾“å‡º

```
2
95 88
```

è§£é‡Š

ç¼–å·`2`ã€`4`ã€`5`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œç¼–å·`1`ã€`3`çš„å­¦ç”Ÿåœ¨åŒä¸€ä¸ªç­çº§ï¼Œå› æ­¤å…±æœ‰ä¸¤ä¸ªç­çº§ï¼Œæœ€é«˜åˆ†æ•°åˆ†åˆ«æ˜¯ç¼–å·`1`çš„å­¦ç”Ÿçš„`88`åˆ†ã€ç¼–å·`5`çš„å­¦ç”Ÿçš„`95`åˆ†ã€‚



To solve this problem, you can use the concept of disjoint sets (also known as union-find). Each student is initially in their own set (or class). When a relationship between two students is given, you unite their sets. The number of disjoint sets at the end will be the number of classes. You can also maintain a list of scores for each class and find the maximum score for each class.

Here is a step-by-step plan:

1. Initialize an array `parent` of size `n+1` where `parent[i]` is initially `i`. This means each student is in their own class.
2. Initialize an array `scores` of size `n+1` to store the scores of each student.
3. For each student relationship, unite their sets using the union operation.
4. For each class, find the maximum score.
5. Count the number of unique parents. This will be the number of classes.
6. Print the maximum scores of the classes in descending order.

Here is the Python code that implements this plan:

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x != root_y:
        parent[root_x] = root_y
        scores[root_y] = max(scores[root_y], scores[root_x])

n, m = map(int, input().split())
parent = list(range(n + 1))
scores = list(map(int, input().split()))
scores.insert(0, 0)  # to make the scores 1-indexed

for _ in range(m):
    a, b = map(int, input().split())
    union(a, b)

classes_scores = [scores[find(x)] for x in range(1, n + 1) if x == parent[x]]
print(len(classes_scores))
print(' '.join(map(str, sorted(classes_scores, reverse=True))))
```

This code reads the number of students and relationships from the input, initializes each student to be in their own class, unites the classes of each pair of students that have a relationship, finds the maximum score for each class, counts and prints the number of unique classes, and prints the maximum scores of the classes in descending order.





#### T01182: é£Ÿç‰©é“¾

å¹¶æŸ¥é›†, http://cs101.openjudge.cn/practice/01182

åŠ¨ç‰©ç‹å›½ä¸­æœ‰ä¸‰ç±»åŠ¨ç‰©A,B,Cï¼Œè¿™ä¸‰ç±»åŠ¨ç‰©çš„é£Ÿç‰©é“¾æ„æˆäº†æœ‰è¶£çš„ç¯å½¢ã€‚AåƒBï¼Œ BåƒCï¼ŒCåƒAã€‚
ç°æœ‰Nä¸ªåŠ¨ç‰©ï¼Œä»¥1ï¼Nç¼–å·ã€‚æ¯ä¸ªåŠ¨ç‰©éƒ½æ˜¯A,B,Cä¸­çš„ä¸€ç§ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸çŸ¥é“å®ƒåˆ°åº•æ˜¯å“ªä¸€ç§ã€‚
æœ‰äººç”¨ä¸¤ç§è¯´æ³•å¯¹è¿™Nä¸ªåŠ¨ç‰©æ‰€æ„æˆçš„é£Ÿç‰©é“¾å…³ç³»è¿›è¡Œæè¿°ï¼š
ç¬¬ä¸€ç§è¯´æ³•æ˜¯"1 X Y"ï¼Œè¡¨ç¤ºXå’ŒYæ˜¯åŒç±»ã€‚
ç¬¬äºŒç§è¯´æ³•æ˜¯"2 X Y"ï¼Œè¡¨ç¤ºXåƒYã€‚
æ­¤äººå¯¹Nä¸ªåŠ¨ç‰©ï¼Œç”¨ä¸Šè¿°ä¸¤ç§è¯´æ³•ï¼Œä¸€å¥æ¥ä¸€å¥åœ°è¯´å‡ºKå¥è¯ï¼Œè¿™Kå¥è¯æœ‰çš„æ˜¯çœŸçš„ï¼Œæœ‰çš„æ˜¯å‡çš„ã€‚å½“ä¸€å¥è¯æ»¡è¶³ä¸‹åˆ—ä¸‰æ¡ä¹‹ä¸€æ—¶ï¼Œè¿™å¥è¯å°±æ˜¯å‡è¯ï¼Œå¦åˆ™å°±æ˜¯çœŸè¯ã€‚
1ï¼‰ å½“å‰çš„è¯ä¸å‰é¢çš„æŸäº›çœŸçš„è¯å†²çªï¼Œå°±æ˜¯å‡è¯ï¼›
2ï¼‰ å½“å‰çš„è¯ä¸­Xæˆ–Yæ¯”Nå¤§ï¼Œå°±æ˜¯å‡è¯ï¼›
3ï¼‰ å½“å‰çš„è¯è¡¨ç¤ºXåƒXï¼Œå°±æ˜¯å‡è¯ã€‚
ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ç»™å®šçš„Nï¼ˆ1 <= N <= 50,000ï¼‰å’ŒKå¥è¯ï¼ˆ0 <= K <= 100,000ï¼‰ï¼Œè¾“å‡ºå‡è¯çš„æ€»æ•°ã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ•´æ•°Nå’ŒKï¼Œä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚
ä»¥ä¸‹Kè¡Œæ¯è¡Œæ˜¯ä¸‰ä¸ªæ­£æ•´æ•° Dï¼ŒXï¼ŒYï¼Œä¸¤æ•°ä¹‹é—´ç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œå…¶ä¸­Dè¡¨ç¤ºè¯´æ³•çš„ç§ç±»ã€‚
è‹¥D=1ï¼Œåˆ™è¡¨ç¤ºXå’ŒYæ˜¯åŒç±»ã€‚
è‹¥D=2ï¼Œåˆ™è¡¨ç¤ºXåƒYã€‚

**è¾“å‡º**

åªæœ‰ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå‡è¯çš„æ•°ç›®ã€‚

æ ·ä¾‹è¾“å…¥

```
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
```

æ ·ä¾‹è¾“å‡º

```
3
```

æ¥æº: Noi 01



```python
class DisjointSet:
    def __init__(self, n):
        #è®¾[1,n] åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n+1,2*n]è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n+1,3*n]è¡¨ç¤ºåƒxçš„åŠ¨ç‰©ã€‚
        self.parent = [i for i in range(3 * n + 1)] # æ¯ä¸ªåŠ¨ç‰©æœ‰ä¸‰ç§å¯èƒ½çš„ç±»å‹ï¼Œç”¨ 3 * n æ¥è¡¨ç¤ºæ¯ç§ç±»å‹çš„å¹¶æŸ¥é›†
        self.rank = [0] * (3 * n + 1)

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        pu, pv = self.find(u), self.find(v)
        if pu == pv:
            return False
        if self.rank[pu] > self.rank[pv]:
            self.parent[pv] = pu
        elif self.rank[pu] < self.rank[pv]:
            self.parent[pu] = pv
        else:
            self.parent[pv] = pu
            self.rank[pu] += 1
        return True


def is_valid(n, k, statements):
    dsu = DisjointSet(n)

    def find_disjoint_set(x):
        if x > n:
            return False
        return True

    false_count = 0
    for d, x, y in statements:
        if not find_disjoint_set(x) or not find_disjoint_set(y):
            false_count += 1
            continue
        if d == 1:  # X and Y are of the same type
            if dsu.find(x) == dsu.find(y + n) or dsu.find(x) == dsu.find(y + 2 * n):
                false_count += 1
            else:
                dsu.union(x, y)
                dsu.union(x + n, y + n)
                dsu.union(x + 2 * n, y + 2 * n)
        else:  # X eats Y
            if dsu.find(x) == dsu.find(y) or dsu.find(x + 2*n) == dsu.find(y):
                false_count += 1
            else: #[1,n] åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n+1,2*n]è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n+1,3*n]è¡¨ç¤ºåƒxçš„åŠ¨ç‰©
                dsu.union(x + n, y)
                dsu.union(x, y + 2 * n)
                dsu.union(x + 2 * n, y + n)

    return false_count


if __name__ == "__main__":
    N, K = map(int, input().split())
    statements = []
    for _ in range(K):
        D, X, Y = map(int, input().split())
        statements.append((D, X, Y))
    result = is_valid(N, K, statements)
    print(result)

```



ã€ŠæŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›ï¼ˆç¬¬2ç‰ˆï¼‰ã€‹çš„2.4.4å¹¶æŸ¥é›†ï¼Œä¹Ÿæœ‰è®²åˆ°ã€‚

```python
# å¹¶æŸ¥é›†ï¼Œhttps://zhuanlan.zhihu.com/p/93647900/
'''
æˆ‘ä»¬è®¾[0,n)åŒºé—´è¡¨ç¤ºåŒç±»ï¼Œ[n,2*n)åŒºé—´è¡¨ç¤ºxåƒçš„åŠ¨ç‰©ï¼Œ[2*n,3*n)è¡¨ç¤ºåƒxçš„åŠ¨ç‰©ã€‚

å¦‚æœæ˜¯å…³ç³»1ï¼š
ã€€ã€€å°†yå’Œxåˆå¹¶ã€‚å°†yåƒçš„ä¸xåƒçš„åˆå¹¶ã€‚å°†åƒyçš„å’Œåƒxçš„åˆå¹¶ã€‚
å¦‚æœæ˜¯å…³ç³»2ï¼š
ã€€ã€€å°†yå’Œxåƒçš„åˆå¹¶ã€‚å°†åƒyçš„ä¸xåˆå¹¶ã€‚å°†yåƒçš„ä¸åƒxçš„åˆå¹¶ã€‚
åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/qq_34594236/article/details/72587829
'''
# p = [0]*150001

def find(x):	# å¹¶æŸ¥é›†æŸ¥è¯¢
    if p[x] == x:
        return x
    else:
        p[x] = find(p[x])	# çˆ¶èŠ‚ç‚¹è®¾ä¸ºæ ¹èŠ‚ç‚¹ã€‚ç›®çš„æ˜¯è·¯å¾„å‹ç¼©ã€‚
        return p[x]

n,k = map(int, input().split())

p = [0]*(3*n + 1)
for i in range(3*n+1):	#å¹¶æŸ¥é›†åˆå§‹åŒ–
    p[i] = i

ans = 0
for _ in range(k):
    a,x,y = map(int, input().split())
    if x>n or y>n:
        ans += 1; continue
    
    if a==1:
        if find(x+n)==find(y) or find(y+n)==find(x):
            ans += 1; continue
        
        # åˆå¹¶
        p[find(x)] = find(y)				
        p[find(x+n)] = find(y+n)
        p[find(x+2*n)] = find(y+2*n)
    else:
        if find(x)==find(y) or find(y+n)==find(x):
            ans += 1; continue
        p[find(x+n)] = find(y)
        p[find(y+2*n)] = find(x)
        p[find(x+2*n)] = find(y+n)

print(ans)
```



# é™„å½•

## A æ ‘çŠ¶æ•°ç»„ï¼ˆBinary Indexed Treeï¼‰

æ ‘çŠ¶æ•°ç»„æˆ–äºŒå‰ç´¢å¼•æ ‘ï¼ˆè‹±è¯­ï¼šBinary Indexed Treeï¼‰ï¼Œåˆä»¥å…¶å‘æ˜è€…å‘½åä¸ºFenwickæ ‘ï¼Œæœ€æ—©ç”±Peter M. Fenwickäº1994å¹´ä»¥A New Data Structure for Cumulative Frequency Tablesä¸ºé¢˜å‘è¡¨ã€‚å…¶åˆè¡·æ˜¯è§£å†³æ•°æ®å‹ç¼©é‡Œçš„ç´¯ç§¯é¢‘ç‡ï¼ˆCumulative Frequencyï¼‰çš„è®¡ç®—é—®é¢˜ï¼Œç°å¤šç”¨äºé«˜æ•ˆè®¡ç®—æ•°åˆ—çš„<mark>å‰ç¼€å’Œï¼Œ åŒºé—´å’Œ</mark>ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœåœ¨æŸ¥è¯¢çš„è¿‡ç¨‹ä¸­å…ƒç´ å¯èƒ½å‘ç”Ÿæ”¹å˜ï¼ˆä¾‹å¦‚æ’å…¥ã€ä¿®æ”¹æˆ–åˆ é™¤ï¼‰ï¼Œå°±ç§°è¿™ç§æŸ¥è¯¢ä¸º<mark>åœ¨çº¿æŸ¥è¯¢</mark>;å¦‚æœåœ¨æŸ¥è¯¢è¿‡ç¨‹ä¸­å…ƒç´ ä¸å‘ç”Ÿæ”¹å˜ï¼Œå°±ç§°ä¸º**ç¦»çº¿æŸ¥è¯¢**ã€‚



> äºŒå‰ç´¢å¼•æ ‘ï¼ˆæ ‘çŠ¶æ•°ç»„ï¼‰ç”¨äºå¤„ç†å¯¹å›ºå®šå¤§å°çš„æ•°ç»„è¿›è¡Œä»¥ä¸‹å¤šç§æ“ä½œçš„è¿™ç±»é—®é¢˜ã€‚
>
> - å‰ç¼€æ“ä½œï¼ˆæ±‚å’Œã€æ±‚ç§¯ã€å¼‚æˆ–ã€æŒ‰ä½æˆ–ç­‰ï¼‰ã€‚æ³¨æ„ï¼ŒåŒºé—´æ“ä½œä¹Ÿå¯ä»¥é€šè¿‡å‰ç¼€æ¥è§£å†³ã€‚ä¾‹å¦‚ï¼Œä»ç´¢å¼•Låˆ°Rçš„åŒºé—´å’Œç­‰äºåˆ°Rï¼ˆåŒ…å«Rï¼‰çš„å‰ç¼€å’Œå‡å»åˆ°L - 1çš„å‰ç¼€å’Œã€‚
> - æ›´æ–°æ•°ç»„ä¸­çš„ä¸€ä¸ªå…ƒç´ 
>
> è¿™ä¸¤ç§æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å‡ä¸º$O(logN)$ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬éœ€è¦$O(NlogN)$çš„é¢„å¤„ç†æ—¶é—´å’Œ$O(N)$çš„è¾…åŠ©ç©ºé—´ã€‚
>
> 
>
> è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹é—®é¢˜æ¥ç†è§£äºŒå‰ç´¢å¼•æ ‘ï¼ˆBinary Indexed Tree, BITï¼‰ï¼š
> æˆ‘ä»¬æœ‰ä¸€ä¸ªæ•°ç»„ $arr[0 . . . n-1]$ã€‚æˆ‘ä»¬å¸Œæœ›å®ç°ä¸¤ä¸ªæ“ä½œï¼š
>
> 1. è®¡ç®—å‰iä¸ªå…ƒç´ çš„å’Œã€‚
> 2. ä¿®æ”¹æ•°ç»„ä¸­æŒ‡å®šä½ç½®çš„å€¼ï¼Œå³è®¾ç½® $arr[i] = x$ï¼Œå…¶ä¸­ $0 \leq i \leq n-1$ã€‚
>
> ä¸€ä¸ªç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯ä» 0 åˆ° i-1 éå†å¹¶è®¡ç®—è¿™äº›å…ƒç´ çš„æ€»å’Œã€‚è¦æ›´æ–°ä¸€ä¸ªå€¼ï¼Œåªéœ€æ‰§è¡Œ $arr[i] = x$ã€‚ç¬¬ä¸€ä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(N)$ï¼Œè€Œç¬¬äºŒä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(1)$ã€‚å¦ä¸€ç§ç®€å•çš„è§£å†³æ–¹æ¡ˆæ˜¯åˆ›å»ºä¸€ä¸ªé¢å¤–çš„æ•°ç»„ï¼Œå¹¶åœ¨è¿™ä¸ªæ–°æ•°ç»„çš„ç¬¬iä¸ªä½ç½®å­˜å‚¨å‰iä¸ªå…ƒç´ çš„æ€»å’Œã€‚è¿™æ ·ï¼Œç»™å®šèŒƒå›´çš„å’Œå¯ä»¥åœ¨$O(1)$æ—¶é—´å†…è®¡ç®—å‡ºæ¥ï¼Œä½†æ˜¯æ›´æ–°æ“ä½œç°åœ¨éœ€è¦$O(N)$æ—¶é—´ã€‚å½“æŸ¥è¯¢æ“ä½œéå¸¸å¤šè€Œæ›´æ–°æ“ä½œéå¸¸å°‘æ—¶ï¼Œè¿™ç§æ–¹æ³•è¡¨ç°è‰¯å¥½ã€‚
>
> **æˆ‘ä»¬èƒ½å¦åœ¨$O(log N)$æ—¶é—´å†…åŒæ—¶å®ŒæˆæŸ¥è¯¢å’Œæ›´æ–°æ“ä½œå‘¢ï¼Ÿ**
> ä¸€ç§é«˜æ•ˆçš„è§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨æ®µæ ‘ï¼ˆSegment Treeï¼‰ï¼Œå®ƒèƒ½å¤Ÿåœ¨$O(logN)$æ—¶é—´å†…å®Œæˆè¿™ä¸¤ä¸ªæ“ä½œã€‚
> å¦ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯äºŒå‰ç´¢å¼•æ ‘ï¼ˆBinary Indexed Treeï¼Œä¹Ÿç§°ä½œFenwick Treeï¼‰ï¼ŒåŒæ ·èƒ½å¤Ÿä»¥$O(logN)$çš„æ—¶é—´å¤æ‚åº¦å®ŒæˆæŸ¥è¯¢å’Œæ›´æ–°æ“ä½œã€‚ä¸æ®µæ ‘ç›¸æ¯”ï¼ŒäºŒå‰ç´¢å¼•æ ‘æ‰€éœ€çš„ç©ºé—´æ›´å°‘ï¼Œä¸”å®ç°èµ·æ¥æ›´åŠ ç®€å•ã€‚



### lowbit è¿ç®—

äºŒè¿›åˆ¶ä¸­ä¸€ä¸ªç»å…¸åº”ç”¨æ˜¯ lowbit è¿ç®—ï¼Œå³ `lowbit(x) = x & (-x)`ã€‚

**æ•´æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºå¸¸ç”¨çš„æ–¹å¼ä¹‹ä¸€æ˜¯ä½¿ç”¨è¡¥ç **

è¡¥ç æ˜¯ä¸€ç§è¡¨ç¤ºæœ‰ç¬¦å·æ•´æ•°çš„æ–¹æ³•ï¼Œå®ƒå°†è´Ÿæ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºè½¬æ¢ä¸ºæ­£æ•°çš„äºŒè¿›åˆ¶è¡¨ç¤ºã€‚è¡¥ç çš„ä¼˜åŠ¿åœ¨äºå¯ä»¥ä½¿ç”¨ç›¸åŒçš„ç®—æœ¯è¿ç®—è§„åˆ™æ¥å¤„ç†æ­£æ•°å’Œè´Ÿæ•°ï¼Œè€Œä¸éœ€è¦ç‰¹æ®Šçš„æ“ä½œã€‚

åœ¨è¡¥ç è¡¨ç¤ºä¸­ï¼Œæœ€é«˜ä½ç”¨äºè¡¨ç¤ºç¬¦å·ä½ï¼Œ0è¡¨ç¤ºæ­£æ•°ï¼Œ1è¡¨ç¤ºè´Ÿæ•°ã€‚å…¶ä»–ä½è¡¨ç¤ºæ•°å€¼éƒ¨åˆ†ã€‚

å…·ä½“å°†ä¸€ä¸ªæ•´æ•°è½¬æ¢ä¸ºè¡¥ç çš„æ­¥éª¤å¦‚ä¸‹ï¼š

1. å¦‚æœæ•´æ•°æ˜¯æ­£æ•°ï¼Œåˆ™è¡¥ç ç­‰äºäºŒè¿›åˆ¶è¡¨ç¤ºæœ¬èº«ã€‚
2. å¦‚æœæ•´æ•°æ˜¯è´Ÿæ•°ï¼Œåˆ™éœ€è¦å…ˆå°†å…¶ç»å¯¹å€¼è½¬æ¢ä¸ºäºŒè¿›åˆ¶ï¼Œç„¶åå–åï¼Œæœ€ååŠ 1ã€‚ç­‰ä»·äº<mark>æŠŠäºŒè¿›åˆ¶æœ€å³è¾¹çš„1çš„å·¦è¾¹çš„æ¯ä¸€ä½éƒ½å–å</mark>ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾è¦å°† -12 è½¬æ¢ä¸ºè¡¥ç ï¼š

1. 12çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸º00001100ã€‚

2. å°†å…¶å–åå¾—åˆ°11110011ã€‚

3. åŠ 1å¾—åˆ°11110100ï¼Œè¿™å°±æ˜¯ -12 çš„è¡¥ç è¡¨ç¤ºã€‚


é€šè¿‡`lowbit(x) = x & (-x)`å°±æ˜¯å– x çš„äºŒè¿›åˆ¶æœ€å³è¾¹çš„1å’Œå®ƒå³è¾¹æ‰€æœ‰çš„0ï¼Œå› æ­¤å®ƒä¸€å®šæ˜¯2çš„å¹‚æ¬¡ï¼Œå³1ã€2ã€4ã€8ç­‰ã€‚

å¯¹ x = 12 = $(00001100)_2$ï¼Œæœ‰ -x = $(11110100)_2$ ï¼Œx & (-x) = 4

å¯¹ x= 6 = $(110)_2$ï¼Œæœ‰ -x = $(010)_2$ï¼Œx & (-x) = 2



### è¡¨ç¤ºæ–¹å¼

æ ‘çŠ¶æ•°ç»„ï¼ˆBinary Indexed Treeï¼ŒBITï¼‰ç”¨æ•°ç»„å½¢å¼è¡¨ç¤ºã€‚å®ƒå…¶å®ä»ç„¶æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå¹¶ä¸”ä¸ sum æ•°ç»„ç±»ä¼¼ï¼Œæ˜¯ä¸€ä¸ªç”¨æ¥è®°å½•å’Œçš„æ•°ç»„ï¼Œåªä¸è¿‡å®ƒå­˜æ”¾çš„ä¸æ˜¯å‰ i ä¸ªæ•´æ•°ä¹‹å’Œï¼Œè€Œæ˜¯åœ¨ <mark>i å·ä½ä¹‹å‰ï¼ˆå«iå·ä½ï¼‰lowbit(i) ä¸ªæ•´æ•°ä¹‹å’Œ</mark>ã€‚æ ‘çŠ¶æ•°ç»„çš„å¤§å°ç­‰äºè¾“å…¥æ•°ç»„çš„å¤§å°ï¼Œè®°ä¸ºnã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œä¸ºäº†ä¾¿äºå®ç°ï¼Œä½¿ç”¨n+1çš„å¤§å°ã€‚

å¦‚ä¸‹å›¾ æ‰€ç¤ºï¼Œæ•°ç»„Aæ˜¯åŸå§‹æ•°ç»„ï¼Œæœ‰ A[1]~ A[16]å…± 16ä¸ªå…ƒç´ ï¼›æ•°ç»„ Cæ˜¯æ ‘çŠ¶æ•°ç»„ï¼Œå…¶ä¸­ C[i]å­˜æ”¾æ•°ç»„ A ä¸­iå·ä½ä¹‹å‰ lowbit(i) ä¸ªå…ƒç´ ä¹‹å’Œã€‚æ˜¾ç„¶ï¼Œ<mark>C[i]çš„è¦†ç›–é•¿åº¦æ˜¯ lowbit(i)ï¼ˆä¹Ÿå¯ä»¥ç†è§£æˆç®¡è¾–èŒƒå›´ï¼‰</mark>ï¼Œå®ƒæ˜¯2çš„å¹‚æ¬¡ï¼Œå³ 1ã€2ã€4ã€8ç­‰ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ ‘çŠ¶æ•°ç»„ä»æ—§æ˜¯ä¸€ä¸ªå¹³å¦çš„æ•°ç»„ï¼Œç”»æˆæ ‘å½¢æ˜¯ä¸ºäº†è®©å­˜å‚¨çš„å…ƒç´ æ›´å®¹æ˜“è§‚å¯Ÿã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250320134426632.png" alt="image-20250320134426632" style="zoom: 67%;" />

<center>å›¾ æ ‘çŠ¶æ•°ç»„å®šä¹‰å›¾</center>



```
C[1] = A[1]  													(é•¿åº¦ä¸º lowbit(1) = 1) 
C[2] = A[1] + A[2]  									(é•¿åº¦ä¸º lowbit(2) = 2) 
C[3] = A[3]  													(é•¿åº¦ä¸º lowbit(3) = 1) 
C[4] = A[1] + A[2] + A[3] + A[4]  		(é•¿åº¦ä¸º lowbit(4) = 4) 
C[5] = A[5]  													(é•¿åº¦ä¸º lowbit(5) = 1) 
C[6] = A[5] + A[6]  									(é•¿åº¦ä¸º lowbit(6) = 2) 
C[7] = A[7]  													(é•¿åº¦ä¸º lowbit(7) = 1) 
C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]  (é•¿åº¦ä¸º lowbit(8) = 8) 
```

<mark>æ ‘çŠ¶æ•°ç»„çš„å®šä¹‰éå¸¸é‡è¦ï¼Œç‰¹åˆ«æ˜¯â€œC[i]çš„è¦†ç›–é•¿åº¦æ˜¯ lowbit(i)â€è¿™ç‚¹ï¼›å¦å¤–ï¼Œæ ‘çŠ¶æ•°ç»„çš„ä¸‹æ ‡å¿…é¡»ä»1å¼€å§‹</mark>ã€‚æ¥ä¸‹æ¥æ€è€ƒä¸€ä¸‹ï¼Œåœ¨è¿™æ ·çš„å®šä¹‰ä¸‹ï¼Œ
æ€æ ·è§£å†³ä¸‹é¢ä¸¤ä¸ªé—®é¢˜ï¼š

â‘  è®¾è®¡å‡½æ•° get_sum(x)ï¼Œè¿”å›å‰xä¸ªæ•°ä¹‹å’Œ A[1]+...+ A[x]ã€‚

â‘¡ è®¾è®¡å‡½æ•° update_bit(x,v)ï¼Œå®ç°å°†ç¬¬xä¸ªæ•°åŠ ä¸Šä¸€ä¸ªæ•°vçš„åŠŸèƒ½ï¼Œå³ A[x]+= vã€‚

å…ˆæ¥çœ‹ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œå³å¦‚ä½•è®¾è®¡å‡½æ•° get_sum(x)ï¼Œè¿”å›å‰xä¸ªæ•°ä¹‹å’Œã€‚ä¸å¦¨å…ˆçœ‹ä¸ªä¾‹å­ã€‚å‡è®¾æƒ³è¦æŸ¥è¯¢ A[1]+â€¦+A[14]ï¼Œé‚£ä¹ˆä»æ ‘çŠ¶æ•°ç»„çš„å®šä¹‰å‡ºå‘ï¼Œå®ƒå®é™…æ˜¯ä»€ä¹ˆä¸œè¥¿å‘¢? å›åˆ°ä¸Šå›¾ï¼Œå¾ˆå®¹æ˜“å‘ç° A[1]+â€¦+A[14] = C[8]+C[12]+ C[14]ã€‚åˆæ¯”å¦‚è¦æŸ»è¯¢ A[1]+â€¦A[11]ï¼Œä»å›¾ä¸­åŒæ ·å¯ä»¥å¾—åˆ° A[1]+â€¦+A[11] = C[8]+C[10]+ C[11]ã€‚é‚£ä¹ˆæ€æ ·çŸ¥é“ A[1]+â€¦+ A[x]å¯¹åº”çš„æ˜¯æ ‘çŠ¶æ•°ç»„ä¸­çš„å“ªäº›é¡¹å‘¢ï¼Ÿäº‹å®ä¸Šè¿™å¾ˆç®€å•ã€‚è®° SUM(1,x) = A[1]+â€¦â€¦+A[x]ï¼Œç”±äº C[x]çš„è¦†ç›–é•¿åº¦æ˜¯ lowbit(x)ï¼Œå› æ­¤

C[x] = A[x-lowbit(x)+1]+...+ A[x]

äºæ˜¯å¯ä»¥å¾—åˆ°

```
SUM(1,x) = A[1] +Â·Â·Â·+ A[x]
				=A[1] +Â·Â·Â·+ A[x-lowbit(x)] + A[x-lowbit(x)+1] +Â·Â·Â·+ A[x]
				=SUM(1,x-lowbit(x)) + C[x]
```

è¿™æ ·å°±æŠŠ SUM(1,x)è½¬æ¢ä¸º SUM(1,x-lowbit(x))äº†ã€‚

æ¥ç€å°±èƒ½å†™å‡º get_sum å‡½æ•°äº†ï¼Œå…¶ä¸­BITTreeæ˜¯æ ‘çŠ¶æ•°ç»„ã€‚

```python
def bit_sum(BIT, i):
    s = 0
    i += 1  # index in BIT[] is 1 more than the index in arr[]

    while i > 0:  # Traverse ancestors of BIT[index]
        s += BIT[i]
        i -= i & (-i)  # Move index to parent node
    return s
```

ç”±äº lowbit(i)çš„ä½œç”¨æ˜¯å®šä½içš„äºŒè¿›åˆ¶ä¸­æœ€å³è¾¹çš„1ï¼Œå› æ­¤ `i = i- lowbit(i)` äº‹å®ä¸Šæ˜¯ä¸æ–­æŠŠiçš„äºŒè¿›åˆ¶ä¸­æœ€å³è¾¹çš„1ç½®ä¸º0çš„è¿‡ç¨‹ã€‚æ‰€ä»¥ get_sum å‡½æ•°çš„ for å¾ªç¯æ‰§è¡Œæ¬¡æ•°ä¸ºxçš„äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ã€‚ä¸€ä¸ªæ•°nçš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­è®¾ç½®ä½çš„æ•°é‡æ˜¯O(logn)ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œget_sum å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(logN)$ã€‚ä»å¦ä¸€ä¸ªè§’åº¦ç†è§£,ç»“åˆå›¾ä¼šå‘ç°ï¼Œget_sum å‡½æ•°çš„è¿‡ç¨‹å®é™…ä¸Šæ˜¯åœ¨æ²¿ç€ä¸€æ¡ä¸æ–­å·¦ä¸Šçš„è·¯å¾„è¡Œè¿›ï¼ˆå¯ä»¥æƒ³ä¸€æƒ³ get_sum(14)è·Ÿ get_sum(11)çš„è¿‡ç¨‹ï¼‰ã€‚äºæ˜¯ç”±äºâ€œæ ‘â€é«˜æ˜¯ $O(logN)$çº§åˆ«,å› æ­¤å¯ä»¥åŒæ ·å¾—åˆ° get_sum å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $O(logN)$ã€‚å¦å¤–ï¼Œ<mark>å¦‚æœè¦æ±‚æ•°ç»„ä¸‹æ ‡åœ¨åŒºé—´[x,y]å†…çš„æ•°ä¹‹å’Œï¼Œå³ A[x] + A[x+1] +â€¦+ A[y]ï¼Œå¯ä»¥è½¬æ¢æˆ get_sum(y) - get_sum(x-1)æ¥è§£å†³ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„æŠ€å·§</mark>ã€‚



æ¥ç€æ¥çœ‹ç¬¬äºŒä¸ªé—®é¢˜ï¼Œå³å¦‚ä½•è®¾è®¡å‡½æ•° update(x,v)ï¼Œå®ç°å°†ç¬¬xä¸ªæ•°åŠ ä¸Šä¸€ä¸ªæ•°vçš„åŠŸ
èƒ½ã€‚
æ¥çœ‹ä¸¤ä¸ªä¾‹å­ã€‚å‡å¦‚è¦è®© A[6]åŠ ä¸Šä¸€ä¸ªæ•° vï¼Œé‚£ä¹ˆå°±è¦å¯»æ‰¾æ ‘çŠ¶æ•°ç»„Cä¸­èƒ½è¦†ç›–äº† A[6]çš„å…ƒç´ ï¼Œè®©å®ƒä»¬éƒ½åŠ ä¸Š vã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœè¦è®© A[6]åŠ ä¸Š vï¼Œå®é™…ä¸Šæ˜¯è¦è®©C[6]ã€C[8]ã€C[16]éƒ½åŠ ä¸Š vã€‚åŒæ ·ï¼Œå¦‚æœè¦å°† A[9]åŠ ä¸Šä¸€ä¸ªæ•° v,å®é™…ä¸Šå°±æ˜¯è¦è®© C[9]ã€C[10]ã€C[12]ã€C[16]éƒ½åŠ ä¸Š vã€‚äºæ˜¯é—®é¢˜åˆæ¥äº†â€”â€”æƒ³è¦ç»™ A[x]åŠ ä¸Švæ—¶ï¼Œæ€æ ·å»å¯»æ‰¾æ ‘çŠ¶æ•°ç»„ä¸­çš„å¯¹åº”é¡¹å‘¢?

è¦è®© A[x]åŠ ä¸Š vï¼Œå°±æ˜¯è¦å¯»æ‰¾æ ‘çŠ¶æ•°ç»„ C ä¸­èƒ½è¦†ç›– A[x]çš„é‚£äº›å…ƒç´ ï¼Œè®©å®ƒä»¬éƒ½åŠ ä¸Š vã€‚è€Œä»å›¾ 1ä¸­ç›´è§‚åœ°çœ‹ï¼Œåªéœ€è¦æ€»æ˜¯å¯»æ‰¾ç¦»å½“å‰çš„â€œçŸ©å½¢â€C[x]æœ€è¿‘çš„â€œçŸ©å½¢â€C[y]ï¼Œä½¿å¾— C[y]èƒ½å¤Ÿè¦†ç›– C[x]å³å¯ã€‚ä¾‹å¦‚è¦è®© A[6]åŠ ä¸Š vï¼Œå°±ä» C[6]å¼€å§‹æ‰¾èµ·ï¼šç¦» C[6]æœ€è¿‘çš„èƒ½è¦†ç›– C[6]çš„â€œçŸ©å½¢â€æ˜¯ C[8]ï¼Œç¦» C[8]æœ€è¿‘çš„èƒ½è¦†ç›– C[8]çš„â€œçŸ©å½¢â€æ˜¯ C[16]ï¼Œäºæ˜¯åªè¦æŠŠ C[6]ã€C[8]ã€C[16]éƒ½åŠ ä¸Švå³å¯ã€‚

é‚£ä¹ˆï¼Œå¦‚ä½•æ‰¾åˆ°è·ç¦»å½“å‰çš„ C[x]æœ€è¿‘çš„èƒ½è¦†ç›– C[x]çš„ C[y]å‘¢ï¼Ÿé¦–å…ˆï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªæ˜¾ç„¶çš„ç»“è®ºï¼šlowbit(y)å¿…é¡»å¤§äº lowbit(x)ï¼ˆä¸ç„¶æ€ä¹ˆè¦†ç›–å‘¢â€¦â€¦ï¼‰ã€‚äºæ˜¯é—®é¢˜ç­‰ä»·äºæ±‚ä¸€ä¸ªå°½å¯èƒ½å°çš„æ•´æ•° aï¼Œä½¿å¾— lowbit(x+a)>lowbit(x)ã€‚æ˜¾ç„¶ï¼Œç”±äº lowbit(x)æ˜¯å–xçš„äºŒè¿›åˆ¶æœ€å³è¾¹çš„1çš„ä½ç½®ï¼Œå› æ­¤å¦‚æœ lowbit(a) < lowbit(x)ï¼Œlowbit(x+ a)å°±ä¼šå°äº lowbit(x)ã€‚ä¸ºæ­¤ lowbit(a)å¿…é¡»ä¸å°äº lowbit(x)ã€‚æ¥ç€å‘ç°ï¼Œå½“aå– lowbit(x)æ—¶ï¼Œç”±äºxå’Œaçš„äºŒè¿›åˆ¶æœ€å³è¾¹çš„1çš„ä½ç½®ç›¸åŒ,å› æ­¤x+aä¼šåœ¨è¿™ä¸ª1çš„ä½ç½®ä¸Šäº§ç”Ÿè¿›ä½ï¼Œä½¿å¾—è¿›ä½è¿‡ç¨‹ä¸­çš„æ‰€æœ‰è¿ç»­çš„1å˜æˆ0ï¼Œç›´åˆ°æŠŠå®ƒä»¬å·¦è¾¹ç¬¬ä¸€ä¸ª0ç½®ä¸º1æ—¶ç»“æŸã€‚äºæ˜¯lowbit(x+a)>lowbit(x)æ˜¾ç„¶æˆç«‹,æœ€å°çš„aå°±æ˜¯lowbit(x)ã€‚äºæ˜¯ update å‡½æ•°çš„åšæ³•å°±å¾ˆæ˜ç¡®äº†ï¼Œåªè¦è®©xä¸æ–­åŠ ä¸Š lowbit(x)ï¼Œå¹¶è®©æ¯æ­¥çš„ C[x]éƒ½åŠ ä¸Š vï¼Œç›´åˆ°xè¶…è¿‡ç»™å®šçš„æ•°æ®èŒƒå›´ä¸ºæ­¢ã€‚ä»£ç å¦‚ä¸‹ï¼š

```python
def bit_update(BIT, n, i, v):
    i += 1  # index in BITree[] is 1 more than the index in arr[]

    while i <= n:  # Traverse all ancestors and add 'val'
        BIT[i] += v
        i += i & (-i)  # Update index to that of parent
```

æ›´æ–°å‡½æ•°éœ€è¦ç¡®ä¿æ‰€æœ‰åŒ…å«arr[i]åœ¨å…¶èŒƒå›´å†…çš„BITèŠ‚ç‚¹éƒ½è¢«æ›´æ–°ã€‚æˆ‘ä»¬é€šè¿‡ä¸æ–­å‘å½“å‰ç´¢å¼•æ·»åŠ å…¶æœ€åä¸€ä½è®¾ç½®ä½å¯¹åº”çš„åè¿›åˆ¶æ•°ï¼Œåœ¨BITä¸­å¾ªç¯éå†è¿™äº›èŠ‚ç‚¹ã€‚



### **å®ç°** 

é¦–å…ˆå°†BIT[]ä¸­çš„æ‰€æœ‰å€¼åˆå§‹åŒ–ä¸º0ã€‚ç„¶åå¯¹æ‰€æœ‰çš„ç´¢å¼•è°ƒç”¨bit_update()å‡½æ•°ã€‚

```python
# Binary Indexed Tree

def bit_sum(BIT, i):
    """è®¡ç®—æ ‘çŠ¶æ•°ç»„ BIT ä»ç´¢å¼• 1 åˆ° i çš„å‰ç¼€å’Œ"""
    s = 0
    while i > 0:
        s += BIT[i]
        i -= i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹
    return s


def bit_update(BIT, i, v):
    """åœ¨æ ‘çŠ¶æ•°ç»„ BIT ä¸­æ›´æ–°ç´¢å¼• i å¤„çš„å€¼ v"""
    while i < len(BIT):
        BIT[i] += v
        i += i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹


# Constructs and returns a Binary Indexed Tree for given array of size n.
def construct(arr, n):
    BIT = [0] * (n + 1)
    for i in range(n):  # Store the actual values in BIT[] using bit_update()
        bit_update(BIT, i + 1, arr[i])

    return BIT


arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
BIT = construct(arr, len(arr))
print(f'BIT: ', *BIT)
print("Sum of elements in arr[0..5] is " + str(bit_sum(BIT, 5)))
arr[3] += 6
bit_update(BIT, 3, 6)
print(f'BIT: ', *BIT)
print("Sum of elements in arr[0..5]" +
      " after update is " + str(bit_sum(BIT, 5)))

```

**Output**

```
BIT:  0 1 3 3 10 5 11 7 36 9 19 11 42 13 27 15 136
Sum of elements in arr[0..5] is 15
BIT:  0 1 3 9 16 5 11 7 42 9 19 11 42 13 27 15 142
Sum of elements in arr[0..5] after update is 21
```

**Time Complexity:** $O(NlogN)$
**Auxiliary Space:** $O(N)$

**Can we extend the Binary Indexed Tree to computing the sum of a range in O(Logn) time?** 
Yes. rangeSum(l, r) = get_sum(r) â€“ get_sum(l-1).

**References:** 
http://en.wikipedia.org/wiki/Fenwick_tree 



### ç¤ºä¾‹20018:èš‚èšç‹å›½çš„è¶Šé‡è·‘

BIT, http://cs101.openjudge.cn/practice/20018/

ä¸ºäº†ä¿ƒè¿›èš‚èšå®¶æ—èº«ä½“å¥åº·ï¼Œæé«˜èšæ—å¥èº«æ„è¯†ï¼Œèš‚èšç‹å›½ä¸¾è¡Œäº†è¶Šé‡è·‘ã€‚å‡è®¾è¶Šé‡è·‘å…±æœ‰Nä¸ªèš‚èšå‚åŠ ï¼Œåœ¨ä¸€æ¡ç¬”ç›´çš„é“è·¯ä¸Šè¿›è¡Œã€‚Nä¸ªèš‚èšåœ¨èµ·ç‚¹å¤„ç«™æˆä¸€åˆ—ï¼Œç›¸é‚»ä¸¤ä¸ªèš‚èšä¹‹é—´ä¿æŒä¸€å®šçš„é—´è·ã€‚æ¯”èµ›å¼€å§‹åï¼ŒNä¸ªèš‚èšåŒæ—¶æ²¿ç€é“è·¯å‘ç›¸åŒçš„æ–¹å‘è·‘å»ã€‚æ¢å¥è¯è¯´ï¼Œè¿™Nä¸ªèš‚èšå¯ä»¥çœ‹ä½œxè½´ä¸Šçš„Nä¸ªç‚¹ï¼Œåœ¨æ¯”èµ›å¼€å§‹åï¼Œå®ƒä»¬åŒæ—¶å‘Xè½´æ­£æ–¹å‘ç§»åŠ¨ã€‚å‡è®¾è¶Šé‡è·‘çš„è·ç¦»è¶³å¤Ÿè¿œï¼Œè¿™Nä¸ªèš‚èšçš„é€Ÿåº¦æœ‰çš„ä¸ç›¸åŒæœ‰çš„ç›¸åŒä¸”ä¿æŒåŒ€é€Ÿè¿åŠ¨ï¼Œé‚£ä¹ˆä¼šæœ‰å¤šå°‘å¯¹å‚èµ›è€…ä¹‹é—´å‘ç”Ÿâ€œèµ¶è¶…â€çš„äº‹ä»¶å‘¢ï¼Ÿæ­¤é¢˜ç»“æœæ¯”è¾ƒå¤§ï¼Œéœ€è¦å®šä¹‰long longç±»å‹ã€‚è¯·çœ‹å¤‡æ³¨ã€‚

<img src="http://media.openjudge.cn/images/upload/1576506586.jpg" alt="img" style="zoom:50%;" />



**è¾“å…¥**

ç¬¬ä¸€è¡Œ1ä¸ªæ•´æ•°Nã€‚
ç¬¬2â€¦ N +1è¡Œï¼šN ä¸ªéè´Ÿæ•´æ•°ï¼ŒæŒ‰ä»å‰åˆ°åçš„é¡ºåºç»™å‡ºæ¯ä¸ªèš‚èšçš„è·‘æ­¥é€Ÿåº¦ã€‚å¯¹äº50%çš„æ•°æ®ï¼Œ2<=N<=1000ã€‚å¯¹äº100%çš„æ•°æ®ï¼Œ2<=N<=100000ã€‚

è¾“å‡º

ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ‰å¤šå°‘å¯¹å‚èµ›è€…ä¹‹é—´å‘ç”Ÿèµ¶è¶…äº‹ä»¶ã€‚

æ ·ä¾‹è¾“å…¥

```
5
1
5
10
7
6

5
1
5
5
7
6
```

æ ·ä¾‹è¾“å‡º

```
7

8
```

æç¤º

æˆ‘ä»¬æŠŠè¿™5ä¸ªèš‚èšä¾æ¬¡ç¼–å·ä¸ºA,B,C,D,Eï¼Œå‡è®¾é€Ÿåº¦åˆ†åˆ«ä¸º1,5,5,7,6ã€‚åœ¨è·‘æ­¥è¿‡ç¨‹ä¸­ï¼šB,C,D,Eå‡ä¼šè¶…è¿‡Aï¼Œå› ä¸ºä»–ä»¬çš„é€Ÿåº¦éƒ½æ¯”Aå¿«ï¼›D,Eéƒ½ä¼šè¶…è¿‡B,Cï¼Œå› ä¸ºä»–ä»¬çš„é€Ÿåº¦éƒ½æ¯”B,Cå¿«ï¼›D,Eä¹‹é—´ä¸ä¼šå‘ç”Ÿèµ¶è¶…ï¼Œå› ä¸ºé€Ÿåº¦å¿«çš„èµ·è·‘æ—¶å°±åœ¨å‰è¾¹ï¼›B,Cä¹‹é—´ä¸ä¼šå‘ç”Ÿèµ¶è¶…ï¼Œå› ä¸ºé€Ÿåº¦ä¸€æ ·ï¼Œåœ¨å‰é¢çš„å°±ä¸€ç›´åœ¨å‰é¢ã€‚

è€ƒè™‘å½’å¹¶æ’åºçš„æ€æƒ³ã€‚

æ­¤é¢˜ç»“æœæ¯”è¾ƒå¤§ï¼Œéœ€è¦å®šä¹‰long longç±»å‹ï¼Œå…¶è¾“å‡ºæ ¼å¼ä¸ºprintf("%lld",x);
long longï¼Œæœ‰ç¬¦å· 64ä½æ•´æ•°ï¼Œæ‰€å 8ä¸ªå­—èŠ‚(Byte)
-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807



```python
# å¼ æ¸…å· 24åŒ–å­¦å­¦é™¢
def bit_sum(BIT, i):
    """è®¡ç®—æ ‘çŠ¶æ•°ç»„ BIT ä»ç´¢å¼• 1 åˆ° i çš„å‰ç¼€å’Œ"""
    s = 0
    while i > 0:
        s += BIT[i]
        i -= i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹
    return s


def bit_update(BIT, i, v):
    """åœ¨æ ‘çŠ¶æ•°ç»„ BIT ä¸­æ›´æ–°ç´¢å¼• i å¤„çš„å€¼ v"""
    while i < len(BIT):
        BIT[i] += v
        i += i & (-i)  # å›æº¯è‡³ç¥–å…ˆèŠ‚ç‚¹


# è¯»å–è¾“å…¥å¹¶è¿›è¡Œç¦»æ•£åŒ–
n = int(input())
values = [int(input()) for _ in range(n)]

# ç¦»æ•£åŒ–ï¼šå»ºç«‹å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
sorted_vals = sorted(set(values))
value_to_index = {v: i + 1 for i, v in enumerate(sorted_vals)}

# åˆå§‹åŒ–æ ‘çŠ¶æ•°ç»„
BIT = [0] * (len(sorted_vals) + 1)
count = 0

# è®¡ç®—é€†åºå¯¹
for v in values:
    index = value_to_index[v]
    count += bit_sum(BIT, index - 1)  # æŸ¥è¯¢æ¯”å½“å‰å€¼å°çš„å…ƒç´ ä¸ªæ•°
    bit_update(BIT, index, 1)  # åœ¨æ ‘çŠ¶æ•°ç»„ä¸­è®°å½•å½“å‰å€¼å‡ºç°æ¬¡æ•°

print(count)
```





## B çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰

Segment tree | Efficient implementation

https://www.geeksforgeeks.org/segment-tree-efficient-implementation/



Let us consider the following problem to understand Segment Trees without recursion.
We have an array $arr[0 . . . n-1]$. We should be able to, 

1. Find the sum of elements from index `l` to `r` where $0 \leq l \leq r \leq n-1$
2. Change the value of a specified element of the array to a new value x. We need to do $arr[i] = x$ where $0 \leq i \leq n-1$. 

A **simple solution** is to run a loop from l to r and calculate the sum of elements in the given range. To update a value, simply do $arr[i] = x$. The first operation takes **O(n)** time and the second operation takes **O(1)** time.

**Another solution** is to create another array and store the sum from start to i at the ith index in this array. The sum of a given range can now be calculated in O(1) time, but the update operation takes O(n) time now. This works well if the number of query operations is large and there are very few updates.
What if the number of queries and updates are equal? Can we perform both the operations in O(log n) time once given the array? We can use a [Segment Tree](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/) to do both operations in O(Logn) time. We have discussed the complete implementation of segment trees in our [previous](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/) post. In this post, we will discuss the easier and yet efficient implementation of segment trees than in the previous post.
Consider the array and segment tree as shown below:  å¶å­æ˜¯æ•°ç»„å€¼ï¼Œéå¶æ˜¯å’Œ

![img](https://media.geeksforgeeks.org/wp-content/uploads/excl.png)



You can see from the above image that the original array is at the bottom and is 0-indexed with 16 elements. The tree contains a total of 31 nodes where the leaf nodes or the elements of the original array start from node 16. So, we can easily construct a segment tree for this array using a `2*N` sized array where `N` is the number of elements in the original array. The leaf nodes will start from index `N` in this array and will go up to index (2*N â€“ 1). Therefore, the element at index i in the original array will be at index (i + N) in the segment tree array. Now to calculate the parents, we will start from the index (N â€“ 1) and move upward. æ ¹èŠ‚ç‚¹ä¸‹æ ‡ä»1å¼€å§‹ï¼ŒFor index i , the left child will be at (2 * i) and the right child will be at (2*i + 1) index. So the values at nodes at (2 * i) and (2*i + 1) are combined at i-th node to construct the tree. 
As you can see in the above figure, we can query in this tree in an interval [L,R) with left index(L) included and right (R) excluded.
We will implement all of these multiplication and addition operations using bitwise operators.
Let us have a look at the complete implementation: 

```python
# Python3 Code Addition 

# limit for array size 
N = 100000; 

# Max size of tree 
tree = [0] * (2 * N); 

# function to build the tree 
def build(arr) : 

	# insert leaf nodes in tree 
	for i in range(n) : 
		tree[n + i] = arr[i]; 
	
	# build the tree by calculating parents 
	for i in range(n - 1, 0, -1) : 
    # tree[i] = tree[2*i] + tree[2*i+1]
		tree[i] = tree[i << 1] + tree[i << 1 | 1]; 	

# function to update a tree node 
def updateTreeNode(p, value) : 
	
	# set value at position p 
	tree[p + n] = value; 
	p = p + n; 
	
	# move upward and update parents 
	i = p; 
	
	while i > 1 : 
		
		tree[i >> 1] = tree[i] + tree[i ^ 1]; 
		i >>= 1; 

# function to get sum on interval [l, r) 
def query(l, r) : 

	res = 0; 
	
	# loop to find the sum in the range 
	l += n; 
	r += n; 
	
	while l < r : 
	
		if (l & 1) : 
			res += tree[l]; 
			l += 1
	
		if (r & 1) : 
			r -= 1; 
			res += tree[r]; 
			
		l >>= 1; 
		r >>= 1
	
	return res; 

if __name__ == "__main__" : 

	a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; 

	n = len(a); 
	
	build(a); 
	
	# print the sum in range(1,2) index-based 
	print(query(1, 3)); 
	
	# modify element at 2nd index 
	updateTreeNode(2, 1); 
	
	# print the sum in range(1,2) index-based 
	print(query(1, 3)); 

```



**Output:** 

```
5
3
```

Yes! That is all. The complete implementation of the segment tree includes the query and update functions. Let us now understand how each of the functions works: 


1. The picture makes it clear that the leaf nodes are stored at i+n, so we can clearly insert all leaf nodes directly.
2. The next step is to build the tree and it takes O(n) time. The parent always has its less index than its children, so we just process all the nodes in decreasing order, calculating the value of the parent node. If the code inside the build function to calculate parents seems confusing, then you can see this code. It is equivalent to that inside the build function. 

```python
tree[i] = tree[2*i] + tree[2*i+1]
```

 

3. Updating a value at any position is also simple and the time taken will be proportional to the height ï¼ˆâ€œé«˜åº¦â€è¿™ä¸ªæ¦‚å¿µï¼Œå…¶å®å°±æ˜¯ä»ä¸‹å¾€ä¸Šåº¦é‡ï¼Œæ ‘è¿™ç§æ•°æ®ç»“æ„çš„é«˜åº¦æ˜¯ä»æœ€åº•å±‚å¼€å§‹è®¡æ•°ï¼Œå¹¶ä¸”è®¡æ•°çš„èµ·ç‚¹æ˜¯0ï¼‰ of the tree. We only update values in the parents of the given node which is being changed. So to get the parent, we just go up to the parent node, which is p/2 or p>>1, for node p. p^1 turns (2\*i) to (2\*i + 1) and vice versa to get the second child of p.
4. Computing the sum also works in $O(Logn)$ time. If we work through an interval of [3,11), we need to calculate only for nodes 19,26,12, and 5 in that order.  è¦æ¼”ç¤ºè¿™ä¸ªç´¢å¼•ä¸Šè¡Œçš„æ±‚å’Œè¿‡ç¨‹ï¼Œå‰é¢ç¨‹åºæ•°ç»„æ˜¯12ä¸ªå…ƒç´ ï¼Œå›¾ç¤ºæ˜¯16ä¸ªå…ƒç´ ï¼Œéœ€è¦ç¨ä½œä¿®æ”¹ã€‚å¢åŠ äº†printè¾“å‡ºï¼Œä¾¿äºè°ƒè¯•ã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/202310312148391.png" alt="image-20231031214814445" style="zoom:50%;" />



The idea behind the query function is whether we should include an element in the sum or whether we should include its parent. Letâ€™s look at the image once again for proper understanding. 

![img](https://media.geeksforgeeks.org/wp-content/uploads/excl.png)

Consider that L is the left border of an interval and R is the right border of the interval [L,R). It is clear from the image that if L is odd, then it means that it is the right child of its parent and our interval includes only L and not the parent. So we will simply include this node to sum and move to the parent of its next node by doing L = (L+1)/2. Now, if L is even, then it is the left child of its parent and the interval includes its parent also unless the right borders interfere. Similar conditions are applied to the right border also for faster computation. We will stop this iteration once the left and right borders meet.
The theoretical time complexities of both previous implementation and this implementation is the same, but practically, it is found to be much more efficient as there are no recursive calls. We simply iterate over the elements that we need. Also, this is very easy to implement.

> The algorithm re-evaluates the sum variable only if the idex from and to are odd. Why is that? It's because if the index is even, then it's the left child node. We don't need to bother reading it, since we'll get another chance at doing it on the next level up. Of course, the same logic applies on the next level up, and the decision about even index nodes could always be postponed. Given that the length of the tree array is always twice the size of the input array, which is a constant multiplier. And that on each iteration of the loop, the from and to variables are halved, the loop iterates at most log base two of two multiply by n. Which is a order log n running time complexity. Another way of saying this is, since the algorithm works up the tree and the height of the tree is equal to log n, its running time is order log n.
>
> ä¸ºä»€ä¹ˆåœ¨ç´¢å¼• from å’Œ to æ˜¯å¥‡æ•°æ—¶ï¼Œç®—æ³•æ‰é‡æ–°è®¡ç®—å’Œæ›´æ–° sum å˜é‡ã€‚åŸå› æ˜¯ï¼Œå¦‚æœç´¢å¼•æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆå®ƒå¯¹åº”çš„èŠ‚ç‚¹æ˜¯å·¦å­èŠ‚ç‚¹ã€‚æˆ‘ä»¬ä¸éœ€è¦è¯»å–å®ƒï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ä¸‹ä¸€å±‚çº§ä¸­ä¼šæœ‰å¦ä¸€æ¬¡æœºä¼šè¿›è¡Œè¯»å–ã€‚å½“ç„¶ï¼Œç›¸åŒçš„é€»è¾‘ä¹Ÿé€‚ç”¨äºä¸Šä¸€å±‚çº§ï¼Œå¯¹å¶æ•°ç´¢å¼•èŠ‚ç‚¹çš„å†³å®šæ€»æ˜¯å¯ä»¥æ¨è¿Ÿçš„ã€‚è€ƒè™‘åˆ°æ ‘æ•°ç»„çš„é•¿åº¦å§‹ç»ˆæ˜¯è¾“å…¥æ•°ç»„å¤§å°çš„ä¸¤å€ï¼Œè¿™æ˜¯ä¸€ä¸ªæ’å®šçš„ä¹˜æ•°ã€‚è€Œä¸”åœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸­ï¼Œfrom å’Œ to å˜é‡éƒ½ä¼šå‡åŠï¼Œå› æ­¤å¾ªç¯çš„æœ€å¤§è¿­ä»£æ¬¡æ•°æ˜¯ä»¥log 2nã€‚è¿™æ˜¯ä¸€ä¸ªå¯¹æ•°å¤æ‚åº¦çš„è¿è¡Œæ—¶é—´ã€‚æ¢å¥è¯è¯´ï¼Œç”±äºç®—æ³•æ˜¯æ²¿ç€æ ‘å‘ä¸Šè¿è¡Œçš„ï¼Œè€Œæ ‘çš„é«˜åº¦ç­‰äº log nï¼Œå› æ­¤å…¶è¿è¡Œæ—¶é—´æ˜¯å¯¹æ•°å¤æ‚åº¦çš„ã€‚



**Time Complexities:**

- Tree Construction: O( n )
- Query in Range: O( Log n )
- Updating an element: O( Log n ).

**Auxiliary Space:** O(2*N)



### ç¤ºä¾‹1364A: A. XXXXX

brute force/data structures/number theory/two pointers, 1200, https://codeforces.com/problemset/problem/1364/A

Ehab loves number theory, but for some reason he hates the number ğ‘¥. Given an array ğ‘, find the length of its longest subarray such that the sum of its elements **isn't** divisible by ğ‘¥, or determine that such subarray doesn't exist.

An array ğ‘ is a subarray of an array ğ‘ if ğ‘ can be obtained from ğ‘ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.

**Input**

The first line contains an integer ğ‘¡ (1â‰¤ğ‘¡â‰¤5) â€” the number of test cases you need to solve. The description of the test cases follows.

The first line of each test case contains 2 integers ğ‘› and ğ‘¥ (1â‰¤ğ‘›â‰¤10^5^, 1â‰¤ğ‘¥â‰¤10^4^) â€” the number of elements in the array ğ‘ and the number that Ehab hates.

The second line contains ğ‘› space-separated integers $ğ‘_1, ğ‘_2, â€¦â€¦, ğ‘_ğ‘› (0â‰¤ğ‘_ğ‘–â‰¤10^4)$ â€” the elements of the array ğ‘.

**Output**

For each testcase, print the length of the longest subarray whose sum isn't divisible by ğ‘¥. If there's no such subarray, print âˆ’1.

Example

input

```
3
3 3
1 2 3
3 4
1 2 3
2 2
0 6
```

output

```
2
3
-1
```

Note

In the first test case, the subarray \[2,3\] has sum of elements 5, which isn't divisible by 3.

In the second test case, the sum of elements of the whole array is 6, which isn't divisible by 4.

In the third test case, all subarrays have an even sum, so the answer is âˆ’1.



Pypy3 å¯ä»¥ACã€‚ä½¿ç”¨tree segmentï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n*logn)

```python
# CF 1364A
 
# def prefix_sum(nums):
#     prefix = []
#     total = 0
#     for num in nums:
#         total += num
#         prefix.append(total)
#     return prefix
 
# def suffix_sum(nums):
#     suffix = []
#     total = 0
#     # é¦–å…ˆå°†åˆ—è¡¨åè½¬
#     reversed_nums = nums[::-1]
#     for num in reversed_nums:
#         total += num
#         suffix.append(total)
#     # å°†ç»“æœåè½¬å›æ¥
#     suffix.reverse()
#     return suffix
 
 
t = int(input())
ans = []
for _ in range(t):
    n, x = map(int, input().split())
    a = [int(i) for i in input().split()]


# Segment tree | Efficient implementation
# https://www.geeksforgeeks.org/segment-tree-efficient-implementation/

    # Max size of tree 
    tree = [0] * (2 * n); 

    def build(arr) : 

        # insert leaf nodes in tree 
        for i in range(n) : 
            tree[n + i] = arr[i]; 
        
        # build the tree by calculating parents 
        for i in range(n - 1, 0, -1) : 
            tree[i] = tree[i << 1] + tree[i << 1 | 1]; 

    # function to update a tree node 
    def updateTreeNode(p, value) : 
        
        # set value at position p 
        tree[p + n] = value; 
        p = p + n; 
        
        # move upward and update parents 
        i = p; 
        
        while i > 1 : 
            
            tree[i >> 1] = tree[i] + tree[i ^ 1]; 
            i >>= 1; 

    # function to get sum on interval [l, r) 
    def query(l, r) : 

        res = 0; 
        
        # loop to find the sum in the range 
        l += n; 
        r += n; 
        
        while l < r : 
        
            if (l & 1) : 
                res += tree[l]; 
                l += 1
        
            if (r & 1) : 
                r -= 1; 
                res += tree[r]; 
                
            l >>= 1; 
            r >>= 1
        
        return res; 
    #aprefix_sum = prefix_sum(a)
    #asuffix_sum = suffix_sum(a)
 
    build([i%x for i in a]);
    
    left = 0
    right = n - 1
    if right == 0:
        if a[0] % x !=0:
            print(1)
        else:
            print(-1)
        continue
 
    leftmax = 0
    rightmax = 0
    while left != right:
        #total = asuffix_sum[left]
        total = query(left, right+1)
        if total % x != 0:
            leftmax = right - left + 1
            break
        else:
            left += 1
 
    left = 0
    right = n - 1
    while left != right:
        #total = aprefix_sum[right]
        total = query(left, right+1)
        if total % x != 0:
            rightmax = right - left + 1
            break
        else:
            right -= 1
    
    if leftmax == 0 and rightmax == 0:
        #print(-1)
        ans.append(-1)
    else:
        #print(max(leftmax, rightmax))
        ans.append(max(leftmax, rightmax))

print('\n'.join(map(str,ans)))
```



å¦‚æœç”¨sumæ±‚å’Œï¼ŒO(n^2)ï¼Œpypy3ä¹Ÿä¼šåœ¨test3 è¶…æ—¶ã€‚





## C å‰ç¼€æ ‘ï¼ˆTrie Treeï¼‰

Trie â€“ Data Structure and Algorithm Tutorials

https://www.geeksforgeeks.org/introduction-to-trie-data-structure-and-algorithm-tutorials/

Trie data structure is defined as a Tree based data structure that is used for storing some collection of strings and performing efficient search operations on them. The word Trie is derived from re**TRIE**val, which means finding something or obtaining it. 

Trie follows some property that If two strings have a common prefix then they will have the same ancestor in the trie. A trie can be used to sort a collection of strings alphabetically as well as search whether a string with a given prefix is present in the trie or not.



**Need for Trie Data Structure?**

A Trie data structure is used for storing and retrieval of data and the same operations could be done using another data structure which is Hash Table but Trie can perform these operations more efficiently than a Hash Table. Moreover, Trie has its own advantage over the Hash table. A Trie data structure can be used for **prefix-based** searching whereas a Hash table canâ€™t be used in the same way. 



**Advantages of Trie Data Structure over a Hash Table:**

The A trie data structure has the following advantages over a hash table:  

- We can efficiently do **prefix search** (or auto-complete) with Trie.
- We can easily print all words in alphabetical order which is not easily possible with hashing.
- There is no overhead of Hash functions in a Trie data structure.
- Searching for a String even in the large collection of strings in a Trie data structure can be done in **O(L)** Time complexity, Where L is the number of words in the query string. This searching time could be even less than O(L) if the query string does not exist in the trie.



**Properties of a Trie Data Structure**

Now we already know that Trie has a tree-like structure. So, it is very important to know its properties.
Below are some important properties of the Trie data structure:

- There is one root node in each Trie.
- Each node of a Trie represents a string and each edge represents a character.
- Every node consists of hashmaps or **an array of pointers**, with each index representing a character and a flag to indicate if any string ends at the current node.
- Trie data structure can contain any number of characters including **alphabets**, **numbers**, and **special characters**. But for this article, we will discuss strings with characters a-z. Therefore, only 26 pointers need for every node, where the **0th** index represents **â€˜aâ€™** and the **25th** index represents **â€˜zâ€™** characters.
- Each path from the root to any node represents a word or string.

Below is a simple example of Trie data structure.

![Trie Data Structure](https://raw.githubusercontent.com/GMyhf/img/main/img/Triedatastructure1.png)

Trie Data Structure



**How does Trie Data Structure work?**

We already know that the Trie data structure can contain any number of characters including **alphabets**, **numbers**, and **special characters**. But for this article, we will discuss strings with characters **a-z**. Therefore, only 26 pointers need for every node, where the **0th** index represents **â€˜aâ€™** and the **25th** index represents **â€˜zâ€™** characters.

Any lowercase English word can start with **a-z**, then the next letter of the word could be **a-z,** the third letter of the word again could be **a-z**, and so on. So for storing a word, we need to take an array (container) of size **26** and initially, all the characters are empty as there are no words and it will look as shown below.

![An array of pointers inside every Trie node](https://raw.githubusercontent.com/GMyhf/img/main/img/nodeintrie.png)

An array of pointers inside every Trie node

Letâ€™s see how a word `and` and `ant` is stored in the Trie data structure: 

1. Store `and` in Trie data structure:

   - The word `and` starts with `a`, So we will mark the position `a` as filled in the Trie node, which represents the use of `a`. 
   - After placing the first character, for the second character again there are `26 possibilities`, So from `a`, again there is an array of size `26`, for storing the 2nd character.
   - The second character is `n`, So from `a`, we will move to `n` and mark `n` in the `2nd` array as used.
   - After `n`, the 3rd character is `d`, So mark the position `d` as used in the respective array.

2. Store `ant` in the Trie data structure:

   - The word `ant` starts with `a` and the position of `a` in the root node has already been filled. So, no need to fill it again, just move to the node `a` in Trie.
   - For the second character `n` we can observe that the position of â€˜nâ€™ in the â€˜aâ€™ node has already been filled. So, no need to fill it again, just move to node `n` in Trie.
   - For the last character `t` of the word, The position for `t` in the `n` node is not filled. So, filled the position of `t`â€˜ in `n` node and move to `t` node.

After storing the word â€œandâ€ and â€œantâ€ the Trie will look like this:

![img](https://raw.githubusercontent.com/GMyhf/img/main/img/a1.png)

 

**Representation of Trie Node:**

Every Trie node consists of a character pointer array or hashmap and a flag to represent if the word is ending at that node or not. But if the words contain only **lower-case** letters (i.e. a-z), then we can define Trie Node with an array instead of a hashmap.



```python
# Python code
class TrieNode:

	# Trie node class
	def _init_(self):
		self.children = [None for _ in range(26)]

		# This will keep track of number of strings that are
		# stored in the Trie from root node to any Trie node.
		self.wordCount = 0
		
		# This code is contributed by ishankhandelwals.

```

**Basic Operations on Trie Data Structure:**

1. Insertion
2. Search
3. Deletion

**1. Insertion in Trie Data Structure:**

This operation is used to insert new strings into the Trie data structure. Let us see how this works:

Let us try to Insert â€œandâ€ & â€œantâ€ in this Trie:

![Insert "and" & "ant"](https://raw.githubusercontent.com/GMyhf/img/main/img/ex1-660x399.png)



From the above representation of insertion, we can see that the word â€œandâ€ & â€œantâ€ have shared some common node (i.e â€œanâ€) this is because of the property of the Trie data structure that If two strings have a common prefix then they will have the same ancestor in the trie.

Now let us try to Insert â€œdadâ€ & â€œdoâ€:

![Insertion in Trie Data Structure](https://raw.githubusercontent.com/GMyhf/img/main/img/ex2.png)

Insertion in Trie Data Structure

**Implementation of Insertion in Trie data structure:**

Algorithm:

1. Define a function `insert(TrieNode root, string &word)` which will take two parameters one for the root and the other for the string that we want to insert in the Trie data structure.

2. Now take another pointer `currentNode` and initialize it with the `root` node.

3. Iterate over the length of the given string and check if the value is `NULL` or not in the array of pointers at the current character of the string.

   - If Itâ€™s `NULL` then, make a new node and point the current character to this newly created node.
   - Move the curr to the newly created node.

4. Finally, increment the `wordCount` of the last `currentNode`, this implies that there is a string ending currentNode.

Below is the implementation of the above algorithm:



```python
def insert_key(root, key):
	# Initialize the currentNode pointer
	# with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current
		# character in the Trie.
		if currentNode.childNode[ord(c) - ord('a')] == None:
			# If node for current character does not exist
			# then make a new node
			newNode = TrieNode()

			# Keep the reference for the newly created
			# node.
			currentNode.childNode[ord(c) - ord('a')] = newNode

		# Now, move the current node pointer to the newly
		# created node.
		currentNode = currentNode.childNode[ord(c) - ord('a')]

	# Increment the wordEndCount for the last currentNode
	# pointer this implies that there is a string ending at
	# currentNode.
	currentNode.wordCount += 1

```

**2. Searching in Trie Data Structure:**

Search operation in Trie is performed in a similar way as the insertion operation but the only difference is that whenever we find that the array of pointers in `curr node` does not point to the `current character` of the `word` then return false instead of creating a new node for that current character of the word. 

This operation is used to search whether a string is present in the Trie data structure or not. There are two search approaches in the Trie data structure.

1. Find whether the given word exists in Trie.
2. Find whether any word that starts with the given prefix exists in Trie.

There is a similar search pattern in both approaches. The first step in searching a given word in Trie is to convert the word to characters and then compare every character with the trie node from the root node. If the current character is present in the node, move forward to its children. Repeat this process until all characters are found.

**2.1 Searching Prefix in Trie Data Structure:**

Search for the prefix â€œanâ€ in the Trie Data Structure.

![Search for the prefix "an" in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/searchforprefix.png)

Search for the prefix â€œanâ€ in Trie



Implementation of Prefix Search in Trie data structure:

```python
def is_prefix_exist(root, key):
	# Initialize the currentNode pointer
	# with the root node
	current_node = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current
		# character in the Trie.
		if current_node.child_node[ord(c) - ord('a')] is None:
			# Given word as a prefix does not exist in Trie
			return False

		# Move the currentNode pointer to the already 
		# existing node for current character.
		current_node = current_node.child_node[ord(c) - ord('a')]

	# Prefix exist in the Trie
	return True

```

**2.2 Searching Complete word in Trie Data Structure:**

It is similar to prefix search but additionally, we have to check if the word is ending at the last character of the word or not.

![Searching in Trie Data Structure](https://raw.githubusercontent.com/GMyhf/img/main/img/search1.png)

Search â€œdadâ€ in the Trie data structure

Implementation of Search in Trie data structure:

```python
def search_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie
		if currentNode.childNode[ord(c) - ord('a')] is None:
			# Given word does not exist in Trie
			return False

		# Move the currentNode pointer to the already existing node for current character
		currentNode = currentNode.childNode[ord(c) - ord('a')]

	# Return if the wordCount is greater than 0
	return currentNode.wordCount > 0

```

**3. Deletion in Trie Data Structure**

This operation is used to delete strings from the Trie data structure. There are three cases when deleting a word from Trie.

1. The deleted word is a prefix of other words in Trie.
2. The deleted word shares a common prefix with other words in Trie.
3. The deleted word does not share any common prefix with other words in Trie.

Example :

**3.1 The deleted word is a prefix of other words in Trie.**

As shown in the following figure, the deleted word â€œanâ€ share a complete prefix with another word â€œandâ€ and â€œantâ€œ.

![Deletion of word which is a prefix of other words in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/case1.png)

Deletion of word which is a prefix of other words in Trie


An easy solution to perform a delete operation for this case is to just decrement the **wordCount** by 1 at the ending node of the word.

**3.2 The deleted word shares a common prefix with other words in Trie.**

As shown in the following figure, the deleted word â€œandâ€ has some common prefixes with other words â€˜antâ€™. They share the prefix â€˜anâ€™.

![Deletion of word which shares a common prefix with other words in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/Case2.png)

Deletion of word which shares a common prefix with other words in Trie


The solution for this case is to delete all the nodes starting from the end of the prefix to the last character of the given word.

3.3 The deleted word does not share any common prefix with other words in Trie.

As shown in the following figure, the word â€œgeekâ€ does not share any common prefix with any other words.

![Deletion of a word that does not share any common prefix with other words in Trie](https://raw.githubusercontent.com/GMyhf/img/main/img/case3.png)

Deletion of a word that does not share any common prefix with other words in Trie


The solution for this case is just to delete all the nodes.

Below is the implementation that handles all the above cases:

```python
def delete_key(root, word):
	current_node = root
	last_branch_node = None
	last_branch_char = 'a'

	# loop through each character in the word
	for c in word:
		# if the current node doesn't have a child with the current character,
		# return False as the word is not present in Trie
		if current_node.childNode[ord(c) - ord('a')] is None:
			return False
		else:
			count = 0
			# count the number of children nodes of the current node
			for i in range(26):
				if current_node.childNode[i] is not None:
					count += 1

			# if the count of children is more than 1,
			# store the node and the current character
			if count > 1:
				last_branch_node = current_node
				last_branch_char = c

			current_node = current_node.childNode[ord(c) - ord('a')]

	count = 0
	# count the number of children nodes of the current node
	for i in range(26):
		if current_node.childNode[i] is not None:
			count += 1

	# Case 1: The deleted word is a prefix of other words in Trie
	if count > 0:
		current_node.wordCount -= 1
		return True

	# Case 2: The deleted word shares a common prefix with other words in Trie
	if last_branch_node is not None:
		last_branch_node.childNode[ord(last_branch_char) - ord('a')] = None
		return True

	# Case 3: The deleted word does not share any common prefix with other words in Trie
	else:
		root.childNode[ord(word[0]) - ord('a')] = None
		return True

```

**How to implement Trie Data Structure?**

- Create a root node with the help of `TrieNode()` constructor.

- Store a collection of strings that we have to insert in the trie in a vector of strings say, `arr`.

- Inserting all strings in Trie with the help of the `insertkey()` function,

- Search strings from `searchQueryStrings\` with the help of `search_key()` function.

- Delete the strings present in the `deleteQueryStrings` with the help of `delete_key`.

  

```python
# Trie implementation in Python 

class TrieNode:
	def __init__(self):
		# pointer array for child nodes of each node
		self.childNode = [None] * 26
		self.wordCount = 0
		
def insert_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie.
		if not currentNode.childNode[ord(c) - ord('a')]:
			# If node for current character does not exist
			# then make a new node
			newNode = TrieNode()
			# Keep the reference for the newly created node.
			currentNode.childNode[ord(c) - ord('a')] = newNode
		# Now, move the current node pointer to the newly created node.
		currentNode = currentNode.childNode[ord(c) - ord('a')]
	# Increment the wordEndCount for the last currentNode
	# pointer this implies that there is a string ending at currentNode.
	currentNode.wordCount += 1
	
def search_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie.
		if not currentNode.childNode[ord(c) - ord('a')]:
			# Given word does not exist in Trie
			return False
		# Move the currentNode pointer to the already existing node for current character.
		currentNode = currentNode.childNode[ord(c) - ord('a')]

	return currentNode.wordCount > 0

def delete_key(root, word):
	currentNode = root
	lastBranchNode = None
	lastBrachChar = 'a'

	for c in word:
		if not currentNode.childNode[ord(c) - ord('a')]:
			return False
		else:
			count = 0
			for i in range(26):
				if currentNode.childNode[i]:
					count += 1
			if count > 1:
				lastBranchNode = currentNode
				lastBrachChar = c
			currentNode = currentNode.childNode[ord(c) - ord('a')]

	count = 0
	for i in range(26):
		if currentNode.childNode[i]:
			count += 1

	# Case 1: The deleted word is a prefix of other words in Trie.
	if count > 0:
		currentNode.wordCount -= 1
		return True

	# Case 2: The deleted word shares a common prefix with other words in Trie.
	if lastBranchNode:
		lastBranchNode.childNode[ord(lastBrachChar) - ord('a')] = None
		return True
	# Case 3: The deleted word does not share any common prefix with other words in Trie.
	else:
		root.childNode[ord(word[0]) - ord('a')] = None
		return True
# Driver Code
if __name__ == '__main__':
	# Make a root node for the Trie
	root = TrieNode()

	# Stores the strings that we want to insert in the Trie
	input_strings = ["and", "ant", "do", "geek", "dad", "ball"]

	# number of insert operations in the Trie
	n = len(input_strings)

	for i in range(n):
		insert_key(root, input_strings[i])

	# Stores the strings that we want to search in the Trie
	search_query_strings = ["do", "geek", "bat"]

	# number of search operations in the Trie
	search_queries = len(search_query_strings)

	for i in range(search_queries):
		print("Query String:", search_query_strings[i])
		if search_key(root, search_query_strings[i]):
			# the queryString is present in the Trie
			print("The query string is present in the Trie")
		else:
			# the queryString is not present in the Trie
			print("The query string is not present in the Trie")

	# stores the strings that we want to delete from the Trie
	delete_query_strings = ["geek", "tea"]

	# number of delete operations from the Trie
	delete_queries = len(delete_query_strings)

	for i in range(delete_queries):
		print("Query String:", delete_query_strings[i])
		if delete_key(root, delete_query_strings[i]):
			# The queryString is successfully deleted from the Trie
			print("The query string is successfully deleted")
		else:
			# The query string is not present in the Trie
			print("The query string is not present in the Trie")

# This code is contributed by Vikram_Shirsat

```

**Output**

```
Query String: do
The query string is present in the Trie
Query String: geek
The query string is present in the Trie
Query String: bat
The query string is not present in the Trie
Query String: geek
The query string is successfully deleted
Query String: tea
The query string is not present in the Trie
```

**Complexity Analysis of Trie Data Structure**

| Operation | Time Complexity | Auxiliary Space |
| :-------: | :-------------: | :-------------: |
| Insertion |      O(n)       |     O(n*m)      |
| Searching |      O(n)       |      O(1)       |
| Deletion  |      O(n)       |      O(1)       |

**Note:** In the above complexity table `n`, `m` represents the size of the string and the number of strings that are stored in the trie.

**Applications of Trie data structure:** 

1. Autocomplete Feature: Autocomplete provides suggestions based on what you type in the search box. Trie data structure is used to implement autocomplete functionality.  





![Autocomplete feature of Trie Data Structure](https://media.geeksforgeeks.org/wp-content/uploads/20220831154521/AutoComplete.png)

Autocomplete feature of Trie Data Structure

2. Spell Checkers: If the word typed does not appear in the dictionary, then it shows suggestions based on what you typed.
   It is a 3-step process that includes :

- Checking for the word in the data dictionary.

- Generating potential suggestions.

- Sorting the suggestions with higher priority on top.

Trie stores the data dictionary and makes it easier to build an algorithm for searching the word from the dictionary and provides the list of valid words for the suggestion.

3. Longest Prefix Matching Algorithm(Maximum Prefix Length Match): This algorithm is used in networking by the routing devices in IP networking. Optimization of network routes requires contiguous masking that bound the complexity of lookup a time to O(n), where n is the length of the URL address in bits.

To speed up the lookup process, Multiple Bit trie schemes were developed that perform the lookups of multiple bits faster.

**Advantages of Trie data structure:**

- Trie allows us to input and finds strings in O(l) time, where l is the length of a single word. It is faster as compared to both hash tables and binary search trees.
- It provides alphabetical filtering of entries by the key of the node and hence makes it easier to print all words in alphabetical order.
- Trie takes less space when compared to BST because the keys are not explicitly saved instead each key requires just an amortized fixed amount of space to be stored.
- Prefix search/Longest prefix matching can be efficiently done with the help of trie data structure.
- Since trie doesnâ€™t need any hash function for its implementation so they are generally faster than hash tables for small keys like integers and pointers.
- Tries support ordered iteration whereas iteration in a hash table will result in pseudorandom order given by the hash function which is usually more cumbersome.
- Deletion is also a straightforward algorithm with O(l) as its time complexity, where l is the length of the word to be deleted.

**Disadvantages of Trie data structure:**

- The main disadvantage of the trie is that it takes a lot of memory to store all the strings. For each node, we have too many node pointers which are equal to the no of characters in the worst case.
- An efficiently constructed hash table(i.e. a good hash function and a reasonable load factor) has O(1) as lookup time which is way faster than O(l) in the case of a trie, where l is the length of the string.



**Frequently asked questions (FAQs) about Trie Data Structure:**

**1. Is trie an advanced data structure?**

A Trie is an advanced data structure that is sometimes also known as a prefix tree

**2. What is the difference between trie and tree data structure?**

A tree is a general structure of recursive nodes. There are many types of trees. Popular ones are the binary tree and balanced tree. A Trie is a kind of tree, known by many names including prefix tree, digital search tree, and retrieval tree (hence the name â€˜trieâ€™).

**3. What are some applications of Trie?**

The longest common prefix, pattern searching, autocomplete and implementation of the dictionary are some of the common applications of a Trie Data Structure.

**4. Does Google use trie?**

Google even stores each word/sentence in the form of a trie.

**5. What is the advantage of trie?**

The main disadvantage of Trie is that it takes a lot of memory to store all the Strings. For each node, we have too many node pointers (equal to the number of characters of the alphabet).

**Conclusion:**

Our discussion so far has led us to the conclusion that the Trie data structure is a Tree based data structure that is used for storing some collection of strings and performing efficient search operations on them and we have also discussed the various advantage and applications of trie data structure.





## D $kd$ æ ‘ï¼ˆK Dimensional treeï¼‰

$k$è¿‘é‚»æ³•çš„å®ç°ï¼š$kd$æ ‘

$k$ è¿‘é‚»ç®—æ³•ï¼šç»™å®šä¸€ä¸ªè®­ç»ƒæ•°æ®é›†ï¼Œå¯¹æ–°çš„è¾“å…¥å®ä¾‹ï¼Œåœ¨è®­ç»ƒæ•°æ®é›†ä¸­æ‰¾åˆ°ä¸è¯¥å®ä¾‹æœ€é‚»è¿‘çš„ $k$ ä¸ªå®ä¾‹ï¼Œè¿™ $k$ ä¸ªå®ä¾‹çš„å¤šæ•°å±äºæŸä¸ªç±»ï¼Œå°±æŠŠè¯¥è¾“å…¥å®ä¾‹åˆ†ä¸ºè¿™ä¸ªç±»ã€‚

> **sklearn.neighbors.KNeighborsClassifier**
>
> - n_neighbors: ä¸´è¿‘ç‚¹ä¸ªæ•°
>
> - p: è·ç¦»åº¦é‡
>
> - algorithm: è¿‘é‚»ç®—æ³•ï¼Œå¯é€‰{'auto', 'ball_tree', 'kd_tree', 'brute'}
>
> - weights: ç¡®å®šè¿‘é‚»çš„æƒé‡
>
>   

$kd$ æ ‘æ˜¯ä¸€ç§å¯¹kç»´ç©ºé—´ä¸­çš„å®ä¾‹ç‚¹è¿›è¡Œå­˜å‚¨ä»¥ä¾¿å¯¹å…¶è¿›è¡Œå¿«é€Ÿæ£€ç´¢çš„æ ‘å½¢æ•°æ®ç»“æ„ã€‚

$kd$ æ ‘æ˜¯äºŒå‰æ ‘ï¼Œè¡¨ç¤ºå¯¹ $k$ ç»´ç©ºé—´çš„ä¸€ä¸ªåˆ’åˆ†ï¼ˆpartitionï¼‰ã€‚æ„é€  $kd$ æ ‘ç›¸å½“äºä¸æ–­åœ°ç”¨å‚ç›´äºåæ ‡è½´çš„è¶…å¹³é¢å°† $k$ ç»´ç©ºé—´åˆ‡åˆ†ï¼Œæ„æˆä¸€ç³»åˆ—çš„kç»´è¶…çŸ©å½¢åŒºåŸŸã€‚$kd$ æ ‘çš„æ¯ä¸ªç»“ç‚¹å¯¹åº”äºä¸€ä¸ª$k$ç»´è¶…çŸ©å½¢åŒºåŸŸã€‚

æ„é€ $kd$æ ‘çš„æ–¹æ³•å¦‚ä¸‹ï¼š

æ„é€ æ ¹ç»“ç‚¹ï¼Œä½¿æ ¹ç»“ç‚¹å¯¹åº”äº$k$ç»´ç©ºé—´ä¸­åŒ…å«æ‰€æœ‰å®ä¾‹ç‚¹çš„è¶…çŸ©å½¢åŒºåŸŸï¼›é€šè¿‡ä¸‹é¢çš„é€’å½’æ–¹æ³•ï¼Œä¸æ–­åœ°å¯¹$k$ç»´ç©ºé—´è¿›è¡Œåˆ‡åˆ†ï¼Œç”Ÿæˆå­ç»“ç‚¹ã€‚åœ¨è¶…çŸ©å½¢åŒºåŸŸï¼ˆç»“ç‚¹ï¼‰ä¸Šé€‰æ‹©ä¸€ä¸ªåæ ‡è½´å’Œåœ¨æ­¤åæ ‡è½´ä¸Šçš„ä¸€ä¸ªåˆ‡åˆ†ç‚¹ï¼Œç¡®å®šä¸€ä¸ªè¶…å¹³é¢ï¼Œè¿™ä¸ªè¶…å¹³é¢é€šè¿‡é€‰å®šçš„åˆ‡åˆ†ç‚¹å¹¶å‚ç›´äºé€‰å®šçš„åæ ‡è½´ï¼Œå°†å½“å‰è¶…çŸ©å½¢åŒºåŸŸåˆ‡åˆ†ä¸ºå·¦å³ä¸¤ä¸ªå­åŒºåŸŸ ï¼ˆå­ç»“ç‚¹ï¼‰ï¼›è¿™æ—¶ï¼Œå®ä¾‹è¢«åˆ†åˆ°ä¸¤ä¸ªå­åŒºåŸŸã€‚è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°å­åŒºåŸŸå†…æ²¡æœ‰å®ä¾‹æ—¶ç»ˆæ­¢ï¼ˆç»ˆæ­¢æ—¶çš„ç»“ç‚¹ä¸ºå¶ç»“ç‚¹ï¼‰ã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œå°†å®ä¾‹ä¿å­˜åœ¨ç›¸åº”çš„ç»“ç‚¹ä¸Šã€‚

é€šå¸¸ï¼Œä¾æ¬¡é€‰æ‹©åæ ‡è½´å¯¹ç©ºé—´åˆ‡åˆ†ï¼Œé€‰æ‹©è®­ç»ƒå®ä¾‹ç‚¹åœ¨é€‰å®šåæ ‡è½´ä¸Šçš„ä¸­ä½æ•° ï¼ˆmedianï¼‰ä¸ºåˆ‡åˆ†ç‚¹ï¼Œè¿™æ ·å¾—åˆ°çš„$kd$æ ‘æ˜¯å¹³è¡¡çš„ã€‚æ³¨æ„ï¼Œå¹³è¡¡çš„$kd$æ ‘æœç´¢æ—¶çš„æ•ˆç‡æœªå¿…æ˜¯æœ€ä¼˜çš„ã€‚



### D.1 æ„é€ å¹³è¡¡$kd$æ ‘ç®—æ³•

è¾“å…¥ï¼š$k$ç»´ç©ºé—´æ•°æ®é›†$Tï¼\{x1ï¼Œx2,â€¦,xN\}$ï¼Œ

å…¶ä¸­$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(k)}\right)^{\mathrm{T}}$

è¾“å‡ºï¼š$kd$æ ‘ã€‚

ï¼ˆ1ï¼‰å¼€å§‹ï¼šæ„é€ æ ¹ç»“ç‚¹ï¼Œæ ¹ç»“ç‚¹å¯¹åº”äºåŒ…å«Tçš„kç»´ç©ºé—´çš„è¶…çŸ©å½¢åŒºåŸŸã€‚

é€‰æ‹© $x^{(1)}$ ä¸ºåæ ‡è½´ï¼Œä»¥Tä¸­æ‰€æœ‰å®ä¾‹çš„ $x^{(1)}$ åæ ‡çš„ä¸­ä½æ•°ä¸ºåˆ‡åˆ†ç‚¹ï¼Œå°†æ ¹ç»“ç‚¹å¯¹åº”çš„è¶…çŸ©å½¢åŒºåŸŸåˆ‡åˆ†ä¸ºä¸¤ä¸ªå­åŒºåŸŸã€‚åˆ‡åˆ†ç”±é€šè¿‡åˆ‡åˆ†ç‚¹å¹¶ä¸åæ ‡è½´ $x^{(1)}$ å‚ç›´çš„è¶…å¹³é¢å®ç°ã€‚

ç”±æ ¹ç»“ç‚¹ç”Ÿæˆæ·±åº¦ä¸º1çš„å·¦ã€å³å­ç»“ç‚¹ï¼šå·¦å­ç»“ç‚¹å¯¹åº”åæ ‡ $x^{(1)}$ å°äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸï¼Œ å³å­ç»“ç‚¹å¯¹åº”äºåæ ‡ $x^{(1)}$ å¤§äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸã€‚

å°†è½åœ¨åˆ‡åˆ†è¶…å¹³é¢ä¸Šçš„å®ä¾‹ç‚¹ä¿å­˜åœ¨æ ¹ç»“ç‚¹ã€‚

ï¼ˆ2ï¼‰é‡å¤ï¼šå¯¹æ·±åº¦ä¸ºjçš„ç»“ç‚¹ï¼Œé€‰æ‹© $x^{(1)}$ ä¸ºåˆ‡åˆ†çš„åæ ‡è½´ï¼Œ$lï¼j(modk)+1$ï¼Œä»¥è¯¥ç»“ç‚¹çš„åŒºåŸŸä¸­æ‰€æœ‰å®ä¾‹çš„$x^{(1)}$åæ ‡çš„ä¸­ä½æ•°ä¸ºåˆ‡åˆ†ç‚¹ï¼Œå°†è¯¥ç»“ç‚¹å¯¹åº”çš„è¶…çŸ©å½¢åŒºåŸŸåˆ‡åˆ†ä¸ºä¸¤ä¸ªå­åŒºåŸŸã€‚åˆ‡åˆ†ç”±é€šè¿‡åˆ‡åˆ†ç‚¹å¹¶ä¸åæ ‡è½´x(1)å‚ç›´çš„è¶…å¹³é¢å®ç°ã€‚

ç”±è¯¥ç»“ç‚¹ç”Ÿæˆæ·±åº¦ä¸º $j+1$ çš„å·¦ã€å³å­ç»“ç‚¹ï¼šå·¦å­ç»“ç‚¹å¯¹åº”åæ ‡ $x^{(1)}$ å°äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸï¼Œå³å­ç»“ç‚¹å¯¹åº”åæ ‡ $x^{(1)}$ å¤§äºåˆ‡åˆ†ç‚¹çš„å­åŒºåŸŸã€‚

å°†è½åœ¨åˆ‡åˆ†è¶…å¹³é¢ä¸Šçš„å®ä¾‹ç‚¹ä¿å­˜åœ¨è¯¥ç»“ç‚¹ã€‚

ï¼ˆ3ï¼‰ç›´åˆ°ä¸¤ä¸ªå­åŒºåŸŸæ²¡æœ‰å®ä¾‹å­˜åœ¨æ—¶åœæ­¢ã€‚ä»è€Œå½¢æˆ $kd$ æ ‘çš„åŒºåŸŸåˆ’åˆ†ã€‚



> ã€$kd$ æ ‘æ˜¯å¦‚ä½•æ„é€ çš„ï¼Ÿ-å“”å“©å“”å“©ã€‘ https://b23.tv/KdKiJUb



### D.2 æœç´¢$kd$æ ‘

**æœ€è¿‘é‚»æœç´¢**

`find_nearest` å‡½æ•°ï¼š

- é€’å½’æœç´¢ $kd$ æ ‘ï¼Œå¯»æ‰¾ä¸ç›®æ ‡ç‚¹æœ€è¿‘çš„æ ·æœ¬ç‚¹ã€‚
- æ ¸å¿ƒé€»è¾‘ï¼š
  1. **é€’å½’åˆ°å¶èŠ‚ç‚¹**ï¼šç¡®å®šç›®æ ‡ç‚¹æ‰€åœ¨çš„å­ç©ºé—´ã€‚
  2. **æ›´æ–°æœ€è¿‘é‚»ä¿¡æ¯**ï¼šä»å¶èŠ‚ç‚¹å‘ä¸Šå›æº¯ï¼Œæ›´æ–°æœ€è¿‘é‚»ç‚¹å’Œè·ç¦»ã€‚
  3. å‰ªæä¼˜åŒ–ï¼šåˆ¤æ–­è¶…çƒä½“ï¼ˆç›®æ ‡ç‚¹ä¸ºçƒå¿ƒï¼Œå½“å‰æœ€è¿‘è·ç¦»ä¸ºåŠå¾„ï¼‰æ˜¯å¦ä¸åˆ†å‰²è¶…å¹³é¢ç›¸äº¤ã€‚
     - å¦‚æœä¸ç›¸äº¤ï¼Œåˆ™æ— éœ€è®¿é—®å¦ä¸€å­ç©ºé—´ã€‚
  4. **æ£€æŸ¥å¦ä¸€å­ç©ºé—´**ï¼šå¦‚æœè¶…çƒä½“ä¸åˆ†å‰²è¶…å¹³é¢ç›¸äº¤ï¼Œé€’å½’æ£€æŸ¥å¦ä¸€å­ç©ºé—´ï¼Œæ›´æ–°æœ€è¿‘é‚»ä¿¡æ¯ã€‚



> ã€$kd$ æ ‘çš„æœç´¢è¿‡ç¨‹-å“”å“©å“”å“©ã€‘ https://b23.tv/xzctdn1



### ç¤ºä¾‹ä»£ç  sklearn_kd_tree_demo.py

```python
#!/usr/bin/env python
# encoding: utf-8
"""
@author: HuRuiFeng
@file: kd_tree_demo.py
@time: 2021/8/3 17:08
@project: statistical-learning-method-solutions-manual
@desc: ä¹ é¢˜3.2 kdæ ‘çš„æ„å»ºä¸æ±‚æœ€è¿‘é‚»ç‚¹
"""

import numpy as np
from sklearn.neighbors import KDTree

# æ„é€ ä¾‹é¢˜3.2çš„æ•°æ®é›†
train_data = np.array([[2, 3],
                       [5, 4],
                       [9, 6],
                       [4, 7],
                       [8, 1],
                       [7, 2]])
# ï¼ˆ1ï¼‰ä½¿ç”¨sklearnçš„KDTreeç±»ï¼Œæ„å»ºå¹³è¡¡kdæ ‘
# è®¾ç½®leaf_sizeä¸º2ï¼Œè¡¨ç¤ºå¹³è¡¡æ ‘
tree = KDTree(train_data, leaf_size=2)

# ï¼ˆ2ï¼‰ä½¿ç”¨tree.queryæ–¹æ³•ï¼Œè®¾ç½®k=1ï¼ŒæŸ¥æ‰¾(3, 4.5)çš„æœ€è¿‘é‚»ç‚¹
# distè¡¨ç¤ºä¸æœ€è¿‘é‚»ç‚¹çš„è·ç¦»ï¼Œindè¡¨ç¤ºæœ€è¿‘é‚»ç‚¹åœ¨train_dataçš„ä½ç½®
dist, ind = tree.query(np.array([[3, 4.5]]), k=1)
node_index = ind[0]

# å¾—åˆ°æœ€è¿‘é‚»ç‚¹
x1 = train_data[node_index][0][0]
x2 = train_data[node_index][0][1]
print("xç‚¹çš„æœ€è¿‘é‚»ç‚¹æ˜¯({0}, {1})".format(x1, x2))
# è¾“å‡ºç»“æœä¸ºï¼šxç‚¹çš„æœ€è¿‘é‚»ç‚¹æ˜¯(2, 3)
```



### ç¤ºä¾‹ä»£ç  my_kd_tree.py

```python
from math import sqrt
from collections import namedtuple
import time
from random import random

# å®šä¹‰ä¸€ä¸ªnamedtuple,åˆ†åˆ«å­˜æ”¾æœ€è¿‘åæ ‡ç‚¹ã€æœ€è¿‘è·ç¦»å’Œè®¿é—®è¿‡çš„èŠ‚ç‚¹æ•°
result = namedtuple("Result_tuple",
                    "nearest_point  nearest_dist  nodes_visited")


# kd-treeæ¯ä¸ªç»“ç‚¹ä¸­ä¸»è¦åŒ…å«çš„æ•°æ®ç»“æ„å¦‚ä¸‹
class KdNode:
    def __init__(self, dom_elt, split, left, right):
        self.dom_elt = dom_elt  # kç»´å‘é‡èŠ‚ç‚¹(kç»´ç©ºé—´ä¸­çš„ä¸€ä¸ªæ ·æœ¬ç‚¹)
        self.split = split  # æ•´æ•°ï¼ˆè¿›è¡Œåˆ†å‰²ç»´åº¦çš„åºå·ï¼‰
        self.left = left  # è¯¥ç»“ç‚¹åˆ†å‰²è¶…å¹³é¢å·¦å­ç©ºé—´æ„æˆçš„kd-tree
        self.right = right  # è¯¥ç»“ç‚¹åˆ†å‰²è¶…å¹³é¢å³å­ç©ºé—´æ„æˆçš„kd-tree


class KdTree:
    def __init__(self, data):
        k = len(data[0])  # æ•°æ®ç»´åº¦

        def create_node(split, data_set):  # æŒ‰ç¬¬splitç»´åˆ’åˆ†æ•°æ®é›†,åˆ›å»ºKdNode
            if not data_set:  # æ•°æ®é›†ä¸ºç©º
                return None

            data_set.sort(key=lambda x: x[split])  # æŒ‰è¦è¿›è¡Œåˆ†å‰²çš„é‚£ä¸€ç»´æ•°æ®æ’åº
            split_pos = len(data_set) // 2  # æ•´æ•°é™¤æ³•å¾—åˆ°ä¸­é—´ä½ç½®
            median = data_set[split_pos]  # ä¸­ä½æ•°åˆ†å‰²ç‚¹
            split_next = (split + 1) % k  # cycle coordinates

            # é€’å½’çš„åˆ›å»ºkdæ ‘
            return KdNode(
                median,
                split,
                create_node(split_next, data_set[:split_pos]),  # åˆ›å»ºå·¦å­æ ‘
                create_node(split_next, data_set[split_pos + 1:]))  # åˆ›å»ºå³å­æ ‘

        self.root = create_node(0, data)  # ä»ç¬¬0ç»´åˆ†é‡å¼€å§‹æ„å»ºkdæ ‘,è¿”å›æ ¹èŠ‚ç‚¹


# KDTreeçš„å‰åºéå†
def preorder(root):
    print(root.dom_elt)
    if root.left:  # èŠ‚ç‚¹ä¸ä¸ºç©º
        preorder(root.left)
    if root.right:
        preorder(root.right)


# å¯¹æ„å»ºå¥½çš„kdæ ‘è¿›è¡Œæœç´¢ï¼Œå¯»æ‰¾ä¸ç›®æ ‡ç‚¹æœ€è¿‘çš„æ ·æœ¬ç‚¹ï¼š


def find_nearest(tree, point):
    k = len(point)  # æ•°æ®ç»´åº¦

    def travel(kd_node, target, max_dist):
        if kd_node is None:
            return result([0] * k, float("inf"), 0)

        nodes_visited = 1

        s = kd_node.split  # è¿›è¡Œåˆ†å‰²çš„ç»´åº¦
        pivot = kd_node.dom_elt  # è¿›è¡Œåˆ†å‰²çš„â€œè½´â€

        if target[s] <= pivot[s]:  # å¦‚æœç›®æ ‡ç‚¹ç¬¬sç»´å°äºåˆ†å‰²è½´çš„å¯¹åº”å€¼(ç›®æ ‡ç¦»å·¦å­æ ‘æ›´è¿‘)
            nearer_node = kd_node.left  # ä¸‹ä¸€ä¸ªè®¿é—®èŠ‚ç‚¹ä¸ºå·¦å­æ ‘æ ¹èŠ‚ç‚¹
            further_node = kd_node.right  # åŒæ—¶è®°å½•ä¸‹å³å­æ ‘
        else:  # ç›®æ ‡ç¦»å³å­æ ‘æ›´è¿‘
            nearer_node = kd_node.right  # ä¸‹ä¸€ä¸ªè®¿é—®èŠ‚ç‚¹ä¸ºå³å­æ ‘æ ¹èŠ‚ç‚¹
            further_node = kd_node.left

        temp1 = travel(nearer_node, target, max_dist)  # è¿›è¡Œéå†æ‰¾åˆ°åŒ…å«ç›®æ ‡ç‚¹çš„åŒºåŸŸ

        nearest = temp1.nearest_point  # ä»¥æ­¤å¶ç»“ç‚¹ä½œä¸ºâ€œå½“å‰æœ€è¿‘ç‚¹â€
        dist = temp1.nearest_dist  # æ›´æ–°æœ€è¿‘è·ç¦»

        nodes_visited += temp1.nodes_visited

        if dist < max_dist:
            max_dist = dist  # æœ€è¿‘ç‚¹å°†åœ¨ä»¥ç›®æ ‡ç‚¹ä¸ºçƒå¿ƒï¼Œmax_distä¸ºåŠå¾„çš„è¶…çƒä½“å†…

        temp_dist = abs(pivot[s] - target[s])  # ç¬¬sç»´ä¸Šç›®æ ‡ç‚¹ä¸åˆ†å‰²è¶…å¹³é¢çš„è·ç¦»
        if max_dist < temp_dist:  # åˆ¤æ–­è¶…çƒä½“æ˜¯å¦ä¸è¶…å¹³é¢ç›¸äº¤
            return result(nearest, dist, nodes_visited)  # ä¸ç›¸äº¤åˆ™å¯ä»¥ç›´æ¥è¿”å›ï¼Œä¸ç”¨ç»§ç»­åˆ¤æ–­

        # ----------------------------------------------------------------------
        # è®¡ç®—ç›®æ ‡ç‚¹ä¸åˆ†å‰²ç‚¹çš„æ¬§æ°è·ç¦»
        temp_dist = sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(pivot, target)))

        if temp_dist < dist:  # å¦‚æœâ€œæ›´è¿‘â€
            nearest = pivot  # æ›´æ–°æœ€è¿‘ç‚¹
            dist = temp_dist  # æ›´æ–°æœ€è¿‘è·ç¦»
            max_dist = dist  # æ›´æ–°è¶…çƒä½“åŠå¾„

        # æ£€æŸ¥å¦ä¸€ä¸ªå­ç»“ç‚¹å¯¹åº”çš„åŒºåŸŸæ˜¯å¦æœ‰æ›´è¿‘çš„ç‚¹
        temp2 = travel(further_node, target, max_dist)

        nodes_visited += temp2.nodes_visited
        if temp2.nearest_dist < dist:  # å¦‚æœå¦ä¸€ä¸ªå­ç»“ç‚¹å†…å­˜åœ¨æ›´è¿‘è·ç¦»
            nearest = temp2.nearest_point  # æ›´æ–°æœ€è¿‘ç‚¹
            dist = temp2.nearest_dist  # æ›´æ–°æœ€è¿‘è·ç¦»

        return result(nearest, dist, nodes_visited)

    return travel(tree.root, point, float("inf"))  # ä»æ ¹èŠ‚ç‚¹å¼€å§‹é€’å½’


data = [[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]]
kd = KdTree(data)
preorder(kd.root)
"""
[7, 2]
[5, 4]
[2, 3]
[4, 7]
[9, 6]
[8, 1]
"""

ret = find_nearest(kd, [3, 4.5])
print(ret)
# Result_tuple(nearest_point=[2, 3], nearest_dist=1.8027756377319946, nodes_visited=4)

# äº§ç”Ÿä¸€ä¸ªkç»´éšæœºå‘é‡ï¼Œæ¯ç»´åˆ†é‡å€¼åœ¨0~1ä¹‹é—´
def random_point(k):
    return [random() for _ in range(k)]


# äº§ç”Ÿnä¸ªkç»´éšæœºå‘é‡
def random_points(k, n):
    return [random_point(k) for _ in range(n)]


N = 400000
# åœ¨å¼€å§‹æ—¶è®°å½•è¿›ç¨‹æ—¶é—´
start_cpu_time = time.process_time()

kd2 = KdTree(random_points(3, N))  # æ„å»ºåŒ…å«å››åä¸‡ä¸ª3ç»´ç©ºé—´æ ·æœ¬ç‚¹çš„kdæ ‘
ret2 = find_nearest(kd2, [0.1, 0.5, 0.8])  # å››åä¸‡ä¸ªæ ·æœ¬ç‚¹ä¸­å¯»æ‰¾ç¦»ç›®æ ‡æœ€è¿‘çš„ç‚¹

# åœ¨ç»“æŸæ—¶å†æ¬¡è®°å½•è¿›ç¨‹æ—¶é—´
end_cpu_time = time.process_time()

# è®¡ç®—å¹¶æ‰“å°æ‰€ç”¨çš„CPUæ—¶é—´
elapsed_cpu_time = end_cpu_time - start_cpu_time
print(f"Elapsed CPU time: {elapsed_cpu_time:0.4f} seconds")

print(ret2)
# Elapsed CPU time: 3.9399 seconds
# Result_tuple(nearest_point=[0.09951475212182137, 0.4971758210372218, 0.8019299872473542], nearest_dist=0.0034548955254863362, nodes_visited=46)

```





## E æ ‘è¿™ç« ç¨‹åºå¯¹åº”ç±»å›¾

### E.1 ç”Ÿæˆç±»å›¾

https://github.com/Yuqiu-Yang/problem_solving_with_algorithms_and_data_structures_using_python

ä¸‹è½½åï¼Œåˆ°ch6ç›®å½•ï¼Œç”Ÿæˆç±»å›¾ã€‚



> https://stackoverflow.com/questions/260165/whats-the-best-way-to-generate-a-uml-diagram-from-python-source-code
>
> You may have heard of [Pylint](http://www.pylint.org/) that helps statically checking Python code. Few people know that it comes with a tool named [Pyreverse](https://pylint.pycqa.org/en/latest/pyreverse.html) that draws UML diagrams from the Python code it reads. Pyreverse uses Graphviz as a backend.
>
> It is used like this:
>
> ```none
> pyreverse -o png -p yourpackage .
> ```
>
> where the `.` can also be a single file.



Generating UML Diagrams

https://www.bhavaniravi.com/python/generate-uml-diagrams-from-python-code

brew install pylint

brew install Graphviz 



åœ¨ ch6ç›®å½•ä¸‹è¿è¡Œ

% pyreverse -o png *.py                     

> Format png is not supported natively. Pyreverse will try to generate it using Graphviz...
>
> Analysed 12 modules with a total of 6 imports

äº§ç”Ÿä¿©æ–‡ä»¶

![image-20240204154709659](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240204154709659.png)

å›¾ packages.png





![image-20240204154437448](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240204154437448.png)

å›¾ classes.png



### E.2 åœ¨UMLç±»å›¾ä¸­ï¼Œå¸¸è§çš„è¿çº¿å’Œç¬¦å·



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/891cfde691e54661923699d89c198373.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom: 67%;" />



åœ¨UMLï¼ˆç»Ÿä¸€å»ºæ¨¡è¯­è¨€ï¼‰ç±»å›¾ä¸­ï¼Œå¸¸è§çš„è¿çº¿å’Œç¬¦å·åŒ…æ‹¬ä»¥ä¸‹è¿™äº›ï¼š

1. å…³è”(Association)

   - æ™®é€šå…³è”ï¼šç”¨ä¸€æ¡ç›´çº¿è¡¨ç¤ºä¸¤ä¸ªç±»ä¹‹é—´çš„å…³ç³»ï¼Œé€šå¸¸åœ¨å…³è”çš„ä¸¤ç«¯å¯ä»¥æœ‰ç®­å¤´ï¼Œç®­å¤´æŒ‡å‘è¢«å…³è”çš„ç±»ï¼Œè¡¨ç¤ºå¯¼èˆªæ–¹å‘ã€‚

   - åŒå‘å…³è”ï¼šä¸€æ¡ç®€å•çš„çº¿ï¼Œè¡¨ç¤ºä¸¤ä¸ªç±»ç›¸äº’çŸ¥é“å¯¹æ–¹ã€‚

   - èšåˆå…³ç³»(Aggregation)ï¼šç”¨ä¸€ä¸ªç©ºå¿ƒçš„è±å½¢åŠ ä¸€æ¡çº¿æ¥è¡¨ç¤ºï¼Œç©ºå¿ƒè±å½¢ä½äºæ•´ä½“çš„ä¸€ç«¯ã€‚è¡¨ç¤ºä¸€ä¸ªç±»æ˜¯å¦ä¸€ä¸ªç±»çš„éƒ¨åˆ†ï¼Œä½†å®ƒä»¬ä¹‹é—´æ²¡æœ‰å¼ºè€¦åˆå…³ç³»ï¼Œéƒ¨åˆ†å¯ä»¥å­˜åœ¨ç‹¬ç«‹äºæ•´ä½“çš„æƒ…å†µã€‚è±å½¢æŒ‡å‘æ•´ä½“ç±»ã€‚ä¾‹å¦‚ï¼š

     <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/381dc758d91249208d20709e4fd67a8e.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom: 67%;" />

   - ç»„åˆå…³ç³»(Composition)ï¼šç”¨ä¸€ä¸ªå®å¿ƒçš„è±å½¢åŠ ä¸€æ¡çº¿æ¥è¡¨ç¤ºï¼Œå®å¿ƒè±å½¢ä½äºæ•´ä½“çš„ä¸€ç«¯ã€‚è¡¨ç¤ºä¸€ä¸ªç±»æ˜¯å¦ä¸€ä¸ªç±»çš„æ•´ä½“éƒ¨åˆ†ï¼Œå®ƒä»¬å…·æœ‰ç”Ÿå‘½å‘¨æœŸä¸Šçš„æ•´ä½“å…³ç³»ã€‚è±å½¢æŒ‡å‘æ•´ä½“ç±»ã€‚ä¾‹å¦‚ï¼š

     <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/338de2b8eaf2425cbf060ade0f38a0f6.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom:67%;" />

2. æ³›åŒ–(Generalization)

   - ç”¨ä¸€æ¡å¸¦æœ‰ç©ºå¿ƒç®­å¤´çš„ç›´çº¿è¡¨ç¤ºï¼Œç®­å¤´æŒ‡å‘çˆ¶ç±»ï¼Œè¡¨ç¤ºå­ç±»ç»§æ‰¿è‡ªçˆ¶ç±»ã€‚è¡¨ç¤ºç»§æ‰¿å…³ç³»ï¼Œä¸€ä¸ªç±»æ˜¯å¦ä¸€ä¸ªç±»çš„å­ç±»ï¼Œç»§æ‰¿äº†çˆ¶ç±»çš„å±æ€§å’Œæ–¹æ³•ã€‚ä¾‹å¦‚ï¼š

     <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/7b6c62e666e44a56987f1e222c498b6f.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom:67%;" />

3. å®ç°(Implementation)

   - ç”¨ä¸€æ¡å¸¦æœ‰ç©ºå¿ƒç®­å¤´çš„è™šçº¿è¡¨ç¤ºï¼Œç®­å¤´æŒ‡å‘æ¥å£ï¼Œè¡¨ç¤ºç±»å®ç°äº†æ¥å£ã€‚

4. ä¾èµ–(Dependency)

   - ç”¨ä¸€æ¡å¸¦æœ‰ç®­å¤´çš„è™šçº¿è¡¨ç¤ºï¼Œç®­å¤´æŒ‡å‘è¢«ä¾èµ–çš„ç±»ã€‚

åœ¨ç±»å›¾ä¸­ï¼Œç±»é€šå¸¸ç”¨å¸¦æœ‰ä¸‰ä¸ªéƒ¨åˆ†çš„çŸ©å½¢æ¥è¡¨ç¤ºï¼š

- é¡¶éƒ¨éƒ¨åˆ†ï¼šæ˜¾ç¤ºç±»åï¼Œå¦‚æœæ˜¯æŠ½è±¡ç±»ï¼Œåˆ™ç”¨æ–œä½“è¡¨ç¤ºã€‚
- ä¸­é—´éƒ¨åˆ†ï¼šæ˜¾ç¤ºç±»çš„å±æ€§æˆ–å­—æ®µã€‚
- åº•éƒ¨éƒ¨åˆ†ï¼šæ˜¾ç¤ºç±»çš„æ–¹æ³•æˆ–æ“ä½œã€‚

è¿˜æœ‰ä¸€äº›å…¶ä»–çš„ç¬¦å·å’Œçº¦å®šï¼Œæ¯”å¦‚è¡¨ç¤ºå¤šé‡æ€§çš„æ•°å­—ï¼ˆä¾‹å¦‚ï¼Œ1â€¦* è¡¨ç¤ºä¸€ä¸ªåˆ°å¤šä¸ªï¼‰ï¼Œä»¥åŠç”¨æ¥è¡¨ç¤ºæ¥å£ã€æŠ½è±¡ç±»ç­‰çš„ç‰¹æ®Šå›¾æ ‡ã€‚åœ¨ç±»å›¾ä¸­ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨æ³¨é‡Šæ¡†ï¼ˆç”¨ä¸€æ¡è™šçº¿è¿æ¥çš„çŸ©å½¢æ¡†ï¼‰æ¥æ·»åŠ å¯¹å…³ç³»æˆ–ç±»çš„é¢å¤–è¯´æ˜ã€‚







# å‚è€ƒ

Problem Solving with Algorithms and Data Structures using Python

https://runestone.academy/ns/books/published/pythonds3/index.html



https://github.com/Yuqiu-Yang/problem_solving_with_algorithms_and_data_structures_using_python

https://github.com/wesleyjtann/Problem-Solving-with-Algorithms-and-Data-Structures-Using-Python

ã€å°æ²å­¦Pythonã€‘UMLç±»å›¾çš„ç®­å¤´è¿çº¿å…³ç³»æ€»ç»“ï¼ˆpython+graphvizï¼‰

https://blog.csdn.net/hhy321/article/details/132651062


# Week4ï½5 çº¿æ€§æ•°æ®ç»“æ„&æ—¶é—´å¤æ‚åº¦

Updated 1601 GMT+8 Mar 19, 2025

2025 spring, Complied by Hongfei Yan



Logs:

> 2025/03/18, week5, è®²æ—¶é—´å¤æ‚åº¦ã€æ ˆã€é˜Ÿåˆ— 
>
> 2025/03/11, week4, å› ä¸ºassign#4 ç•™äº†é“¾è¡¨é¢˜ç›®ï¼Œæˆ‘ä»¬<mark>å…ˆä» 3 åŸºæœ¬æ•°æ®ç»“æ„è®²èµ·</mark>ï¼Œä¹‹åå†è®² 2 æ—¶é—´å¤æ‚åº¦ã€‚
>
> cs201æ•°ç®—ï¼ˆè®¡ç®—æœºåŸºç¡€2/2ï¼‰2025preæ¯æ—¥é€‰åšï¼Œhttps://github.com/GMyhf/2025spring-cs201/blob/main/pre_problem_list_2025spring.md
>
> ã€ŠPythonæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹v2ä¸v3åŸºæœ¬ä¸€è‡´çš„ï¼Œæ–°ç‰ˆç¨‹åºæ›´è§„èŒƒäº†ã€‚æˆ‘ä»¬ä¼šé€‰è®²v3éƒ¨åˆ†å†…å®¹ï¼Œä¹¦ä¸Šä¸è¶³çš„åœ°æ–¹ï¼Œæœ‰å…¶ä»–ææ–™è¡¥å……ã€‚https://runestone.academy/ns/books/published/pythonds3/index.html



# 0 Recapå¤ä¹ 

## 0.1 OOPé¢å‘å¯¹è±¡ç¼–ç¨‹

### 18161: çŸ©é˜µè¿ç®—ï¼ˆå…ˆä¹˜å†åŠ ï¼‰

matrices, OOP, http://cs101.openjudge.cn/practice/18161



åˆ›å»º<mark>è‡ªå·±çš„æ•°æ®ç±»å‹</mark>

```python
# é¢œé¼å ƒ 24å·¥å­¦é™¢
class Matrix():
    def __init__(self, row, col, val):
        self.row = row
        self.col = col
        self.val = val

    def __add__(self, other):
        if self.row != other.row or self.col != other.col:
            raise ValueError
        ans = [[self.val[i][j] + other.val[i][j] for j in range(self.col)] for i in range(self.row)]
        return Matrix(self.row, self.col, ans)

    def __str__(self):
        ans = []
        for r in self.val:
            ans.append(" ".join(map(str, r)))
        return "\n".join(ans)

    def __mul__(self, other):
        if self.col != other.row:
            raise ValueError
        ans = [[0 for i in range(other.col)] for j in range(self.row)]
        for i in range(self.row):
            for j in range(other.col):
                for k in range(self.col):
                    ans[i][j] += self.val[i][k] * other.val[k][j]
        return Matrix(self.row, other.col, ans)


A = []
for i in range(3):
    row, col = map(int, input().split())
    val = [list(map(int, input().split())) for i in range(row)]
    A.append(Matrix(row, col, val))
try:
    print(A[0] * A[1] + A[2])
except ValueError:
    print("Error!")
```



### 19942: äºŒç»´çŸ©é˜µä¸Šçš„å·ç§¯è¿ç®—

matrices, OOP, http://cs101.openjudge.cn/practice/19942/

OOP<mark>ç»§æ‰¿</mark>

```python
class Matrix():
    def __init__(self, row, col, val):
        self.row = row
        self.col = col
        self.val = val

    def __add__(self, other):
        if self.row != other.row or self.col != other.col:
            raise ValueError
        ans = [[self.val[i][j] + other.val[i][j] for j in range(self.col)] for i in range(self.row)]
        return Matrix(self.row, self.col, ans)

    def __str__(self):
        ans = []
        for r in self.val:
            ans.append(" ".join(map(str, r)))
        return "\n".join(ans)

    def __mul__(self, other):
        if self.col != other.row:
            raise ValueError
        ans = [[0 for i in range(other.col)] for j in range(self.row)]
        for i in range(self.row):
            for j in range(other.col):
                for k in range(self.col):
                    ans[i][j] += self.val[i][k] * other.val[k][j]
        return Matrix(self.row, other.col, ans)


class ConvMatrix(Matrix):
    def __init__(self, row, col, val):
        super().__init__(row, col, val)

    def conv2d(self, kernel):
        # è·å–å·ç§¯æ ¸çš„å°ºå¯¸
        k_row, k_col = len(kernel), len(kernel[0])

        # è®¡ç®—è¾“å‡ºçŸ©é˜µçš„å°ºå¯¸
        out_row = self.row - k_row + 1
        out_col = self.col - k_col + 1

        # åˆå§‹åŒ–è¾“å‡ºçŸ©é˜µ
        output_val = [[0] * out_col for _ in range(out_row)]

        # è¿›è¡Œå·ç§¯è¿ç®—
        for i in range(out_row):
            for j in range(out_col):
                for ki in range(k_row):
                    for kj in range(k_col):
                        output_val[i][j] += self.val[i + ki][j + kj] * kernel[ki][kj]

        return Matrix(out_row, out_col, output_val)


if __name__ == "__main__":
    m, n, p, q = map(int, input().split())
    M = ConvMatrix(m, n, [list(map(int, input().split())) for _ in range(m)])

    kernel = []
    for _ in range(p):
        kernel.append(list(map(int, input().split())))

    result = M.conv2d(kernel)
    for row in result.val:
        print(" ".join(map(str, row)))
```



## 0.2 binary search + greedyäºŒåˆ†

äºŒåˆ†+è´ªå¿ƒé¢˜ç›®ç±»å‹ï¼Œéœ€è¦æŒæ¡äº†ã€‚è¿™ç±»é—®é¢˜é€šå¸¸æ¶‰åŠæ±‚è§£æœ€å°åŒ–æœ€å¤§å€¼ï¼ˆminMaxï¼‰æˆ–æœ€å¤§åŒ–æœ€å°å€¼ï¼ˆmaxMinï¼‰ã€‚é‡åˆ°æ­¤ç±»é—®é¢˜æ—¶ï¼Œåº”è€ƒè™‘ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾é…åˆè´ªå¿ƒç­–ç•¥æ¥è¿›è¡Œåˆ¤å®šã€‚

> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20231212104106505.png" alt="image-20231212104106505" style="zoom:50%;" />
>
> æ•°é™¢èƒ¡ç¿è¯šï¼šè¿™å°±æ˜¯ä¸ªæ±‚æœ€å°å€¼çš„æœ€å¤§å€¼æˆ–è€…æœ€å¤§å€¼çš„æœ€å°å€¼çš„ä¸€ä¸ªå¥—è·¯ã€‚
>
> æ±‚æœ€å€¼è½¬åŒ–ä¸ºåˆ¤å®šå¯¹ä¸å¯¹ï¼Œåˆ¤å®šé—®é¢˜æ˜¯å¯ä»¥ç”¨è´ªå¿ƒè§£å†³çš„ï¼Œç„¶åç”¨äºŒåˆ†åªç”¨åˆ¤å®šlogæ¬¡ã€‚



### 08210: æ²³ä¸­è·³æˆ¿å­/çŸ³å¤´

binary search/greedy, http://cs101.openjudge.cn/practice/08210



```python
L,n,m = map(int,input().split())
rock = [0]
for i in range(n):
    rock.append(int(input()))
rock.append(L)

def check(x):
    num = 0
    now = 0
    for i in range(1, n+2):
        if rock[i] - now < x:
            num += 1
        else:
            now = rock[i]
            
    if num > m:
        return True
    else:
        return False

# https://github.com/python/cpython/blob/main/Lib/bisect.py
'''
2022fall-cs101ï¼Œåˆ˜å­é¹ï¼Œå…ƒåŸ¹ã€‚
æºç çš„äºŒåˆ†æŸ¥æ‰¾é€»è¾‘æ˜¯ç»™å®šä¸€ä¸ªå¯è¡Œçš„ä¸‹ç•Œå’Œä¸å¯è¡Œçš„ä¸Šç•Œï¼Œé€šè¿‡äºŒåˆ†æŸ¥æ‰¾ï¼Œå°†èŒƒå›´ç¼©å°åŒæ—¶ä¿æŒä¸‹ç•Œå¯è¡Œè€ŒåŒºé—´å†…ä¸Šç•Œä¸ç¬¦åˆï¼Œ
ä½†è¿™ç§æœ€åprint(lo-1)çš„å†™æ³•çš„åŸºç¡€æ˜¯æœ€åå¤¹å‡ºæ¥ä¸€ä¸ªä¸å¯è¡Œçš„ä¸Šç•Œï¼Œä½†å…¶å®Låœ¨è¿™ç§æƒ…å†µä¸‹æœ‰å¯èƒ½æ˜¯å¯è¡Œçš„
ï¼ˆè€ƒè™‘æ‰€æœ‰å¯ä»¥ç§»é™¤æ‰€æœ‰å²©çŸ³çš„æƒ…å†µï¼‰ï¼Œæ‰€ä»¥æˆ‘è§‰å¾—åº”è¯¥å°†ä¸Šç•Œä¿®æ”¹ä¸ºä¸å¯èƒ½çš„ L+1 çš„é€»è¾‘æ‰æ˜¯æ­£ç¡®ã€‚
ä¾‹å¦‚ï¼š
25 5 5
1
2
3
4
5

åº”è¯¥è¾“å‡º 25
'''
# lo, hi = 0, L
lo, hi = 0, L+1
ans = -1
while lo < hi:
    mid = (lo + hi) // 2
    
    if check(mid):
        hi = mid
    else:               # è¿”å›Falseï¼Œæœ‰å¯èƒ½æ˜¯num==m
        ans = mid       # å¦‚æœnum==m, midå°±æ˜¯ç­”æ¡ˆ
        lo = mid + 1
        
#print(lo-1)
print(ans)
```



### 04135: æœˆåº¦å¼€é”€

binary search/greedy , http://cs101.openjudge.cn/practice/04135



```python
n,m = map(int, input().split())
expenditure = []
for _ in range(n):
    expenditure.append(int(input()))

def check(x):
    num, s = 1, 0
    for i in range(n):
        if s + expenditure[i] > x:
            s = expenditure[i]
            num += 1
        else:
            s += expenditure[i]
    
    return [False, True][num > m]

# https://github.com/python/cpython/blob/main/Lib/bisect.py
lo = max(expenditure)
# hi = sum(expenditure)
hi = sum(expenditure) + 1
ans = 1
while lo < hi:
    mid = (lo + hi) // 2
    if check(mid):      # è¿”å›Trueï¼Œæ˜¯å› ä¸ºnum>mï¼Œæ˜¯ç¡®å®šä¸åˆé€‚
        lo = mid + 1    # æ‰€ä»¥loå¯ä»¥ç½®ä¸º mid + 1ã€‚
    else:
        ans = mid    # å¦‚æœnum==m, midå°±æ˜¯ç­”æ¡ˆ
        hi = mid
        
#print(lo)
print(ans)
```



### LC1760.è¢‹å­é‡Œæœ€å°‘æ•°ç›®çš„çƒ

ä¸­ç­‰, äºŒåˆ†æŸ¥æ‰¾ï¼Œhttps://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/



Deepseek Coder v2 Lite Instruct 4bit mlx: Beaking the Barrier of Closed-Source models in Code Intelligence. 16B, 8.84GB, last updated: 238 days ago.



![image-20250311094233684](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250311094233684.png)



è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥æ‰¾åˆ°æœ€å°çš„å¼€é”€ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬è®¾å®šä¸€ä¸ªå¯èƒ½çš„æœ€å°å¼€é”€ `x`ï¼Œç„¶åæ£€æŸ¥æ˜¯å¦å¯ä»¥åœ¨ç»™å®šçš„æ“ä½œæ¬¡æ•°å†…å°†æ‰€æœ‰è¢‹å­ä¸­çš„çƒæ•°ç›®å‡å°‘åˆ° `x` ä»¥ä¸‹ã€‚å¦‚æœå¯ä»¥ï¼Œæˆ‘ä»¬å°±å°è¯•ç¼©å°å¼€é”€ï¼›å¦åˆ™ï¼Œæˆ‘ä»¬å°±å¢å¤§å¼€é”€ã€‚

ä¸‹é¢æ˜¯å®ç°è¿™ä¸ªç®—æ³•çš„ Python ä»£ç ï¼š

```python
def min_cost(nums, maxOperations):
    def can_achieve(threshold):
        operations = 0
        for num in nums:
            if num > threshold:
                operations += (num - 1) // threshold
        return operations <= maxOperations
    
    left, right = 1, max(nums)
    while left < right:
        mid = (left + right) // 2
        if can_achieve(mid):
            right = mid
        else:
            left = mid + 1
    return left

# ç¤ºä¾‹æµ‹è¯•
nums1 = [9]
maxOperations1 = 2
print(min_cost(nums1, maxOperations1))  # è¾“å‡º: 3

nums2 = [2, 4, 8, 2]
maxOperations2 = 4
print(min_cost(nums2, maxOperations2))  # è¾“å‡º: 2

nums3 = [7, 17]
maxOperations3 = 2
print(min_cost(nums3, maxOperations3))  # è¾“å‡º: 7
```

ä»£ç è§£é‡Šï¼š

1. **`can_achieve(threshold)`**:
   - è¿™ä¸ªå‡½æ•°ç”¨äºæ£€æŸ¥åœ¨ç»™å®šçš„æ“ä½œæ¬¡æ•°å†…ï¼Œæ˜¯å¦å¯ä»¥å°†æ‰€æœ‰è¢‹å­ä¸­çš„çƒæ•°ç›®å‡å°‘åˆ° `threshold` ä»¥ä¸‹ã€‚
   - å¯¹äºæ¯ä¸ªè¢‹å­ï¼Œå¦‚æœè¢‹å­ä¸­çš„çƒæ•°ç›®å¤§äº `threshold`ï¼Œæˆ‘ä»¬å°±éœ€è¦è¿›è¡Œåˆ†å‰²æ“ä½œã€‚å…·ä½“æ¥è¯´ï¼Œåˆ†å‰²çš„æ¬¡æ•°æ˜¯ `(num - 1) // threshold`ã€‚
   - å¦‚æœæ€»çš„åˆ†å‰²æ¬¡æ•°ä¸è¶…è¿‡ `maxOperations`ï¼Œé‚£ä¹ˆå°±è¿”å› `True`ï¼Œå¦åˆ™è¿”å› `False`ã€‚

2. **äºŒåˆ†æŸ¥æ‰¾**:
   - æˆ‘ä»¬è®¾å®šä¸€ä¸ªå¯èƒ½çš„æœ€å°å¼€é”€ `left` ä¸º `1`ï¼Œæœ€å¤§å¼€é”€ `right` ä¸º `max(nums)`ã€‚
   - åœ¨æ¯æ¬¡è¿­ä»£ä¸­ï¼Œè®¡ç®—ä¸­é—´å€¼ `mid`ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦å¯ä»¥åœ¨è¿™ä¸ªå¼€é”€ä¸‹å®Œæˆåˆ†å‰²æ“ä½œã€‚
   - å¦‚æœå¯ä»¥ï¼Œå°±å°è¯•ç¼©å°å¼€é”€èŒƒå›´ï¼ˆå³ `right = mid`ï¼‰ï¼›å¦åˆ™ï¼Œå¢å¤§å¼€é”€èŒƒå›´ï¼ˆå³ `left = mid + 1`ï¼‰ã€‚
   - æœ€ç»ˆï¼Œå½“ `left` å’Œ `right` ç›¸ç­‰æ—¶ï¼Œå°±æ‰¾åˆ°äº†æœ€å°çš„å¼€é”€ã€‚

è¿™ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n log m)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ï¼Œm æ˜¯æ•°ç»„ä¸­æœ€å¤§å…ƒç´ çš„å€¼ã€‚è¿™ä¸ªå¤æ‚åº¦æ˜¯å¯ä»¥æ¥å—çš„ï¼Œå› ä¸ºé¢˜ç›®ç»™å®šçš„çº¦æŸæ¡ä»¶æ˜¯ `1 <= nums[i] <= 10^9`ï¼Œæ‰€ä»¥ `m` çš„æœ€å¤§å€¼æ˜¯ `10^9`ã€‚







## 0.3 Information Retrievalä¸­çš„å€’æ’ç´¢å¼•

ä¿¡æ¯æ£€ç´¢ä¸­çš„å€’æ’ç´¢å¼•

æœç´¢å¼•æ“çš„å·¥ä½œæœºåˆ¶æ¶‰åŠç½‘é¡µçš„æŠ“å–ï¼Œæ¯ä¸ªè¢«è·å–åˆ°çš„ç½‘é¡µè¢«è§†ä¸ºä¸€ä¸ªæ–‡æ¡£ï¼ˆdocï¼‰ï¼Œå¹¶è¢«å¤„ç†è½¬åŒ–ä¸ºä¸€ç³»åˆ—çš„æ ‡è®°ï¼ˆtokenï¼‰ã€‚ä¸ºäº†ç¡®ä¿åœ¨ç”¨æˆ·è¿›è¡Œæœç´¢æ—¶èƒ½å¤Ÿå¿«é€Ÿå“åº”ï¼Œæœç´¢å¼•æ“ä¼šé¢„å…ˆæ„å»ºä¸€ç§ä»æ ‡è®°åˆ°æ–‡æ¡£çš„æ˜ å¼•ç»“æ„ï¼Œå³æ‰€è°“çš„å€’æ’ç´¢å¼•ã€‚è¿™æ˜¯å› ä¸ºç”¨æˆ·çš„æŸ¥è¯¢è¾“å…¥é€šå¸¸æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªæ ‡è®°ã€‚

å…·ä½“æ¥è¯´ï¼Œä»æ–‡æ¡£åˆ°æ ‡è®°çš„æ˜ å°„è¢«ç§°ä¸º**æ­£æ’ç´¢å¼•**ï¼Œè€Œä»æ ‡è®°æŒ‡å‘åŒ…å«è¯¥æ ‡è®°çš„æ–‡æ¡£ï¼ˆä¾‹å¦‚ï¼šæ ‡è®° -> æ–‡æ¡£_i, æ–‡æ¡£_j, ...ï¼‰çš„æ˜ å°„åˆ™è¢«ç§°ä¸º**å€’æ’ç´¢å¼•**ã€‚è¿™ç§å‘½åæ–¹å¼æ­£æ˜¯åŸºäºä¸Šè¿°ä¸¤ç§æ˜ å°„çš„æ–¹å‘æ€§å·®å¼‚è€Œæ¥çš„ã€‚å€’æ’ç´¢å¼•æ˜¯æå‡æœç´¢æ•ˆç‡çš„å…³é”®æŠ€æœ¯ä¹‹ä¸€ï¼Œå®ƒä½¿å¾—æœç´¢å¼•æ“èƒ½å¤Ÿåœ¨å¤§é‡æ–‡æ¡£ä¸­è¿…é€Ÿå®šä½åˆ°å«æœ‰ç‰¹å®šæ ‡è®°çš„æ‰€æœ‰æ–‡æ¡£ã€‚



### 06640: å€’æ’ç´¢å¼•

data structures, http://cs101.openjudge.cn/practice/06640/



è¾“å…¥ç»™å‡ºçš„æ˜¯æ­£æ’ç´¢å¼•ï¼Œè¾“å‡ºè¦æ±‚å€’æ’ç´¢å¼•

```python
from collections import defaultdict
def main():
    n = int(input())
    index = 1
    inverted_index = defaultdict(set)   # æ„å»ºå€’æ’ç´¢å¼•
    for i in range(1, n + 1):
        parts = input().split()
        doc_id = i
        num_words = int(parts[0])
        words = parts[1:num_words + 1]
        for word in words:
            inverted_index[word].add(doc_id)

    m = int(input())
    results = []

    # æŸ¥è¯¢å€’æ’ç´¢å¼•
    for _ in range(m):
        query = input()
        if query in inverted_index:
            results.append(" ".join(map(str, sorted(list(inverted_index[query])))))
        else:
            results.append("NOT FOUND")

    # è¾“å‡ºæŸ¥è¯¢ç»“æœ
    for result in results:
        print(result)

if __name__ == "__main__":
    main()
```



### 04093: å€’æ’ç´¢å¼•æŸ¥è¯¢

data structures, http://cs101.openjudge.cn/practice/04093/



è¾“å…¥ç»™å‡ºçš„æ˜¯å€’æ’ç´¢å¼•ã€‚

å¤„ç†æŸ¥è¯¢ï¼š

- å•è¯æŸ¥è¯¢ï¼šå¯¹äºå•ä¸ªè¯çš„æŸ¥è¯¢ï¼Œæœç´¢å¼•æ“ç›´æ¥è¿”å›è¯¥è¯çš„å€’æ’åˆ—è¡¨ã€‚
- å¤šè¯äº¤é›†æŸ¥è¯¢ï¼šå¯¹äºåŒ…å«å¤šä¸ªè¯çš„æŸ¥è¯¢ï¼Œæœç´¢å¼•æ“æ‰¾åˆ°æ¯ä¸ªè¯çš„å€’æ’åˆ—è¡¨ï¼Œç„¶åè®¡ç®—è¿™äº›åˆ—è¡¨çš„äº¤é›†ã€‚
  è¿™ä¸ªäº¤é›†ä»£è¡¨äº†æ‰€æœ‰æŸ¥è¯¢è¯éƒ½å‡ºç°çš„æ–‡æ¡£é›†åˆã€‚
- å¤æ‚é€»è¾‘å¤„ç†ï¼šå¯¹äºåŒ…å«é€»è¾‘è¿ç®—ï¼ˆAND, OR, NOTï¼‰çš„æŸ¥è¯¢ï¼Œæœç´¢å¼•æ“ä¼šç»“åˆä½¿ç”¨é›†åˆçš„
  äº¤é›†ï¼ˆANDï¼‰ã€å¹¶é›†ï¼ˆORï¼‰å’Œå·®é›†ï¼ˆNOTï¼‰æ“ä½œæ¥å¤„ç†æŸ¥è¯¢ã€‚ç‰¹åˆ«æ˜¯åœ¨å¤„ç† NOT é€»è¾‘æ—¶ï¼Œ
  å®ƒå¹¶ä¸æ˜¯å»æŸ¥æ‰¾é‚£äº›æœªå‡ºç°è¯çš„æ–‡æ¡£é›†åˆï¼Œè€Œæ˜¯ä»å·²ç»ç¡®å®šçš„ç»“æœé›†ä¸­æ’é™¤å«æœ‰è¿™ä¸ªè¯çš„æ–‡æ¡£ã€‚

```python
import sys


def main():
    data = sys.stdin.read().split()
    it = iter(data)

    # è¯»å…¥å€’æ’ç´¢å¼•çš„è¯æ•°
    N = int(next(it))
    inverted = []
    for _ in range(N):
        # æ¯ä¸ªè¯çš„å‡ºç°æ–‡æ¡£æ•°
        count = int(next(it))
        docs = set()
        for _ in range(count):
            docs.add(int(next(it)))
        inverted.append(docs)

    # è¯»å…¥æŸ¥è¯¢æ•°ç›®
    M = int(next(it))
    output_lines = []
    for _ in range(M):
        # æ¯ä¸ªæŸ¥è¯¢åŒ…å« N ä¸ªæ•°å­—
        query = [int(next(it)) for _ in range(N)]
        candidate = None
        # å¤„ç†å¿…é¡»å‡ºç°çš„è¯ï¼ˆå€¼ä¸º 1ï¼‰ï¼šå–äº¤é›†
        for j in range(N):
            if query[j] == 1:
                if candidate is None:
                    candidate = inverted[j].copy()  # é›†åˆåˆå§‹åŒ–
                else:
                    candidate &= inverted[j]
        # å¤„ç†å¿…é¡»ä¸å‡ºç°çš„è¯ï¼ˆå€¼ä¸º -1ï¼‰ï¼šä»å€™é€‰é›†åˆä¸­å‰”é™¤
        for j in range(N):
            if query[j] == -1:
                candidate -= inverted[j]
        # è¾“å‡ºç»“æœ
        if candidate:
            result_line = " ".join(map(str, sorted(candidate)))
            output_lines.append(result_line)
        else:
            output_lines.append("NOT FOUND")

    sys.stdout.write("\n".join(output_lines))


if __name__ == '__main__':
    main()
```



## 0.4 Heapå †

### 06648: Sequence

heap, merge http://cs101.openjudge.cn/practice/06648/



```python
import sys
import heapq

def merge(arr1, arr2, n):
    """
    å°†ä¸¤ä¸ªæœ‰åºæ•°ç»„ arr1 å’Œ arr2 åˆå¹¶ï¼Œæ±‚å‡ºæ‰€æœ‰ç»„åˆä¸­æœ€å°çš„ n ä¸ªå’Œ
    ä½¿ç”¨å †æ¥è¿›è¡Œåˆå¹¶æœç´¢
    """
    heap = []
    visited = set()
    # åˆå§‹å€™é€‰é¡¹ï¼š(arr1[0]+arr2[0], 0, 0)
    heapq.heappush(heap, (arr1[0] + arr2[0], 0, 0))
    visited.add((0, 0))
    result = []
    while len(result) < n:
        s, i, j = heapq.heappop(heap)
        result.append(s)
        # å¦‚æœ arr1 ä¸­çš„ä¸‹ä¸€ä¸ªæ•°å­˜åœ¨ï¼Œå°è¯•åŠ å…¥å€™é€‰é¡¹
        if i + 1 < n and (i + 1, j) not in visited:
            heapq.heappush(heap, (arr1[i + 1] + arr2[j], i + 1, j))
            visited.add((i + 1, j))
        # å¦‚æœ arr2 ä¸­çš„ä¸‹ä¸€ä¸ªæ•°å­˜åœ¨ï¼Œå°è¯•åŠ å…¥å€™é€‰é¡¹
        if j + 1 < n and (i, j + 1) not in visited:
            heapq.heappush(heap, (arr1[i] + arr2[j + 1], i, j + 1))
            visited.add((i, j + 1))
    return result

def main():
    input_data = sys.stdin.read().split()
    it = iter(input_data)
    T = int(next(it))
    results = []
    for _ in range(T):
        m = int(next(it))
        n = int(next(it))
        # è¯»å–ç¬¬ä¸€ä¸ªåºåˆ—ï¼Œå¹¶æ’åº
        current = sorted(int(next(it)) for _ in range(n))
        # ä¾æ¬¡ä¸åç»­çš„ m-1 ä¸ªåºåˆ—åˆå¹¶
        for _ in range(m - 1):
            seq = sorted(int(next(it)) for _ in range(n))
            current = merge(current, seq, n)
        results.append(" ".join(map(str, current)))
    sys.stdout.write("\n".join(results))

if __name__ == "__main__":
    main()
```



## Assign4-Q6.äº¤äº’å¯è§†åŒ–neural network

https://developers.google.com/machine-learning/crash-course/neural-networks/interactive-exercises

**Your task:** configure a neural network that can separate the orange dots from the blue dots in the diagram, achieving a loss of less than 0.2 on both the training and test data.

![image-20250311112914644](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250311112914644.png)





## 0.5 Backpropagationåå‘ä¼ æ’­

åå‘ä¼ æ’­ï¼ˆBack Propagationï¼ŒBPï¼‰ç®—æ³•æ˜¯ä¸€ç§é‡è¦çš„ç¥ç»ç½‘ç»œè®­ç»ƒç®—æ³•ï¼Œå®ƒçš„ä¸€äº›ç®—æ³•æ€æƒ³å¯ä»¥è¿½æº¯åˆ°20ä¸–çºª60å¹´ä»£çš„æ§åˆ¶ç†è®ºã€‚åå‘ä¼ æ’­ç®—æ³•å…¶å®å’Œå¤§éƒ¨åˆ†æœ‰ç›‘ç£å­¦ä¹ ç®—æ³•å¦‚çº¿æ€§å›å½’ã€é€»è¾‘å›å½’ç­‰æ±‚è§£æ€è·¯ç›¸ä¼¼ï¼Œéƒ½æ˜¯é€šè¿‡æ¢¯åº¦ä¸‹é™æ³•æ¥é€æ¸è°ƒèŠ‚å‚æ•°è¿›è€Œè®­ç»ƒæ¨¡å‹çš„ï¼Œå…¶åç§°ä¸­â€œåå‘â€çš„å«ä¹‰ä¸»è¦æ˜¯æŒ‡è¯¯å·®çš„åå‘ä¼ æ’­ã€‚

ä¼—å¤šæœºå™¨å­¦ä¹ ç®—æ³•åœ¨æ±‚è§£å‚æ•°è¿‡ç¨‹ä¸­éƒ½ä¼šä½¿ç”¨åˆ°æ¢¯åº¦ä¸‹é™æ³•ï¼Œç¥ç»ç½‘ç»œç®—æ³•ä¹Ÿä¸ä¾‹å¤–ã€‚<mark>ç¥ç»ç½‘ç»œä¸­ä¸»è¦ä½¿ç”¨æ¢¯åº¦ä¸‹é™æ³•æ¥è¿›è¡Œæƒé‡å’Œåç½®çš„å­¦ä¹ ä¸æ”¹è¿›ï¼Œä»è€Œä½¿ä»£ä»·å‡½æ•°å–å¾—æå°å€¼</mark>ã€‚ä½†éšç€å‚æ•°è§„æ¨¡è¶Šæ¥è¶Šå¤§ï¼Œæ¢¯åº¦çš„æ±‚è§£æœ¬èº«å°±æ˜¯ä¸€ä»¶è®©äººå¤´ç—›çš„äº‹æƒ…ã€‚å¦‚ä½•èƒ½å¤Ÿå¿«é€Ÿæ±‚è§£å‡º<mark>å¤æ‚å‡½æ•°çš„æ¢¯åº¦</mark>ï¼Œä»è€ŒåŠ å¿«æ¢¯åº¦ä¸‹é™è¿‡ç¨‹å‘¢ï¼Ÿè¿™å°±éœ€è¦ç”¨åˆ°åå‘ä¼ æ’­ç®—æ³•ã€‚

åå‘ä¼ æ’­ç®—æ³•å¯ä»¥çœ‹æˆæ¢¯åº¦ä¸‹é™æ³•åœ¨ç¥ç»ç½‘ç»œä¸­çš„å˜å½¢ç‰ˆæœ¬ï¼Œå®ƒçš„åŸç†ä¸»è¦æ˜¯åˆ©ç”¨<mark>é“¾å¼æ³•åˆ™</mark>é€šè¿‡é€’å½’çš„æ–¹å¼æ±‚è§£å¾®åˆ†ï¼Œä»è€Œç®€åŒ–å¯¹ç¥ç»ç½‘ç»œæ¢¯åº¦ä¸‹é™ä¼˜åŒ–å‚æ•°æ—¶çš„è®¡ç®—ã€‚åœ¨è¾“å…¥æ•°æ®å›ºå®šçš„æƒ…å†µä¸‹ï¼Œåå‘ä¼ æ’­ç®—æ³•åˆ©ç”¨ç¥ç»ç½‘ç»œçš„è¾“å‡ºæ•æ„Ÿåº¦æ¥å¿«é€Ÿè®¡ç®—ç¥ç»ç½‘ç»œä¸­çš„å„ç§è¶…å‚æ•°ï¼Œä»è€Œå¤§å¤§å‡å°‘è®­ç»ƒæ‰€éœ€æ—¶é—´ã€‚

åå‘ä¼ æ’­ç®—æ³•æ˜¯ç¥ç»ç½‘ç»œç®—æ³•çš„æ ¸å¿ƒæ‰€åœ¨ã€‚<mark>åå‘ä¼ æ’­ç®—æ³•çš„æ ¸å¿ƒç†å¿µå°±æ˜¯æŠŠä¸‹ä¸€å±‚ç¥ç»å…ƒå¯¹äºä¸Šä¸€å±‚ç¥ç»å…ƒçš„æ‰€æœ‰æœŸå¾…æ±‡æ€»ï¼Œä»è€ŒæŒ‡å¯¼ä¸Šä¸€å±‚ç¥ç»å…ƒæ”¹å˜</mark>ã€‚
å‡è®¾ç¥ç»ç½‘ç»œè¿˜æ²¡æœ‰è¢«è®­ç»ƒå¥½ï¼Œè¿™ä¸ªæ—¶å€™è¾“å‡ºå±‚ç¥ç»å…ƒçš„æ¿€æ´»å€¼çœ‹èµ·æ¥æ¯”è¾ƒéšæœºï¼Œä¸æˆ‘ä»¬æœŸæœ›çš„æ­£ç¡®ç»“æœç›¸å·®è¾ƒå¤§ã€‚æˆ‘ä»¬å½“ç„¶å¸Œæœ›å¯¹æ­¤åšå‡ºæ”¹å˜ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸èƒ½ç›´æ¥æ”¹å˜ç¥ç»å…ƒçš„æ¿€æ´»å€¼ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ”¹å˜çš„åªæ˜¯æƒé‡å’Œåç½®ï¼Œ

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250318105058016.png" alt="image-20250318105058016" style="zoom: 50%;" />



**Backpropagation in Neural Network**

https://www.geeksforgeeks.org/backpropagation-in-neural-network/

Last Updated : 07 Mar, 2025



**ç¤ºä¾‹ï¼šå¯¹äºXORé—®é¢˜ï¼ˆè¾“å…¥ä¸º[0,0], [0,1], [1,0], [1,1]ï¼‰ï¼ŒæœŸæœ›è¾“å‡ºä¸º[0,1,1,0]**

æ‰‹åŠ¨å®ç°åå‘ä¼ æ’­ï¼Œæ²¡æœ‰ä½¿ç”¨æ·±åº¦å­¦ä¹ æ¡†æ¶ï¼Œè¿™æœ‰åŠ©äºç†è§£åº•å±‚åŸç†

ä»£ç `xor_bp_neural_net_manual.py`

```python
import numpy as np


class NeuralNetwork:
    def __init__(self, input_size, hidden_size, output_size):
        self.input_size = input_size  # è¾“å…¥ç‰¹å¾ç»´åº¦
        self.hidden_size = hidden_size  # éšè—å±‚ç¥ç»å…ƒæ•°é‡
        self.output_size = output_size  # è¾“å‡ºå±‚ç¥ç»å…ƒæ•°é‡

        # è¾“å…¥å±‚åˆ°éšè—å±‚çš„æƒé‡ï¼Œå½¢çŠ¶ä¸º (è¾“å…¥ç»´åº¦, éšè—å±‚ç»´åº¦)
        self.weights_input_hidden = np.random.randn(self.input_size, self.hidden_size)
        # éšè—å±‚åˆ°è¾“å‡ºå±‚çš„æƒé‡ï¼Œå½¢çŠ¶ä¸º (éšè—å±‚ç»´åº¦, è¾“å‡ºå±‚ç»´åº¦)
        self.weights_hidden_output = np.random.randn(self.hidden_size, self.output_size)

        # éšè—å±‚çš„åç½®ï¼Œå½¢çŠ¶ä¸º (1, éšè—å±‚ç»´åº¦)
        self.bias_hidden = np.zeros((1, self.hidden_size))
        # è¾“å‡ºå±‚çš„åç½®ï¼Œå½¢çŠ¶ä¸º (1, è¾“å‡ºå±‚ç»´åº¦)
        self.bias_output = np.zeros((1, self.output_size))

    def sigmoid(self, x):  # æ¿€æ´»å‡½æ•°ï¼Œå°†è¾“å…¥å‹ç¼©åˆ°(0,1)åŒºé—´
        return 1 / (1 + np.exp(-x))

    def sigmoid_derivative(self, x):
        return x * (1 - x)  # Sigmoidçš„å¯¼æ•°ï¼Œç”¨äºåå‘ä¼ æ’­ä¸­çš„æ¢¯åº¦è®¡ç®—

    def feedforward(self, X):
        # éšè—å±‚è®¡ç®—
        self.hidden_activation = np.dot(X, self.weights_input_hidden) + self.bias_hidden  # çº¿æ€§å˜æ¢
        self.hidden_output = self.sigmoid(self.hidden_activation)  # æ¿€æ´»å‡½æ•°

        # è¾“å‡ºå±‚è®¡ç®—
        self.output_activation = np.dot(self.hidden_output, self.weights_hidden_output) + self.bias_output
        self.predicted_output = self.sigmoid(self.output_activation)

        return self.predicted_output

    def backward(self, X, y, learning_rate):
        # è®¡ç®—è¾“å‡ºå±‚è¯¯å·®å’Œæ¢¯åº¦
        output_error = y - self.predicted_output  # è¯¯å·® = çœŸå®å€¼ - é¢„æµ‹å€¼
        output_delta = output_error * self.sigmoid_derivative(self.predicted_output)  # æ¢¯åº¦ = è¯¯å·® Ã— å¯¼æ•°

        # è®¡ç®—éšè—å±‚è¯¯å·®å’Œæ¢¯åº¦
        hidden_error = np.dot(output_delta, self.weights_hidden_output.T)  # è¯¯å·®ä¼ é€’åˆ°éšè—å±‚
        hidden_delta = hidden_error * self.sigmoid_derivative(self.hidden_output)  # æ¢¯åº¦ = è¯¯å·® Ã— å¯¼æ•°

        # æ›´æ–°æƒé‡å’Œåç½®ï¼ˆæ¢¯åº¦ä¸‹é™ï¼‰
        self.weights_hidden_output += np.dot(self.hidden_output.T, output_delta) * learning_rate  # è¾“å‡ºå±‚æƒé‡æ›´æ–°
        self.bias_output += np.sum(output_delta, axis=0, keepdims=True) * learning_rate  # è¾“å‡ºå±‚åç½®æ›´æ–°
        self.weights_input_hidden += np.dot(X.T, hidden_delta) * learning_rate  # éšè—å±‚æƒé‡æ›´æ–°

        # axis=0ï¼šæ²¿åˆ—æ±‚å’Œï¼Œèšåˆæ‰€æœ‰æ ·æœ¬çš„æ¢¯åº¦
        # keepdims=Trueï¼šä¿æŒåŸçŸ©é˜µçš„è¡Œæ•°ç»´åº¦ï¼Œç¡®ä¿åç½®æ›´æ–°çš„å½¢çŠ¶å…¼å®¹æ€§
        self.bias_hidden += np.sum(hidden_delta, axis=0, keepdims=True) * learning_rate  # éšè—å±‚åç½®æ›´æ–°

    def train(self, X, y, epochs, learning_rate):
        for epoch in range(epochs):
            output = self.feedforward(X)  # å‰å‘ä¼ æ’­
            self.backward(X, y, learning_rate)  # åå‘ä¼ æ’­ä¸å‚æ•°æ›´æ–°
            if epoch % 4000 == 0:
                loss = np.mean(np.square(y - output))  # è®¡ç®—å‡æ–¹è¯¯å·®
                print(f"Epoch {epoch}, Loss:{loss}")


X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
y = np.array([[0], [1], [1], [0]])

# è¾“å…¥ç»´åº¦ 2ï¼ˆäºŒç»´äºŒè¿›åˆ¶ç‰¹å¾ï¼‰ï¼Œéšè—å±‚4ä¸ªç¥ç»å…ƒï¼Œè¾“å‡ºå±‚1ä¸ªç¥ç»å…ƒï¼ˆäºŒåˆ†ç±»é—®é¢˜ï¼‰
nn = NeuralNetwork(input_size=2, hidden_size=4, output_size=1)
# è®­ç»ƒæ€»è½®æ¬¡, å­¦ä¹ ç‡
nn.train(X, y, epochs=10000, learning_rate=0.1)

output = nn.feedforward(X)
print("Predictions after training:")
print(output)
"""
Epoch 0, Loss:0.2653166263520884
Epoch 4000, Loss:0.007000926683956338
Epoch 8000, Loss:0.001973630232951721
Predictions after training:
[[0.03613239]
 [0.96431351]
 [0.96058291]
 [0.03919372]]
"""

```



![image-20250318103310678](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250318103310678.png)





# Continuing with the content 

from 03/04/2025, 03/11/2025...



# 2 æ—¶é—´å¤æ‚åº¦ Big-O

ä½¿ç”¨æ•°æ®ç»“æ„ä¸ç®—æ³•ï¼ˆDSAï¼‰çš„ä¸»è¦ç›®çš„æ˜¯ä¸ºäº†æœ‰æ•ˆåœ°å’Œé«˜æ•ˆåœ°è§£å†³é—®é¢˜ã€‚ä½ å¦‚ä½•å†³å®šè‡ªå·±ç¼–å†™çš„ç¨‹åºæ˜¯å¦é«˜æ•ˆå‘¢ï¼Ÿè¿™é€šè¿‡å¤æ‚åº¦æ¥è¡¡é‡ã€‚å¤æ‚åº¦åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼š

1. æ—¶é—´å¤æ‚åº¦ï¼šæ—¶é—´å¤æ‚åº¦ç”¨äºè¡¡é‡æ‰§è¡Œä»£ç æ‰€éœ€çš„æ—¶é—´ã€‚
2. ç©ºé—´å¤æ‚åº¦ï¼šç©ºé—´å¤æ‚åº¦æŒ‡çš„æ˜¯æˆåŠŸæ‰§è¡Œä»£ç åŠŸèƒ½æ‰€éœ€çš„å­˜å‚¨ç©ºé—´é‡ã€‚ åœ¨æ•°æ®ç»“æ„ä¸ç®—æ³•ä¸­ï¼Œä¼šç»å¸¸é‡åˆ°**è¾…åŠ©ç©ºé—´**è¿™ä¸ªæœ¯è¯­ï¼Œå®ƒæŒ‡çš„æ˜¯ç¨‹åºä¸­é™¤äº†è¾“å…¥æ•°æ®ç»“æ„å¤–ä½¿ç”¨çš„é¢å¤–ç©ºé—´ã€‚

> LC234.å›æ–‡é“¾è¡¨ã€‚**è¿›é˜¶ï¼š**èƒ½å¦ç”¨ `O(n)` æ—¶é—´å¤æ‚åº¦å’Œ `O(1)` ç©ºé—´å¤æ‚åº¦è§£å†³æ­¤é¢˜ï¼Ÿ



> Here comes one of the interesting and important topics. The primary motive to use DSA is to solve a problem effectively and efficiently. How can you decide if a program written by you is efficient or not? This is measured by complexities. Complexity is of two types:
>
> 1. Time Complexity: Time complexity is used to measure the amount of time required to execute the code.
> 2. Space Complexity: Space complexity means the amount of space required to execute successfully the functionalities of the code. 
>    You will also come across the term **Auxiliary Space** very commonly in DSA, which refers to the extra space used in the program other than the input data structure.

ä¸Šè¿°ä¸¤ç§å¤æ‚åº¦éƒ½æ˜¯ç›¸å¯¹äºè¾“å…¥å‚æ•°æ¥è¡¡é‡çš„ã€‚ä½†è¿™é‡Œå‡ºç°äº†ä¸€ä¸ªé—®é¢˜ã€‚æ‰§è¡Œä¸€æ®µä»£ç æ‰€éœ€çš„æ—¶é—´å–å†³äºå¤šä¸ªå› ç´ ï¼Œä¾‹å¦‚ï¼š

- ç¨‹åºä¸­æ‰§è¡Œçš„æ“ä½œæ•°é‡ï¼Œè®¾å¤‡çš„é€Ÿåº¦ï¼Œä»¥åŠå¦‚æœæ˜¯åœ¨åœ¨çº¿å¹³å°ä¸Šæ‰§è¡Œçš„è¯ï¼Œæ•°æ®ä¼ è¾“çš„é€Ÿåº¦ã€‚

é‚£ä¹ˆå¦‚ä½•ç¡®å®šå“ªä¸€ä¸ªæ›´é«˜æ•ˆå‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨æ¸è¿‘ç¬¦å·ã€‚<mark>æ¸è¿‘ç¬¦å·</mark>æ˜¯ä¸€ç§æ•°å­¦å·¥å…·ï¼Œå®ƒæ ¹æ®è¾“å…¥å¤§å°è®¡ç®—æ‰€éœ€æ—¶é—´ï¼Œå¹¶ä¸éœ€è¦å®é™…æ‰§è¡Œä»£ç ã€‚

> Both of the above complexities are measured with respect to the input parameters. But here arises a problem. The time required for executing a code depends on several factors, such as: 
>
> - The number of operations performed in the program, 
> - The speed of the device, and also 
> - The speed of data transfer if being executed on an online platform. 
>
> So how can we determine which one is efficient? The answer is the use of asymptotic notation. **Asymptotic notation** is a mathematical tool that calculates the required time in terms of input size and does not require the execution of the code. 

å®ƒå¿½ç•¥äº†ä¾èµ–äºç³»ç»Ÿçš„å¸¸æ•°ï¼Œå¹¶ä¸”åªä¸æ•´ä¸ªç¨‹åºä¸­æ‰§è¡Œçš„æ¨¡å—åŒ–æ“ä½œçš„æ•°é‡æœ‰å…³ã€‚ä»¥ä¸‹ä¸‰ç§æ¸è¿‘ç¬¦å·æœ€å¸¸ç”¨ä»¥è¡¨ç¤ºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼š

- **å¤§Oç¬¦å· (ÎŸ)** â€“ <mark>å¤§Oç¬¦å·ç‰¹åˆ«æè¿°äº†æœ€åæƒ…å†µä¸‹çš„æƒ…å½¢</mark>ã€‚$\Theta$è®°å·æ¸è¿›åœ°ç»™å‡ºç®—æ³•çš„å¹³å‡å¤æ‚åº¦ï¼Œå³ä¸€ä¸ªå‡½æ•°çš„ä¸Šç•Œå’Œä¸‹ç•Œã€‚å½“åªæœ‰ä¸€ä¸ªæ¸è¿›ä¸Šç•Œæ—¶ï¼Œå³å½“nè¶³å¤Ÿå¤§æ—¶ï¼Œä½¿ç”¨ $O$ è®°å·ã€‚
- **æ¬§ç±³ä¼½ç¬¦å· (Î©)** â€“ æ¬§ç±³ä¼½(Î©)ç¬¦å·ç‰¹åˆ«æè¿°äº†æœ€å¥½æƒ…å†µä¸‹çš„æƒ…å½¢ã€‚
- **è¥¿å¡”ç¬¦å· ($\Theta$)** â€“ è¿™ä¸ªç¬¦å·ä»£è¡¨äº†ç®—æ³•çš„å¹³å‡å¤æ‚åº¦ã€‚

> It neglects the system-dependent constants and is related to only the number of modular operations being performed in the whole program. The following 3 asymptotic notations are mostly used to represent the time complexity of algorithms:
>
> - **Big-O Notation (ÎŸ)** â€“ Big-O notation specifically describes the worst-case scenario.
> - **Omega Notation (Î©)** â€“ Omega(Î©) notation specifically describes the best-case scenario.
> - **Theta Notation (Î¸)** â€“ This notation represents the average complexity of an algorithm.

![Rate of Growth of Algorithms](https://raw.githubusercontent.com/GMyhf/img/main/img/202402232027181.png)



ç®—æ³•çš„å¢é•¿ç‡

<mark>åœ¨ä»£ç åˆ†æä¸­æœ€å¸¸ç”¨çš„ç¬¦å·æ˜¯**å¤§Oç¬¦å·**ï¼Œå®ƒç»™å‡ºäº†ä»£ç è¿è¡Œæ—¶é—´çš„ä¸Šç•Œ</mark>ï¼ˆæˆ–è€…è¯´æ˜¯è¾“å…¥è§„æ¨¡å¤§å°å¯¹åº”çš„å†…å­˜ä½¿ç”¨é‡ï¼‰ã€‚å¤§Oç¬¦å·å¸®åŠ©æˆ‘ä»¬ç†è§£å½“è¾“å…¥æ•°æ®é‡å¢åŠ æ—¶ï¼Œç®—æ³•çš„æ‰§è¡Œæ—¶é—´æˆ–ç©ºé—´éœ€æ±‚å°†ä»¥æ€æ ·çš„é€Ÿåº¦å¢é•¿ã€‚

> Rate of Growth of Algorithms
>
> The most used notation in the analysis of a code is the **Big O Notation** which gives an upper bound of the running time of the code (or the amount of memory used in terms of input size).



## 2.1 Analyzing algorithms

åˆ†æç®—æ³•æ„å‘³ç€é¢„æµ‹è¯¥ç®—æ³•æ‰€éœ€çš„èµ„æºã€‚è™½ç„¶æœ‰æ—¶æˆ‘ä»¬ä¸»è¦å…³å¿ƒåƒå†…å­˜ã€é€šä¿¡å¸¦å®½æˆ–è®¡ç®—æœºç¡¬ä»¶è¿™ç±»èµ„æºï¼Œä½†æ˜¯é€šå¸¸æƒ³è¦åº¦é‡çš„æ˜¯è®¡ç®—æ—¶é—´ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œé€šè¿‡åˆ†ææŸä¸ªé—®é¢˜çš„å‡ ç§å€™é€‰ç®—æ³•ï¼Œå¯ä»¥è¯†åˆ«å‡ºæœ€é«˜æ•ˆçš„é‚£ä¸€ä¸ªã€‚è¿™æ ·çš„åˆ†æå¯èƒ½ä¼šæŒ‡å‡ºä¸æ­¢ä¸€ä¸ªå¯è¡Œçš„å€™é€‰ç®—æ³•ï¼Œä½†åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­ï¼Œé€šå¸¸å¯ä»¥æ·˜æ±°å‡ ä¸ªè¾ƒå·®çš„ç®—æ³•ã€‚

> **Analyzing** an algorithm has come to mean predicting the resources that the algorithm requires. Occasionally, resources such as memory, communication bandwidth, or computer hardware are of primary concern, but most often it is computational time that we want to measure. Generally, by analyzing several candidate algorithms for a problem, we can identify a most efficient one. Such analysis may indicate more than one viable candidate, but we can often discard several inferior algorithms in the process.

åœ¨åˆ†æä¸€ä¸ªç®—æ³•ä¹‹å‰ï¼Œå¿…é¡»æœ‰ä¸€ä¸ªè¦ä½¿ç”¨çš„å®ç°æŠ€æœ¯çš„æ¨¡å‹ï¼ŒåŒ…æ‹¬è¯¥æŠ€æœ¯çš„èµ„æºæ¨¡å‹åŠå…¶æˆæœ¬ã€‚æˆ‘ä»¬å°†å‡è®¾ä¸€ç§é€šç”¨çš„<mark>å•å¤„ç†å™¨è®¡ç®—æ¨¡å‹â€”â€”éšæœºå­˜å–æœºï¼ˆrandom-access machine, RAMï¼‰</mark>æ¥ä½œä¸ºå®ç°æŠ€æœ¯ï¼Œç®—æ³•å¯ä»¥ç”¨è®¡ç®—æœºç¨‹åºæ¥å®ç°ã€‚åœ¨RAMæ¨¡å‹ä¸­ï¼ŒæŒ‡ä»¤æ˜¯é¡ºåºæ‰§è¡Œçš„ï¼Œæ²¡æœ‰å¹¶å‘æ“ä½œã€‚

> Before we can analyze an algorithm, we must have a model of the implementation technology that we will use, including a model for the resources of that technology and their costs. For most of this book, we shall assume a generic oneprocessor, **random-access machine (RAM)** model of computation as our implementation technology and understand that our algorithms will be implemented as computer programs. In the RAM model, instructions are executed one after another, with no concurrent operations.

ä¸¥æ ¼æ¥è¯´ï¼Œåº”è¯¥ç²¾ç¡®åœ°å®šä¹‰RAMæ¨¡å‹çš„æŒ‡ä»¤åŠå…¶æˆæœ¬ã€‚ç„¶è€Œè¿™æ ·åšä¼šå¾ˆç¹çï¼Œå¹¶ä¸”ä¸ä¼šå¯¹ç®—æ³•è®¾è®¡å’Œåˆ†ææä¾›å¤ªå¤šçš„æ´å¯ŸåŠ›ã€‚ä½†å¿…é¡»å°å¿ƒä¸è¦æ»¥ç”¨RAMæ¨¡å‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœRAMæœ‰ä¸€ä¸ªæ’åºæŒ‡ä»¤ï¼Œé‚£ä¹ˆå°±å¯ä»¥åªç”¨ä¸€æ¡æŒ‡ä»¤å®Œæˆæ’åºã€‚è¿™æ ·çš„RAMå°†æ˜¯ä¸ç°å®çš„ï¼Œå› ä¸ºå®é™…çš„è®¡ç®—æœºæ²¡æœ‰è¿™æ ·çš„æŒ‡ä»¤ã€‚å› æ­¤ï¼Œ**æŒ‡å¯¼åŸåˆ™æ˜¯å®é™…è®¡ç®—æœºçš„è®¾è®¡æ–¹å¼**ã€‚<mark>RAMæ¨¡å‹åŒ…å«äº†åœ¨å®é™…è®¡ç®—æœºä¸­å¸¸è§çš„æŒ‡ä»¤ï¼šç®—æœ¯è¿ç®—ï¼ˆå¦‚åŠ æ³•ã€å‡æ³•ã€ä¹˜æ³•ã€é™¤æ³•ã€æ±‚ä½™æ•°ã€å–åº•ã€å–é¡¶ï¼‰ï¼Œæ•°æ®ç§»åŠ¨ï¼ˆåŠ è½½ã€å­˜å‚¨ã€å¤åˆ¶ï¼‰ï¼Œä»¥åŠæ§åˆ¶ï¼ˆæ¡ä»¶åˆ†æ”¯å’Œæ— æ¡ä»¶åˆ†æ”¯ã€å­ç¨‹åºè°ƒç”¨å’Œè¿”å›ï¼‰ã€‚æ¯æ¡è¿™æ ·çš„æŒ‡ä»¤éƒ½éœ€è¦å›ºå®šçš„æ—¶é—´é‡ã€‚</mark>

> Strictly speaking, we should precisely define the instructions of the RAM model and their costs. To do so, however, would be tedious and would yield little insight into algorithm design and analysis. Yet we must be careful not to abuse the RAM model. For example, what if a RAM had an instruction that sorts? Then we couldsort in just one instruction. Such a RAM would be unrealistic, since real computers do not have such instructions. Our guide, therefore, is how real computers are designed. The RAM model contains instructions commonly found in real computers: arithmetic (such as add, subtract, multiply, divide, remainder, floor, ceiling), data movement (load, store, copy), and control (conditional and unconditional branch, subroutine call and return). Each such instruction takes a constant amount of time.

<mark>RAMæ¨¡å‹ä¸­çš„æ•°æ®ç±»å‹æœ‰æ•´å‹å’Œæµ®ç‚¹å®æ•°å‹</mark>ã€‚è™½ç„¶åœ¨æ­¤å¤„é€šå¸¸ä¸å…³å¿ƒç²¾åº¦é—®é¢˜ï¼Œä½†åœ¨æŸäº›åº”ç”¨ä¸­ç²¾åº¦æ˜¯è‡³å…³é‡è¦çš„ã€‚ä¹Ÿå‡è®¾æ¯ä¸ªæ•°æ®å­—çš„å¤§å°æœ‰é™åˆ¶ã€‚ä¾‹å¦‚ï¼Œåœ¨å¤„ç†å¤§å°ä¸ºnçš„è¾“å…¥æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸å‡è®¾å¯¹æŸä¸ªå¸¸æ•°câ‰¥1ï¼Œ æ•´æ•°ç”±`c lgn`ä½è¡¨ç¤ºã€‚æˆ‘ä»¬è¦æ±‚câ‰¥1æ˜¯ä¸ºäº†ç¡®ä¿æ¯ä¸ªå­—èƒ½å¤Ÿå®¹çº³nçš„å€¼ï¼Œä»è€Œä½¿æˆ‘ä»¬èƒ½å¤Ÿç´¢å¼•å„ä¸ªè¾“å…¥å…ƒç´ ï¼Œå¹¶ä¸”æˆ‘ä»¬å°†cé™åˆ¶ä¸ºå¸¸æ•°ä»¥é˜²æ­¢å­—é•¿æ— é™å¢é•¿ã€‚ï¼ˆå¦‚æœå­—é•¿å¯ä»¥æ— é™å¢é•¿ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ä¸€ä¸ªå­—ä¸­å­˜å‚¨å¤§é‡æ•°æ®å¹¶åœ¨æ’å®šæ—¶é—´å†…å¯¹å…¶è¿›è¡Œæ“ä½œâ€”â€”è¿™æ˜¾ç„¶æ˜¯ä¸€ç§ä¸åˆ‡å®é™…çš„æƒ…å†µã€‚ï¼‰

> The data types in the RAM model are integer and floating point (for storing real numbers). Although we typically do not concern ourselves with precision in this book, in some applications precision is crucial. We also assume a limit on the size of each word of data. For example, when working with inputs of size n, we typically assume that integers are represented by c lg n bits for some constant $c \ge 1$. We require $c \ge 1$â€‹ so that each word can hold the value of n, enabling us to index the individual input elements, and we restrict c to be a constant so that the word size does not grow arbitrarily. (If the word size could grow arbitrarily, we could store huge amounts of data in one word and operate on it all in constant timeâ€”clearly an unrealistic scenario.)

> è®¡ç®—æœºå­—é•¿ï¼ˆComputer Word Lengthï¼‰æ˜¯æŒ‡è®¡ç®—æœºä¸­ç”¨äºå­˜å‚¨å’Œå¤„ç†æ•°æ®çš„åŸºæœ¬å•ä½çš„ä½æ•°ã€‚å®ƒè¡¨ç¤ºè®¡ç®—æœºèƒ½å¤Ÿä¸€æ¬¡æ€§å¤„ç†çš„äºŒè¿›åˆ¶æ•°æ®çš„ä½æ•°ã€‚
>
> å­—é•¿çš„å¤§å°å¯¹è®¡ç®—æœºçš„æ€§èƒ½å’Œæ•°æ®å¤„ç†èƒ½åŠ›æœ‰é‡è¦å½±å“ã€‚è¾ƒå¤§çš„å­—é•¿é€šå¸¸æ„å‘³ç€è®¡ç®—æœºèƒ½å¤Ÿå¤„ç†æ›´å¤§èŒƒå›´çš„æ•°æ®æˆ–æ‰§è¡Œæ›´å¤æ‚çš„æ“ä½œã€‚å¸¸è§çš„å­—é•¿åŒ…æ‹¬ 8 ä½ã€16 ä½ã€32 ä½å’Œ 64 ä½ã€‚
>
> è¾ƒå°çš„å­—é•¿å¯ä»¥èŠ‚çœå­˜å‚¨ç©ºé—´å’Œèµ„æºï¼Œé€‚ç”¨äºç®€å•çš„è®¡ç®—ä»»åŠ¡å’Œèµ„æºæœ‰é™çš„è®¾å¤‡ã€‚è¾ƒå¤§çš„å­—é•¿é€šå¸¸ç”¨äºå¤„ç†æ›´å¤§é‡çº§çš„æ•°æ®ã€è¿›è¡Œå¤æ‚çš„è®¡ç®—å’Œæ”¯æŒé«˜æ€§èƒ½è®¡ç®—éœ€æ±‚ã€‚
>
> éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå­—é•¿å¹¶ä¸æ˜¯å”¯ä¸€è¡¡é‡è®¡ç®—æœºæ€§èƒ½çš„æŒ‡æ ‡ï¼Œè¿˜æœ‰å…¶ä»–å› ç´ å¦‚å¤„ç†å™¨é€Ÿåº¦ã€ç¼“å­˜å¤§å°ã€æ“ä½œç³»ç»Ÿç­‰ä¹Ÿä¼šå½±å“è®¡ç®—æœºçš„æ•´ä½“æ€§èƒ½ã€‚



#### **Q. Distill,32B,<mark>Q4</mark>è¿™äº›å‚æ•°æ˜¯ä»€ä¹ˆæ„æ€?**

DeepSeek-R1-Distill-Qwen-32B-GGUF/DeepSeek-R1-Distill-Qwen-32B-Q4_K_M.gguf 

> A: é—®é¢˜æ¶‰åŠ **GGUF æ ¼å¼çš„é‡åŒ–æ¨¡å‹æ–‡ä»¶**ï¼Œç‰¹åˆ«æ˜¯ `DeepSeek-R1-Distill-Qwen-32B-GGUF/DeepSeek-R1-Distill-Qwen-32B-Q4_K_M.gguf` è¿™ç±»æ–‡ä»¶åçš„å‚æ•°å«ä¹‰ã€‚ä»¥ä¸‹æ˜¯è¯¦ç»†è§£æï¼š
>
> 
>
> **æ–‡ä»¶åç»“æ„è§£æ**
>
> `DeepSeek-R1-Distill-Qwen-32B-Q4_K_M.gguf`
>
> **1. `DeepSeek-R1-Distill`**
>
>    - **DeepSeek-R1-Distill**ï¼šæŒ‡çš„æ˜¯ DeepSeek å®éªŒå®¤è®­ç»ƒçš„ç¬¬ä¸€ä»£ï¼ˆR1ï¼‰è’¸é¦ç‰ˆï¼ˆDistillï¼‰æ¨¡å‹ã€‚  
>    - **è’¸é¦ï¼ˆDistillï¼‰** é€šå¸¸æ„å‘³ç€è¿™ä¸ªæ¨¡å‹æ˜¯ä»ä¸€ä¸ªæ›´å¤§çš„æ¨¡å‹ï¼ˆå¦‚ DeepSeek åŸå§‹æ¨¡å‹ï¼‰å‹ç¼©æˆ–ä¼˜åŒ–è€Œæ¥çš„ï¼Œä»¥æé«˜æ¨ç†é€Ÿåº¦å¹¶å‡å°‘è®¡ç®—éœ€æ±‚ã€‚
>
> **2. `Qwen-32B`**
>
>    - **Qwen**ï¼šè¡¨ç¤ºè¿™ä¸ªæ¨¡å‹åŸºäº Qwenï¼ˆé€šä¹‰åƒé—®ï¼‰æ¶æ„ï¼Œç”±é˜¿é‡Œå·´å·´ DAMO ç ”å‘ã€‚
>    - **32B**ï¼šè¡¨ç¤ºè¯¥æ¨¡å‹æœ‰ **320 äº¿ï¼ˆ32 Billionï¼‰å‚æ•°**ï¼Œæ˜¯ä¸€ä¸ªè¾ƒå¤§çš„æ¨¡å‹ã€‚
>
> **3. `GGUF`**
>
>    - **GGUFï¼ˆGPT-Generated Unified Formatï¼‰** æ˜¯ä¸€ç§ **é«˜æ•ˆçš„ LLM é‡åŒ–æ ¼å¼**ï¼Œä¸“ä¸º GGML/GGUF å…¼å®¹çš„æ¨ç†å¼•æ“ï¼ˆå¦‚ llama.cppï¼‰è®¾è®¡ã€‚
>    - è¿™ç§æ ¼å¼å¯ä»¥ä¼˜åŒ–å¤§è¯­è¨€æ¨¡å‹åœ¨ CPU å’Œ GPU ä¸Šçš„æ¨ç†é€Ÿåº¦ã€‚
>
> **4. `Q4_K_M`**
>
>    - **Q4**ï¼šæŒ‡çš„æ˜¯ **é‡åŒ–ç²¾åº¦ä¸º 4-bit**ï¼ˆè¡¨ç¤ºæ¯ä¸ªæƒé‡åªå  4 æ¯”ç‰¹ï¼‰ã€‚
>    - **K**ï¼šä»£è¡¨ **K-quants é‡åŒ–æ–¹æ¡ˆ**ï¼Œç”¨äºæ›´å¥½çš„æ¨ç†ç²¾åº¦å’Œå¹³è¡¡è®¡ç®—æ•ˆç‡ã€‚
>    - **M**ï¼šé€šå¸¸è¡¨ç¤º **Mixed**ï¼ˆæ··åˆé‡åŒ–ï¼‰ï¼Œæ„å‘³ç€æ¨¡å‹å¯èƒ½ä½¿ç”¨äº†æ··åˆç²¾åº¦é‡åŒ–ï¼ˆä¾‹å¦‚éƒ¨åˆ†æƒé‡ 4-bitï¼Œéƒ¨åˆ† 8-bitï¼‰ã€‚
>
> ---
>
> **Q4_K_M ä»£è¡¨çš„é‡åŒ–æ–¹æ¡ˆ**
>
> - `Q4` æŒ‡ 4-bit é‡åŒ–ï¼Œæ„å‘³ç€æ¨¡å‹çš„å‚æ•°è¢«å‹ç¼©ä¸º 4-bitï¼Œè€Œä¸æ˜¯åŸå§‹çš„ 16-bit æˆ– 32-bit æµ®ç‚¹æ•°ã€‚
>
>   > åœ¨æ¨¡å‹å‹ç¼©ä¸­ï¼Œé‡åŒ–é€šå¸¸æ˜¯æŒ‡ä»æµ®ç‚¹æ•°åˆ°æ•´æ•°çš„æ˜ å°„è¿‡ç¨‹ï¼Œç›®å‰æ¯”è¾ƒå¸¸ç”¨çš„æ˜¯8æ¯”ç‰¹æ•´æ•°é‡åŒ–ï¼Œå³INT8é‡åŒ–ã€‚é’ˆå¯¹ç¥ç»ç½‘ç»œæ¨¡å‹ï¼Œé€šå¸¸æœ‰ä¸¤ç§ç±»å‹çš„æ•°æ®éœ€è¦è¿›è¡Œé‡åŒ–ï¼Œåˆ†åˆ«æ˜¯æƒé‡ï¼ˆä¹Ÿç§°ä¸ºæ¨¡å‹å‚æ•°ï¼‰å’Œæ¿€æ´»ï¼Œå®ƒä»¬éƒ½ä»¥æµ®ç‚¹æ•°å½¢å¼è¿›è¡Œè¡¨ç¤ºå’Œå­˜å‚¨ã€‚é‡åŒ–è¿‡ç¨‹å¯ä»¥çœ‹ä½œä¸€ä¸ªå‡½æ•°å˜æ¢ï¼Œç›®æ ‡æ˜¯å°†è¿ç»­çš„è¾“å…¥æ•°å€¼æ˜ å°„ä¸ºç¦»æ•£çš„è¾“å‡ºé›†åˆã€‚
>
> - `K`ï¼ˆK-quantï¼‰æ˜¯ä¸€ç§å¢å¼ºçš„é‡åŒ–æŠ€æœ¯ï¼Œå¯ä»¥æé«˜é‡åŒ–æ¨¡å‹çš„ç²¾åº¦ï¼Œå‡å°‘æ¨ç†è¯¯å·®ã€‚
>
> - `M`ï¼ˆMixedï¼‰è¡¨ç¤º **æ··åˆé‡åŒ–**ï¼Œé€šå¸¸æ„å‘³ç€ï¼š
>
>   - å¯èƒ½å¯¹ä¸åŒå±‚ä½¿ç”¨ä¸åŒçš„é‡åŒ–ç²¾åº¦ã€‚
>   - å¯èƒ½æ··åˆä¸åŒçš„å—ï¼ˆblockwise quantizationï¼‰ã€‚
>
> ---
>
> **GGUF é‡åŒ–æ ¼å¼çš„é€‰æ‹©**
>
> ä½ å¯èƒ½ä¼šçœ‹åˆ°ç±»ä¼¼çš„ GGUF æ–‡ä»¶ï¼Œä¾‹å¦‚ï¼š
>
> - `Q4_K_S`ï¼ˆ4-bit K-quants, Smallï¼‰
> - `Q5_K_M`ï¼ˆ5-bit K-quants, Mixedï¼‰
> - `Q8_K`ï¼ˆ8-bit K-quantsï¼‰
>
> é€šå¸¸ï¼š
>
> - **Q4_K_M**ï¼šå¹³è¡¡æ€§èƒ½å’Œé€Ÿåº¦ï¼Œé€‚åˆä¸­ç­‰è®¡ç®—èµ„æºï¼ˆå¦‚ CPU + é«˜ç«¯ GPUï¼‰ã€‚
> - **Q5_K_M**ï¼šæ›´å¥½çš„ç²¾åº¦ï¼Œä½†è®¡ç®—å¼€é”€æ›´å¤§ã€‚
> - **Q8_K**ï¼šæœ€é«˜ç²¾åº¦ï¼Œä½†éœ€è¦æ›´å¤šæ˜¾å­˜ï¼ˆVRAMï¼‰ã€‚



å®é™…è®¡ç®—æœºåŒ…å«æœªåœ¨ä¸Šè¿°åˆ—è¡¨ä¸­çš„æŒ‡ä»¤ï¼Œè¿™äº›æŒ‡ä»¤åœ¨RAMæ¨¡å‹ä¸­ä»£è¡¨äº†ä¸€ä¸ªç°è‰²åœ°å¸¦ã€‚ä¾‹å¦‚ï¼Œå¹‚è¿ç®—æ˜¯å¦æ˜¯å¸¸æ•°æ—¶é—´æŒ‡ä»¤ï¼Ÿåœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¹¶ä¸æ˜¯ï¼›å½“xå’Œyæ˜¯å®æ•°æ—¶ï¼Œè®¡ç®— $x^y$ éœ€è¦å¤šæ¡æŒ‡ä»¤ã€‚ç„¶è€Œï¼Œ<mark>åœ¨æŸäº›å—é™çš„æƒ…å†µä¸‹ï¼Œå¹‚è¿ç®—æ˜¯ä¸€ä¸ªå¸¸æ•°æ—¶é—´æ“ä½œ</mark>ã€‚è®¸å¤šè®¡ç®—æœºæœ‰ä¸€ä¸ªâ€œå·¦ç§»â€æŒ‡ä»¤ï¼Œå®ƒå¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å°†ä¸€ä¸ªæ•´æ•°çš„ä½å‘å·¦ç§»åŠ¨ k ä¸ªä½ç½®ã€‚åœ¨å¤§å¤šæ•°è®¡ç®—æœºä¸­ï¼Œå°†ä¸€ä¸ªæ•´æ•°çš„ä½å‘å·¦ç§»åŠ¨ä¸€ä¸ªä½ç½®ç­‰ä»·äºä¹˜ä»¥ 2ï¼Œå› æ­¤å°†ä½å‘å·¦ç§»åŠ¨ k ä¸ªä½ç½®å°±ç­‰ä»·äºä¹˜ä»¥ $2^k$ã€‚å› æ­¤ï¼Œåªè¦ k ä¸è¶…è¿‡è®¡ç®—æœºå­—çš„ä½æ•°ï¼Œè¿™æ ·çš„è®¡ç®—æœºå¯ä»¥é€šè¿‡å°†æ•´æ•°1å·¦ç§»kä¸ªä½ç½®æ¥åœ¨ä¸€ä¸ªå¸¸æ•°æ—¶é—´å†…è®¡ç®—å‡º$2^k$ã€‚æˆ‘ä»¬å°†åŠªåŠ›é¿å…åœ¨RAMæ¨¡å‹ä¸­å‡ºç°è¿™æ ·çš„ç°è‰²åœ°å¸¦ï¼Œä½†åœ¨ k æ˜¯ä¸€ä¸ªè¶³å¤Ÿå°çš„æ­£æ•´æ•°æ—¶ï¼Œæˆ‘ä»¬ä¼šæŠŠ $2^k$ çš„è®¡ç®—è§†ä¸ºä¸€ä¸ªå¸¸æ•°æ—¶é—´æ“ä½œã€‚

> Real computers contain instructions not listed above, and such instructions represent a gray area in the RAM model. For example, is exponentiation a constanttime instruction? In the general case, no; it takes several instructions to compute $x^y$ when x and y are real numbers. In restricted situations, however, exponentiation is a constant-time operation. Many computers have a â€œshift leftâ€ instruction, which in constant time shifts the bits of an integer by k positions to the left. In most computers, shifting the bits of an integer by one position to the left is equivalent to multiplication by 2, so that shifting the bits by k positions to the left is equivalent to multiplication by $2^k$. Therefore, such computers can compute $2^k$ in one constant-time instruction by shifting the integer 1 by k positions to the left, as long as k is no more than the number of bits in a computer word. We will endeavor to avoid such gray areas in the RAM model, but we will treat computation of $2^k$ as a constant-time operation when k is a small enough positive integer.

<mark>åœ¨RAMæ¨¡å‹ä¸­ï¼Œå¹¶ä¸è¯•å›¾æ¨¡æ‹Ÿç°ä»£è®¡ç®—æœºä¸­å¸¸è§çš„å†…å­˜å±‚æ¬¡ç»“æ„</mark>ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸æ¨¡æ‹Ÿç¼“å­˜æˆ–è™šæ‹Ÿå†…å­˜ã€‚ä¸€äº›è®¡ç®—æ¨¡å‹å°è¯•è€ƒè™‘å†…å­˜å±‚æ¬¡ç»“æ„æ•ˆåº”ï¼Œè¿™åœ¨å®é™…ç¨‹åºè¿è¡Œåœ¨çœŸå®æœºå™¨ä¸Šæ—¶æœ‰æ—¶æ˜¯éå¸¸æ˜¾è‘—çš„ã€‚ä½†æ€»ä½“è€Œè¨€ï¼Œåˆ†æä¸ä¼šè€ƒè™‘å®ƒä»¬ã€‚åŒ…æ‹¬å†…å­˜å±‚æ¬¡ç»“æ„çš„æ¨¡å‹æ¯”RAMæ¨¡å‹å¤æ‚å¾—å¤šï¼Œæ‰€ä»¥å¯èƒ½éš¾äºä½¿ç”¨ã€‚æ­¤å¤–ï¼ŒåŸºäºRAMæ¨¡å‹çš„åˆ†æé€šå¸¸æ˜¯å®é™…æœºå™¨æ€§èƒ½çš„è‰¯å¥½é¢„æµ‹æŒ‡æ ‡ã€‚

> In the RAM model, we do not attempt to model the memory hierarchy that is common in contemporary computers. That is, we do not model caches or virtual memory. Several computational models attempt to account for memory-hierarchy effects, which are sometimes significant in real programs on real machines. A handful of problems in this book examine memory-hierarchy effects, but for the most part, the analyses in this book will not consider them. Models that include the memory hierarchy are quite a bit more complex than the RAM model, and so they can be difficult to work with. Moreover, RAM-model analyses are usually excellent predictors of performance on actual machines.

å³ä½¿æ˜¯åœ¨RAMæ¨¡å‹ä¸­åˆ†æä¸€ä¸ªç®€å•çš„ç®—æ³•ä¹Ÿå¯èƒ½æ˜¯ä¸€é¡¹æŒ‘æˆ˜ã€‚æ‰€éœ€çš„æ•°å­¦å·¥å…·å¯èƒ½åŒ…æ‹¬ç»„åˆæ•°å­¦ã€æ¦‚ç‡è®ºã€ä»£æ•°æŠ€å·§ä»¥åŠè¯†åˆ«å…¬å¼ä¸­æœ€é‡è¦é¡¹çš„èƒ½åŠ›ã€‚ç”±äºä¸€ä¸ªç®—æ³•çš„è¡Œä¸ºå¯èƒ½å¯¹æ¯ä¸ªå¯èƒ½çš„è¾“å…¥éƒ½æ˜¯ä¸åŒçš„ï¼Œéœ€è¦ä¸€ç§æ–¹å¼æ¥ç”¨ç®€å•ä¸”æ˜“äºç†è§£çš„å…¬å¼æ¦‚æ‹¬è¿™ç§è¡Œä¸ºã€‚

> Analyzing even a simple algorithm in the RAM model can be a challenge. The mathematical tools required may include combinatorics, probability theory, algebraic dexterity, and the ability to identify the most significant terms in a formula. Because the behavior of an algorithm may be different for each possible input, we need a means for summarizing that behavior in simple, easily understood formulas.

å°½ç®¡é€šå¸¸åªé€‰æ‹©ä¸€ç§æœºå™¨æ¨¡å‹æ¥åˆ†æç»™å®šçš„ç®—æ³•ï¼Œä½†åœ¨å†³å®šå¦‚ä½•è¡¨è¾¾åˆ†ææ—¶ï¼Œä»ç„¶é¢ä¸´è®¸å¤šé€‰æ‹©ã€‚å¸Œæœ›æœ‰ä¸€ç§æ–¹æ³•å¯ä»¥ç®€å•åœ°ä¹¦å†™å’Œæ“ä½œï¼Œèƒ½å¤Ÿå±•ç¤ºç®—æ³•èµ„æºéœ€æ±‚çš„é‡è¦ç‰¹å¾ï¼Œå¹¶æŠ‘åˆ¶ç¹ççš„ç»†èŠ‚ã€‚

> Even though we typically select only one machine model to analyze a given algorithm, we still face many choices in deciding how to express our analysis. We would like a way that is simple to write and manipulate, shows the important characteristics of an algorithmâ€™s resource requirements, and suppresses tedious details.

### 1 Analysis of insertion sort

åœ¨ç®—æ³•åˆ†æä¸­æœ‰ä¸¤ä¸ªå…³é”®æ¦‚å¿µï¼šè¾“å…¥è§„æ¨¡ï¼ˆinput sizeï¼‰å’Œè¿è¡Œæ—¶é—´ï¼ˆrunning timeï¼‰ï¼Œå¹¶ä»¥æ’å…¥æ’åºï¼ˆINSERTION-SORTï¼‰ä¸ºä¾‹æ¥è¯´æ˜è¿™äº›æ¦‚å¿µã€‚

> The time taken by the INSERTION-SORT procedure depends on the input: sorting a thousand numbers takes longer than sorting three numbers. Moreover, INSERTIONSORT can take different amounts of time to sort two input sequences of the same size depending on how nearly sorted they already are. In general, the time taken by an algorithm grows with the size of the input, so it is traditional to describe the running time of a program as a function of the size of its input. To do so, we need to define the terms â€œrunning timeâ€ and â€œsize of inputâ€ more carefully.



**è¾“å…¥è§„æ¨¡**æ˜¯è¡¡é‡ä¸€ä¸ªç®—æ³•è¾“å…¥å¤§å°çš„æ ‡å‡†ï¼Œå®ƒå–å†³äºå…·ä½“çš„é—®é¢˜ã€‚å¯¹äºä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚æ’åºæˆ–è®¡ç®—ç¦»æ•£å‚…é‡Œå¶å˜æ¢ï¼Œæœ€è‡ªç„¶çš„åº¦é‡æ–¹å¼æ˜¯è¾“å…¥ä¸­é¡¹ç›®çš„æ•°é‡â€”â€”ä¾‹å¦‚ï¼Œæ’åºæ—¶çš„æ•°ç»„é•¿åº¦nã€‚å¯¹äºå…¶ä»–é—®é¢˜ï¼Œå¦‚æ•´æ•°ä¹˜æ³•ï¼Œè¾“å…¥è§„æ¨¡çš„æœ€ä½³åº¦é‡å¯èƒ½æ˜¯è¡¨ç¤ºè¾“å…¥æ‰€éœ€çš„æ€»ä½æ•°ã€‚<mark>æœ‰æ—¶ï¼Œç”¨ä¸¤ä¸ªæ•°å­—æè¿°è¾“å…¥è§„æ¨¡æ¯”ç”¨ä¸€ä¸ªæ›´åˆé€‚ï¼Œä¾‹å¦‚ï¼Œå¦‚æœç®—æ³•çš„è¾“å…¥æ˜¯ä¸€ä¸ªå›¾ï¼Œåˆ™å¯ä»¥ç”¨é¡¶ç‚¹å’Œè¾¹çš„æ•°é‡æ¥æè¿°è¾“å…¥è§„æ¨¡</mark>ã€‚

> The best notion for **input size** depends on the problem being studied. For many problems, such as sorting or computing discrete Fourier transforms, the most natural measure is the number of items in the inputâ€”for example, the array size n for sorting. For many other problems, such as multiplying two integers, the best measure of input size is the total number of bits needed to represent the input in ordinary binary notation. Sometimes, it is more appropriate to describe the size of the input with two numbers rather than one. For instance, if the input to an algorithm is a graph, the input size can be described by the numbers of vertices and edges in the graph. We shall indicate which input size measure is being used with each problem we study.



<mark>**è¿è¡Œæ—¶é—´**æ˜¯æŒ‡ç‰¹å®šè¾“å…¥ä¸Šç®—æ³•æ‰§è¡Œçš„åŸºæœ¬æ“ä½œæˆ–â€œæ­¥éª¤â€çš„æ•°é‡</mark>ã€‚ä¸ºäº†ä½¿è¿™ä¸ªæ¦‚å¿µå°½å¯èƒ½ä¸æœºå™¨æ— å…³ï¼Œé€šå¸¸å‡è®¾ä¼ªä»£ç ä¸­çš„æ¯ä¸€è¡Œéœ€è¦å¸¸é‡æ—¶é—´æ¥æ‰§è¡Œã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸€è¡Œå¯èƒ½éœ€è¦ä¸åŒçš„æ—¶é—´ï¼Œä½†æ¯æ‰§è¡Œç¬¬iè¡Œæ‰€éœ€çš„æ—¶é—´ä¸ºciï¼Œå…¶ä¸­ciæ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚è¿™ç§è§‚ç‚¹ç¬¦åˆéšæœºè®¿é—®æœºï¼ˆRAMï¼‰æ¨¡å‹ï¼Œå¹¶ä¸”åæ˜ äº†å¤§å¤šæ•°å®é™…è®¡ç®—æœºä¸Šå¦‚ä½•å®ç°ä¼ªä»£ç ã€‚

> The **running time** of an algorithm on a particular input is the number of primitive operations or â€œstepsâ€ executed. It is convenient to define the notion of step so that it is as machine-independent as possible. For the moment, let us adopt the following view. A constant amount of time is required to execute each line of our pseudocode. One line may take a different amount of time than another line, but we shall assume that each execution of the ith line takes time ci, where ci is a constant. This viewpoint is in keeping with the **RAM** model, and it also reflects how the pseudocode would be implemented on most actual computers.



éšç€è®¨è®ºçš„æ·±å…¥ï¼Œå¯¹æ’å…¥æ’åºè¿è¡Œæ—¶é—´çš„è¡¨è¾¾å°†ä»ä½¿ç”¨æ‰€æœ‰è¯­å¥æˆæœ¬ciçš„å¤æ‚å…¬å¼æ¼”å˜ä¸ºä¸€ç§æ›´ç®€å•ã€æ›´ç®€æ´ã€æ›´æ˜“å¤„ç†çš„ç¬¦å·ã€‚è¿™ç§ç®€åŒ–åçš„ç¬¦å·ä¹Ÿå°†ä½¿å¾—æ¯”è¾ƒä¸åŒç®—æ³•çš„æ•ˆç‡å˜å¾—æ›´åŠ å®¹æ˜“ã€‚

> In the following discussion, our expression for the running time of INSERTIONSORT will evolve from a messy formula that uses all the statement costs ci to a much simpler notation that is more concise and more easily manipulated. This simpler notation will also make it easy to determine whether one algorithm is more efficient than another.



æ¥ä¸‹æ¥ï¼Œä½¿ç”¨æ’å…¥æ’åºè¿‡ç¨‹æ¥å±•ç¤ºæ¯ä¸ªè¯­å¥çš„æ—¶é—´â€œæˆæœ¬â€ä»¥åŠæ¯ä¸ªè¯­å¥è¢«æ‰§è¡Œçš„æ¬¡æ•°ã€‚å¯¹äºæ¯ä¸€ä¸ª`j = 2, 3, ..., n`ï¼ˆå…¶ä¸­`n = A.length`ï¼‰ï¼Œä»¤$t_j$è¡¨ç¤ºå½“jå–è¯¥å€¼æ—¶ï¼Œç¬¬7è¡Œçš„whileå¾ªç¯æµ‹è¯•è¢«æ‰§è¡Œçš„æ¬¡æ•°ã€‚å½“foræˆ–whileå¾ªç¯ä»¥å¸¸è§„æ–¹å¼é€€å‡ºï¼ˆå³ç”±äºå¾ªç¯å¤´ä¸­çš„æµ‹è¯•ï¼‰æ—¶ï¼Œæµ‹è¯•è¢«æ‰§è¡Œçš„æ¬¡æ•°æ¯”å¾ªç¯ä½“å¤šä¸€æ¬¡ã€‚å¦å¤–ï¼Œè¿™é‡Œå‡å®šæ³¨é‡Šä¸æ˜¯å¯æ‰§è¡Œè¯­å¥ï¼Œå› æ­¤å®ƒä»¬ä¸éœ€è¦ä»»ä½•æ—¶é—´ã€‚

> We start by presenting the INSERTION-SORT procedure with the time â€œcostâ€ of each statement and the number of times each statement is executed. For each `j = 2, 3, ... , n`, where `n = A.length`, we let $t_j$ denote the number of times the **while** loop test in line 7 is executed for that value of j . When a **for** or **while** loop exits in the usual way (i.e., due to the test in the loop header), the test is executed one time more than the loop body. We assume that comments are not executable statements, and so they take no time.

Implementation of Insertion Sort Algorithm

> <mark>**æ’å…¥æ’åº**æ˜¯ä¸€ç§ç®€å•çš„æ’åºç®—æ³•ï¼Œå…¶å·¥ä½œåŸç†ç±»ä¼¼äºä½ åœ¨æ‰‹ä¸­æ•´ç†æ‰‘å…‹ç‰Œçš„æ–¹å¼ã€‚æ•°ç»„è¢«è™šæ‹Ÿåœ°åˆ†æˆå·²æ’åºå’Œæœªæ’åºä¸¤éƒ¨åˆ†ã€‚ä»æœªæ’åºéƒ¨åˆ†é€‰å–å€¼ï¼Œå¹¶å°†å…¶æ”¾ç½®åˆ°å·²æ’åºéƒ¨åˆ†çš„æ­£ç¡®ä½ç½®ä¸Šã€‚</mark>
>
> `\sum_{j=1}^{n-1} t_j`  æ˜¯ $\sum_{j=1}^{n-1} t_j$ çš„LaTexè¡¨ç¤ºï¼Œ
>
> `\sum_{j=1}^{n-1} (t_{j}-1)` æ˜¯ $\sum_{j=1}^{n-1} (t_{j}-1)$â€‹ çš„LaTexè¡¨ç¤ºã€‚

```python
def insertion_sort(arr):														# cost	times
    for i in range(1, len(arr)):										# c1		n
        j = i																				# c2 		n - 1
        
        # Insert arr[j] into the
        # sorted sequence arry[0..j-1]							#	0			n - 1
        while arr[j - 1] > arr[j] and j > 0:				# c4		\sum_{j=1}^{n-1} t_j
            arr[j - 1], arr[j] = arr[j], arr[j - 1] # c5		\sum_{j=1}^{n-1} (t_j - 1)
            j -= 1																	# c6		\sum_{j=1}^{n-1} (t_j - 1)


arr = [2, 6, 5, 1, 3, 4]
insertion_sort(arr)
print(arr)

# [1, 2, 3, 4, 5, 6]
```





> https://www.geeksforgeeks.org/insertion-sort/
>
> **Insertion sort** is a simple sorting algorithm that works similarly to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed in the correct position in the sorted part.
>
> 
>
> è¦ä»¥å‡åºå¯¹å¤§å°ä¸ºNçš„æ•°ç»„è¿›è¡Œæ’åºï¼Œéœ€è¦éå†æ•°ç»„å¹¶å°†å½“å‰å…ƒç´ ï¼ˆç§°ä¸ºâ€œå…³é”®å­—â€ï¼‰ä¸å®ƒçš„å‰ä¸€ä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼›å¦‚æœå…³é”®å­—æ¯”å®ƒçš„å‰ä¸€ä¸ªå…ƒç´ å°ï¼Œåˆ™å°†å®ƒä¸å‰é¢çš„å…ƒç´ è¿›è¡Œæ¯”è¾ƒã€‚å°†è¾ƒå¤§çš„å…ƒç´ ç§»åŠ¨ä¸€ä¸ªä½ç½®ä»¥è…¾å‡ºç©ºé—´ç»™è¢«äº¤æ¢çš„å…ƒç´ ã€‚
>
> To sort an array of size N in ascending order iterate over the array and compare the current element (key) to its predecessor, if the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.
>
> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/insertionsort.png" alt="insertion-sort" style="zoom:50%;" />



<mark>ç¬”è¯•é¢˜ç›®ç¤ºä¾‹</mark>

> **Q:** Suppose you have the following list of numbers to sort: [15, 5, 4, 18, 12, 19, 14, 10, 8, 20] which list represents the partially sorted list after three complete passes of insertion sort? (C)
>
> A. [4, 5, 12, 15, 14, 10, 8, 18, 19, 20]
> B. [15, 5, 4, 10, 12, 8, 14, 18, 19, 20]
> **C. [4, 5, 15, 18, 12, 19, 14, 10, 8, 20]**
> D. [15, 5, 4, 18, 12, 19, 14, 8, 10, 20]



ç®—æ³•çš„è¿è¡Œæ—¶é—´æ˜¯æ¯ä¸ªè¢«æ‰§è¡Œè¯­å¥çš„è¿è¡Œæ—¶é—´ä¹‹å’Œï¼›ä¸€ä¸ªæ‰§è¡Œä¸€æ¬¡éœ€è¦$c_i$æ­¥éª¤å¹¶ä¸”æ€»å…±æ‰§è¡Œnæ¬¡çš„è¯­å¥å°†å¯¹æ€»è¿è¡Œæ—¶é—´è´¡çŒ®$c_i \times n$ã€‚ä¸ºäº†è®¡ç®—T(n)ï¼Œå³åœ¨nä¸ªå€¼çš„è¾“å…¥ä¸ŠINSERTION-SORTçš„è¿è¡Œæ—¶é—´ï¼Œæˆ‘ä»¬å°†æˆæœ¬åˆ—å’Œæ¬¡æ•°åˆ—çš„ä¹˜ç§¯ç›¸åŠ ï¼Œå¾—åˆ°

$ T(n) = \sum (c_i \times t_i) $

è¿™é‡Œï¼Œæ¯ä¸ª$c_i$ä»£è¡¨ä¼ªä»£ç ä¸­ç¬¬iè¡Œæ‰§è¡Œä¸€æ¬¡æ‰€éœ€çš„æ—¶é—´ï¼ˆå¸¸é‡ï¼‰ï¼Œè€Œ$t_i$åˆ™è¡¨ç¤ºè¯¥è¡Œè¢«æ‰§è¡Œçš„æ¬¡æ•°ã€‚å¯¹äºæ’å…¥æ’åºï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘æ¯ä¸€è¡Œä»£ç è¢«æ‰§è¡Œçš„å…·ä½“æƒ…å†µï¼Œç‰¹åˆ«æ˜¯å†…å±‚å¾ªç¯çš„æ‰§è¡Œæ¬¡æ•°ä¼šä¾èµ–äºæ•°ç»„ä¸­å…ƒç´ çš„åˆå§‹æ’åˆ—ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸€ä¸ªå…³äºnï¼ˆè¾“å…¥å¤§å°ï¼‰çš„å‡½æ•°è¡¨è¾¾å¼ï¼Œç”¨æ¥æè¿°æ’å…¥æ’åºçš„è¿è¡Œæ—¶é—´ã€‚

> The running time of the algorithm is the sum of running times for each statement executed; a statement that takes $c_i$ steps to execute and executes n times will contribute $c_in$â€‹ to the total running time. To compute T(n), the running time of INSERTION-SORT on an input of n values, we sum the products of the cost and times columns, obtaining



$T(n) = c_1n + c_2(n-1) + c_4\sum_{j=1}^{n-1} t_j + c_5\sum_{j=1}^{n-1} (t_j-1) + c_6\sum_{j=1}^{n-1} (t_j-1)$



å³ä½¿å¯¹äºç»™å®šå¤§å°çš„è¾“å…¥ï¼Œ<mark>ç®—æ³•çš„è¿è¡Œæ—¶é—´ä¹Ÿå¯èƒ½å–å†³äºç»™å‡ºçš„æ˜¯å“ªä¸ªå…·ä½“è¾“å…¥</mark>ã€‚ä¾‹å¦‚ï¼Œåœ¨æ’å…¥æ’åºï¼ˆINSERTION-SORTï¼‰ä¸­ï¼Œæœ€ä½³æƒ…å†µå‘ç”Ÿåœ¨æ•°ç»„å·²ç»æ˜¯æœ‰åºçš„æ—¶å€™ã€‚å¯¹äºæ¯ä¸ªi = 1, 2, 3, ..., n-1ï¼Œå½“$j$åœ¨å…¶åˆå§‹å€¼$i$æ—¶ï¼Œæˆ‘ä»¬åœ¨ç¬¬7è¡Œå‘ç°$arr[j-1] \le arr[j]$ã€‚å› æ­¤ï¼Œå¯¹äºi = 1, 2, 3, ..., n-1ï¼Œæœ‰$t_j = 1$ï¼Œè¿™æ—¶æœ€ä½³æƒ…å†µä¸‹çš„è¿è¡Œæ—¶é—´æ˜¯

> Even for inputs of a given size, an algorithmâ€™s running time may depend on which input of that size is given. For example, in INSERTION-SORT, the best case occurs if the array is already sorted. For each i = 1, 2, 3, ... , n-1, we then find that $arr[j-1] \le arr[j]$ in line 7 when $j$ has its initial value of $i$. Thus $t_j = 1$ for i = 1, 2, 3, ... , n-1, and the best-case running time is



$T_{\text{best}}(n) = c_1n + c_2(n-1) + c_4(n-1)$â€‹

$\quad = (c_1 + c_2 + c_4)n - (c_2 + c_4)$



æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªè¿è¡Œæ—¶é—´è¡¨ç¤ºä¸º`an + b`ï¼Œå…¶ä¸­å¸¸é‡aå’Œbå–å†³äºè¯­å¥æˆæœ¬$c_i$ï¼›å› æ­¤ï¼Œå®ƒæ˜¯nçš„**çº¿æ€§å‡½æ•°**ã€‚

å¦‚æœæ•°ç»„æ˜¯ä»¥é€†åºæ’åºçš„â€”â€”ä¹Ÿå°±æ˜¯è¯´ï¼Œä»¥é€’å‡é¡ºåºæ’åˆ—â€”â€”é‚£ä¹ˆå°±ä¼šå‡ºç°æœ€åæƒ…å†µã€‚æˆ‘ä»¬å¿…é¡»å°†æ¯ä¸ªå…ƒç´ A[j]ä¸æ•´ä¸ªå·²æ’åºå­æ•°ç»„`A[0..j-1]`ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œå› æ­¤ $t_j = j$ å¯¹äº`j = 1, 2, ..., n-1`ã€‚æ³¨æ„åˆ°è¿™ä¸€ç‚¹ï¼Œ

> We can express this running time as `an + b` for constants a and b that depend on the statement costs $c_i$; it is thus a **linear function** of n.
>
> If the array is in reverse sorted orderâ€”that is, in decreasing orderâ€”the worst case results. We must compare each element A[j]  with each element in the entire sorted subarray `A[0..j-1]`, and so $t_j = j$ for `j = 1, 2, ..., n-1`. Noting that

$\sum_{j=1}^{n-1} j = \frac{n(n-1)}{2}$â€‹ 

$\sum_{j=1}^{n-1} (j-1) = \frac{(n-1)(n-2)}{2}$ 

we find that in the worst case, the running time of INSERTION-SORT is



$T_{\text{worst}}(n) = c_1n + c_2(n-1) + c_4(\frac{n(n-1)}{2} -1) + c_5(\frac{(n-1)(n-2)}{2}) + + c_6(\frac{(n-1)(n-2)}{2})$

$\quad = (\frac{c_4}2 + \frac{c_5}2 + \frac{c_6}2)n^2 + (c_1 + c_2 - \frac{c_4}2 - \frac{3c_5}2 - \frac{2c_6}2)n + (-c_2 - c_4 + c_5 + c_6)$



å¯ä»¥å°†è¿™ç§æœ€åæƒ…å†µä¸‹çš„è¿è¡Œæ—¶é—´è¡¨ç¤ºä¸º$an^2 + bn + c$ï¼Œå…¶ä¸­å¸¸é‡aã€bå’Œcå†æ¬¡å–å†³äºè¯­å¥æˆæœ¬$c_i$ï¼›å› æ­¤ï¼Œå®ƒæ˜¯nçš„**äºŒæ¬¡å‡½æ•°**ã€‚

é€šå¸¸æƒ…å†µä¸‹ï¼Œå°±åƒåœ¨æ’å…¥æ’åºä¸­ä¸€æ ·ï¼Œå¯¹äºç»™å®šçš„è¾“å…¥ï¼Œç®—æ³•çš„è¿è¡Œæ—¶é—´æ˜¯å›ºå®šçš„ï¼Œå°½ç®¡ä¸€äº›æœ‰è¶£çš„â€œéšæœºåŒ–â€ç®—æ³•ï¼Œå³ä½¿å¯¹äºå›ºå®šçš„è¾“å…¥ï¼Œå®ƒä»¬çš„è¡Œä¸ºä¹Ÿå¯èƒ½æœ‰æ‰€ä¸åŒã€‚

> We can express this worst-case running time as $an^2 + bn + c$ for constants a, b, and c that again depend on the statement costs ci; it is thus a **quadratic function** of n.
>
> Typically, as in insertion sort, the running time of an algorithm is fixed for a given input, although in later chapters we shall see some interesting â€œrandomizedâ€ algorithms whose behavior can vary even for a fixed input.



### 2 Worst-case and average-case analysis

åœ¨æˆ‘ä»¬å¯¹æ’å…¥æ’åºçš„åˆ†æä¸­ï¼Œæˆ‘ä»¬æ—¢è€ƒè™‘äº†æœ€ä½³æƒ…å†µï¼Œå³è¾“å…¥æ•°ç»„å·²ç»æ’åºçš„æƒ…å†µï¼Œä¹Ÿè€ƒè™‘äº†æœ€åæƒ…å†µï¼Œå³è¾“å…¥æ•°ç»„æ˜¯é€†åºæ’åˆ—çš„æƒ…å†µã€‚ç„¶è€Œï¼Œ<mark>é€šå¸¸ä¸“æ³¨äºå¯»æ‰¾åªæœ‰æœ€åæƒ…å†µä¸‹çš„è¿è¡Œæ—¶é—´</mark>ï¼Œä¹Ÿå°±æ˜¯å¯¹äºä»»ä½•å¤§å°ä¸ºnçš„è¾“å…¥æœ€é•¿çš„è¿è¡Œæ—¶é—´ã€‚æˆ‘ä»¬ç»™å‡ºå…³æ³¨æœ€åæƒ…å†µçš„ä¸‰ä¸ªç†ç”±ï¼š

> In our analysis of insertion sort, we looked at both the best case, in which the input array was already sorted, and the worst case, in which the input array was reverse sorted. For the remainder of this book, though, we shall usually concentrate on finding only the **worst-case running time**, that is, the longest running time for any input of size n. We give three reasons for this orientation.



- ä¸€ä¸ªç®—æ³•çš„æœ€åæƒ…å†µä¸‹çš„è¿è¡Œæ—¶é—´ä¸ºä»»ä½•è¾“å…¥æä¾›äº†ä¸€ä¸ªè¿è¡Œæ—¶é—´çš„ä¸Šé™ã€‚äº†è§£å®ƒæä¾›äº†ç®—æ³•æ°¸è¿œä¸ä¼šè¶…è¿‡è¿™ä¸ªæ—¶é—´çš„ä¿è¯ã€‚

- å¯¹äºæŸäº›ç®—æ³•ï¼Œæœ€åæƒ…å†µå‡ºç°å¾—ç›¸å½“é¢‘ç¹ã€‚ä¾‹å¦‚ï¼Œåœ¨æ•°æ®åº“ä¸­æœç´¢ç‰¹å®šä¿¡æ¯æ—¶ï¼Œ<mark>å½“ä¿¡æ¯ä¸åœ¨æ•°æ®åº“ä¸­æ—¶ï¼Œæœç´¢ç®—æ³•çš„æœ€åæƒ…å†µç»å¸¸å‘ç”Ÿ</mark>ã€‚åœ¨æŸäº›åº”ç”¨ä¸­ï¼Œå¯èƒ½ç»å¸¸ä¼šè¿›è¡Œä¸å­˜åœ¨çš„ä¿¡æ¯æœç´¢ã€‚

  

<mark>ç¬”è¯•é¢˜ç›®ç¤ºä¾‹</mark>

> å¯¹é•¿åº¦ä¸º 3 çš„é¡ºåºè¡¨è¿›è¡ŒæŸ¥æ‰¾ï¼Œè‹¥æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå…ƒç´ çš„æ¦‚ç‡ä¸º 1/2ï¼ŒæŸ¥æ‰¾ç¬¬äºŒä¸ªå…ƒç´ çš„æ¦‚ç‡ä¸º 1/4ï¼ŒæŸ¥æ‰¾ç¬¬ä¸‰ä¸ªå…ƒç´ çš„æ¦‚ç‡ä¸º 1/8ï¼Œåˆ™æ‰§è¡Œä»»æ„æŸ¥æ‰¾éœ€è¦æ¯”è¾ƒå…ƒç´ çš„å¹³å‡ä¸ªæ•°ä¸º _ _ _ _ ã€‚
>
> #$1*(1/2) + 2*(1/4) + 3*(1/8) + 3*(1/8) = 1.75$, è¿˜æœ‰1/8çš„å¤±è´¥æŸ¥è¯¢æ¦‚ç‡ã€‚
>
> 

- â€œå¹³å‡æƒ…å†µâ€é€šå¸¸å‡ ä¹å’Œæœ€åæƒ…å†µä¸€æ ·ç³Ÿç³•ã€‚å‡è®¾æˆ‘ä»¬éšæœºé€‰æ‹©nä¸ªæ•°å­—å¹¶åº”ç”¨æ’å…¥æ’åºã€‚ç¡®å®šå…ƒç´ A[j]åº”è¯¥æ’å…¥åˆ°å­æ•°ç»„`A[0 .. j-1]`ä¸­çš„å“ªä¸ªä½ç½®éœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿå¹³å‡æ¥è¯´ï¼Œ`A[0 .. j-1]`ä¸­çš„ä¸€åŠå…ƒç´ å°äº`A[j]`ï¼Œå¦ä¸€åŠå¤§äº`A[j]`ã€‚å› æ­¤ï¼Œå¹³å‡è€Œè¨€ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥å­æ•°ç»„`A[0 .. j-1]`çš„ä¸€åŠï¼Œæ‰€ä»¥$t_j$å¤§çº¦æ˜¯$j/2$ã€‚ç»“æœå¾—åˆ°çš„å¹³å‡æƒ…å†µä¸‹çš„è¿è¡Œæ—¶é—´æœ€ç»ˆæ˜¯è¾“å…¥è§„æ¨¡çš„äºŒæ¬¡å‡½æ•°ï¼Œå°±åƒæœ€åæƒ…å†µä¸‹çš„è¿è¡Œæ—¶é—´ä¸€æ ·ã€‚

> The worst-case running time of an algorithm gives us an upper bound on the running time for any input. Knowing it provides a guarantee that the algorithm will never take any longer. We need not make some educated guess about the running time and hope that it never gets much worse.
>
> For some algorithms, the worst case occurs fairly often. For example, in searching a database for a particular piece of information, the searching algorithmâ€™s worst case will often occur when the information is not present in the database. In some applications, searches for absent information may be frequent.
>
> The â€œaverage caseâ€ is often roughly as bad as the worst case. Suppose that we randomly choose n numbers and apply insertion sort. How long does it take to determine where in subarray `A[0 ..  j-1]` to insert element A[j] ? On average, half the elements in `A[0 .. j-1]` are less than `A[j]` , and half the elements are greater. On average, therefore, we check half of the subarray `A[0 ..  j-1]`, and so $t_j$ is about $j/2$. The resulting average-case running time turns out to be a quadratic function of the input size, just like the worst-case running time.



> åœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†å¯¹ç®—æ³•çš„**å¹³å‡æƒ…å†µ**è¿è¡Œæ—¶é—´æ„Ÿå…´è¶£ï¼›æˆ‘ä»¬å°†çœ‹åˆ°**æ¦‚ç‡åˆ†æ**æŠ€æœ¯åº”ç”¨äºå„ç§ç®—æ³•ã€‚å¹³å‡æƒ…å†µåˆ†æçš„èŒƒå›´æ˜¯æœ‰é™çš„ï¼Œå› ä¸ºå¯èƒ½ä¸æ¸…æ¥šä»€ä¹ˆæ„æˆç‰¹å®šé—®é¢˜çš„â€œå¹³å‡â€è¾“å…¥ã€‚ç»å¸¸å‡è®¾æ‰€æœ‰ç»™å®šå¤§å°çš„è¾“å…¥éƒ½æ˜¯ç­‰å¯èƒ½çš„ã€‚å®é™…ä¸Šï¼Œè¿™ä¸€å‡è®¾å¯èƒ½ä¼šè¢«è¿åï¼Œä½†æœ‰æ—¶å¯ä»¥ä½¿ç”¨ä¸€ç§**éšæœºåŒ–ç®—æ³•**ï¼Œå®ƒä¼šåšå‡ºéšæœºé€‰æ‹©ï¼Œä»è€Œä½¿æ¦‚ç‡åˆ†ææˆä¸ºå¯èƒ½ï¼Œå¹¶å¾—å‡ºä¸€ä¸ª**æœŸæœ›**çš„è¿è¡Œæ—¶é—´ã€‚
>
> In some particular cases, we shall be interested in the **average-case** running time of an algorithm; we shall see the technique of **probabilistic analysis** applied to various algorithms throughout this book. The scope of average-case analysis is limited, because it may not be apparent what constitutes an â€œaverageâ€ input for a particular problem. Often, we shall assume that all inputs of a given size are equally likely. In practice, this assumption may be violated, but we can sometimes use a **randomized algorithm**, which makes random choices, to allow a probabilistic analysis and yield an **expected** running time. 

### 3 Order of growthå¢é•¿é‡çº§

æˆ‘ä»¬ä½¿ç”¨äº†ä¸€äº›ç®€åŒ–çš„æŠ½è±¡æ¥ç®€åŒ–å¯¹INSERTIONSORTè¿‡ç¨‹çš„åˆ†æã€‚é¦–å…ˆï¼Œå¿½ç•¥äº†æ¯ä¸ªè¯­å¥çš„å®é™…æˆæœ¬ï¼Œç”¨å¸¸æ•°$c_i$æ¥è¡¨ç¤ºè¿™äº›æˆæœ¬ã€‚ç„¶åï¼Œæ³¨æ„åˆ°å³ä½¿è¿™äº›å¸¸æ•°ä¹Ÿç»™å‡ºäº†æ¯”å®é™…éœ€è¦æ›´å¤šçš„ç»†èŠ‚ï¼šå°†æœ€åæƒ…å†µä¸‹çš„è¿è¡Œæ—¶é—´è¡¨è¾¾ä¸º$an^2 + bn + c$ï¼Œå…¶ä¸­aã€bå’Œcæ˜¯ä¾èµ–äºè¯­å¥æˆæœ¬$c_i$çš„å¸¸æ•°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸ä»…å¿½ç•¥äº†å®é™…çš„è¯­å¥æˆæœ¬ï¼Œè¿˜å¿½ç•¥äº†æŠ½è±¡æˆæœ¬$c_i$ã€‚

> We used some simplifying abstractions to ease our analysis of the INSERTIONSORT procedure. First, we ignored the actual cost of each statement, using the constants ci to represent these costs. Then, we observed that even these constants give us more detail than we really need: we expressed the worst-case running time as $an^2 + bn + c$ for some constants a, b, and c that depend on the statement costs $c_i$. We thus ignored not only the actual statement costs, but also the abstract costs $c_i$.



ç°åœ¨æˆ‘ä»¬å°†å¼•å…¥å¦ä¸€ä¸ªç®€åŒ–çš„æŠ½è±¡ï¼š<mark>çœŸæ­£å¼•èµ·æˆ‘ä»¬å…´è¶£çš„æ˜¯è¿è¡Œæ—¶é—´çš„å¢é•¿ç‡ï¼Œæˆ–ç§°ä¸ºå¢é•¿é‡çº§</mark>ã€‚å› æ­¤ï¼Œåªè€ƒè™‘å…¬å¼çš„ä¸»è¦é¡¹ï¼ˆä¾‹å¦‚ï¼Œ$an^2$ï¼‰ï¼Œå› ä¸ºå¯¹äºnçš„è¾ƒå¤§å€¼æ¥è¯´ï¼Œä½é˜¶é¡¹ç›¸å¯¹æ¥è¯´ä¸é‚£ä¹ˆé‡è¦ã€‚å¿½ç•¥ä¸»è¦é¡¹çš„å¸¸æ•°ç³»æ•°ï¼Œå› ä¸ºåœ¨ç¡®å®šå¤§è¾“å…¥çš„è®¡ç®—æ•ˆç‡æ—¶ï¼Œå¸¸æ•°å› å­ä¸å¦‚å¢é•¿ç‡é‡è¦ã€‚å¯¹äºæ’å…¥æ’åºï¼Œå½“å¿½ç•¥ä½é˜¶é¡¹å’Œä¸»è¦é¡¹çš„å¸¸æ•°ç³»æ•°åï¼Œå‰©ä¸‹çš„æ˜¯æ¥è‡ªä¸»è¦é¡¹çš„$n^2$å› å­ã€‚è¯´æ’å…¥æ’åºå…·æœ‰$\Theta(n^2)$ï¼ˆå‘éŸ³ä¸ºâ€œtheta of n-squaredâ€ï¼‰çš„æœ€åæƒ…å†µè¿è¡Œæ—¶é—´ã€‚

> We shall now make one more simplifying abstraction: it is the **rate of growth**, or **order of growth**, of the running time that really interests us. We therefore consider only the leading term of a formula (e.g., $an^2$), since the lower-order terms are relatively insignificant for large values of n. We also ignore the leading termâ€™s constant coefficient, since constant factors are less significant than the rate of growth in determining computational efficiency for large inputs. For insertion sort, when we ignore the lower-order terms and the leading termâ€™s constant coefficient, we are left with the factor of $n^2$ from the leading term. We write that insertion sort has a worst-case running time of $\Theta(n^2)$ (pronounced â€œtheta of n-squaredâ€). 



é€šå¸¸æˆ‘ä»¬è®¤ä¸ºä¸€ä¸ªç®—æ³•å¦‚æœå…¶æœ€åæƒ…å†µè¿è¡Œæ—¶é—´çš„å¢é•¿é˜¶è¾ƒä½ï¼Œåˆ™å®ƒæ¯”å¦ä¸€ä¸ªç®—æ³•æ›´é«˜æ•ˆã€‚<mark>ç”±äºå¸¸æ•°å› å­å’Œä½é˜¶é¡¹çš„å½±å“ï¼Œä¸€ä¸ªè¿è¡Œæ—¶é—´å¢é•¿é˜¶è¾ƒé«˜çš„ç®—æ³•åœ¨å°è¾“å…¥çš„æƒ…å†µä¸‹å¯èƒ½ä¼šæ¯”ä¸€ä¸ªå¢é•¿é˜¶è¾ƒä½çš„ç®—æ³•èŠ±è´¹çš„æ—¶é—´æ›´å°‘</mark>ã€‚ä½†å¯¹äºè¶³å¤Ÿå¤§çš„è¾“å…¥ï¼Œä¾‹å¦‚ï¼Œåœ¨æœ€åæƒ…å†µä¸‹ï¼Œä¸€ä¸ª$\Theta(n^2)$çš„ç®—æ³•å°†æ¯”ä¸€ä¸ª$\Theta(n^3)$çš„ç®—æ³•è¿è¡Œå¾—æ›´å¿«ã€‚

> We usually consider one algorithm to be more efficient than another if its worstcase running time has a lower order of growth. Due to constant factors and lowerorder terms, an algorithm whose running time has a higher order of growth might take less time for small inputs than an algorithm whose running time has a lower order of growth. But for large enough inputs, a $\Theta(n^2)$ algorithm, for example, will run more quickly in the worst case than a $\Theta(n^3)$â€‹ algorithm.
>
> è¿™é‡Œæåˆ°çš„$\Theta$ ç¬¦å·æ˜¯ç”¨æ¥æè¿°ç®—æ³•è¿è¡Œæ—¶é—´çš„å¢é•¿é˜¶çš„ç´§ç¡®ç•Œï¼Œæ„å‘³ç€ç®—æ³•çš„è¿è¡Œæ—¶é—´åœ¨æ¸è¿‘æƒ…å†µä¸‹æ—¢ä¸ä¼šå¿«äºä¹Ÿä¸ä¼šæ…¢äº$n^2$çš„æŸä¸ªå¸¸æ•°å€ã€‚è¿™æ˜¯å…³äºç®—æ³•å¤æ‚åº¦åˆ†æä¸­çš„æ¸è¿‘è®°æ³•çš„ä¸€ç§è¡¨è¿°æ–¹å¼ï¼Œç”¨æ¥æ¦‚æ‹¬åœ°è¯´æ˜ç®—æ³•æ€§èƒ½éšè¾“å…¥è§„æ¨¡å˜åŒ–çš„è¶‹åŠ¿ã€‚



### 4 O-notation

> é€šç”¨çš„è®°å·åº”è¯¥æ˜¯ï¼ŒOè¡¨ç¤ºä¸Šç•Œï¼Œ$\Omega$è¡¨ç¤ºä¸‹ç•Œï¼Œ$\Theta$è¡¨ç¤ºæ¸è¿›é˜¶ï¼Œå°±æ˜¯æ—¢ä¸Šç•Œåˆä¸‹ç•Œã€‚

$\Theta$-è®°å·ä»æ¸è¿‘ä¸Šç•Œå’Œä¸‹ç•Œä¸¤ä¸ªæ–¹é¢çº¦æŸä¸€ä¸ªå‡½æ•°ã€‚å½“æˆ‘ä»¬åªæœ‰æ¸è¿‘ä¸Šç•Œæ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨O-è®°å·ã€‚å¯¹äºç»™å®šçš„å‡½æ•°g(n)ï¼Œç”¨O(g(n)ï¼ˆè¯»ä½œâ€œå¤§O of g of nâ€æˆ–ç®€ç§°â€œO of g of nâ€ï¼‰æ¥è¡¨ç¤ºæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„å‡½æ•°é›†åˆï¼š

> The $\Theta$-notation asymptotically bounds a function from above and below. When we have only an asymptotic upper bound, we use O-notation. For a given function g(n), we denote by O(g(n) (pronounced â€œbig-oh of g of nâ€ or sometimes just â€œoh of g of nâ€) the set of functions



$ O(g(n)) = \{f(n): å­˜åœ¨æ­£çš„å¸¸æ•°c å’Œ n_0ï¼Œä½¿å¾—å¯¹æ‰€æœ‰ n â‰¥ n_0, æœ‰ 0 â‰¤ f(n) â‰¤ cg(n)\} $

æˆ‘ä»¬ä½¿ç”¨O-è®°å·æ¥ç»™å‡ºä¸€ä¸ªå‡½æ•°çš„ä¸Šç•Œï¼Œæœ€å¤šç›¸å·®ä¸€ä¸ªå¸¸æ•°å› å­ã€‚

åˆ©ç”¨O-è®°å·ï¼Œé€šå¸¸å¯ä»¥é€šè¿‡æ£€æŸ¥ç®—æ³•çš„æ•´ä½“ç»“æ„æ¥ç®€å•æè¿°ç®—æ³•çš„è¿è¡Œæ—¶é—´ã€‚ä¾‹å¦‚ï¼Œæ’å…¥æ’åºç®—æ³•ä¸­çš„åŒé‡åµŒå¥—å¾ªç¯ç»“æ„ç«‹å³ç»™å‡ºäº†æœ€åæƒ…å†µä¸‹è¿è¡Œæ—¶é—´ä¸º$O(n^2)$çš„ä¸Šç•Œã€‚

ç”±äºO-è®°å·æè¿°çš„æ˜¯ä¸Šç•Œï¼Œå½“ç”¨å®ƒæ¥çº¦æŸç®—æ³•çš„æœ€åæƒ…å†µè¿è¡Œæ—¶é—´æ—¶ï¼Œå°±å¾—åˆ°äº†è¯¥ç®—æ³•åœ¨ä»»ä½•è¾“å…¥ä¸Šçš„è¿è¡Œæ—¶é—´çš„ä¸Šé™ã€‚è¿™æ„å‘³ç€ï¼Œåœ¨æœ€åæƒ…å†µä¸‹ï¼Œç®—æ³•ä¸ä¼šæ¯”è¿™ä¸ªä¸Šç•Œæ›´æ…¢ï¼Œæ— è®ºè¾“å…¥æ˜¯ä»€ä¹ˆã€‚

> We use O-notation to give an upper bound on a function, to within a constant factor.
>
> Using O-notation, we can often describe the running time of an algorithm merely by inspecting the algorithmâ€™s overall structure. For example, the doubly nested loop structure of the insertion sort algorithm immediately yields an $O(n^2)$ upper bound on the worst-case running time.
>
> Since O-notation describes an upper bound, when we use it to bound the worstcase running time of an algorithm, we have a bound on the running time of the algorithm on every input.



**ä¸¾ä¾‹ï¼š**$2n + 10$ is $O(n)$

$2n + 10 \le cn$

$(c - 2) n \ge 10$

$n \ge 10/(c - 2)$

Pick $c = 3 \space and \space n_0 = 10$



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240301083003567.png" alt="image-20240301083003567" style="zoom:50%;" />

**ä¸¾ä¾‹ï¼š**the function $n^2$ is not O(n)

$n^2 \le cn$

$n \le c$, the inequality cannot be satisfied since $c$â€‹ must be a constant 

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240301083805826.png" alt="image-20240301083805826" style="zoom:50%;" />

**More Big-Oh Examples**

$7n - 2$â€‹ is O(n)

need $c \gt 0$ and $n_0 \ge 1$ such that $7n - 2 \le cn$ for $n \ge n_0$â€‹



$3n^3 + 20n^2 + 5$ is $O(n^3)$

need $c \gt 0$ and $n_0 \ge 1$ such that $3n^3 + 20n^2 + 5 \le cn^3$ for $n \ge n_0$

This is true for $c = 4$ and $n_0 = 21$



$3logn + 5$ is $O(logn)$

need $c \gt 0$ and $n_0 \gt 1$ such that $3logn + 5 \le clogn$ for $n \ge n_0$

this is true for $c=8$ and $n_0 = 2$



<mark>å¤§Oè®°å·ç»™å‡ºäº†å‡½æ•°å¢é•¿ç‡çš„ä¸Šç•Œã€‚é™ˆè¿°`f(n) æ˜¯ O(g(n))`æ„å‘³ç€`f(n)`çš„å¢é•¿ç‡ä¸è¶…è¿‡`g(n)`çš„å¢é•¿ç‡ã€‚</mark>

å¯ä»¥ä½¿ç”¨å¤§Oè®°å·æ ¹æ®å®ƒä»¬çš„å¢é•¿ç‡æ¥å¯¹å‡½æ•°è¿›è¡Œæ’åºã€‚

æ¢å¥è¯è¯´ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°`f(n)`æ˜¯O(g(n))ï¼Œé‚£ä¹ˆå¯¹äºè¶³å¤Ÿå¤§çš„è¾“å…¥nï¼Œ`f(n)`çš„å€¼ä¸ä¼šè¶…è¿‡`g(n)`çš„æŸä¸ªå¸¸æ•°å€ã€‚è¿™æä¾›äº†ä¸€ç§æ–¹å¼æ¥æè¿°å’Œæ¯”è¾ƒä¸åŒç®—æ³•éšç€è¾“å…¥è§„æ¨¡å¢åŠ è€Œè¡¨ç°å‡ºçš„æ•ˆç‡å·®å¼‚ï¼Œé€šè¿‡å°†ç®—æ³•çš„è¿è¡Œæ—¶é—´æˆ–ç©ºé—´éœ€æ±‚çš„å¢é•¿ç‡ä¸ä¸€äº›åŸºå‡†å‡½æ•°ï¼ˆå¦‚çº¿æ€§ã€å¹³æ–¹ã€ç«‹æ–¹ã€æŒ‡æ•°ç­‰ï¼‰è¿›è¡Œå¯¹æ¯”ã€‚åœ¨ç®—æ³•åˆ†æä¸­ï¼Œç»å¸¸ä½¿ç”¨å¤§Oè®°å·æ¥ç®€åŒ–è¡¨è¾¾ï¼Œå¹¶ä¸“æ³¨äºç®—æ³•æ€§èƒ½çš„å…³é”®è¶‹åŠ¿ï¼Œå¿½ç•¥æ‰é‚£äº›å¯¹äºå¤§è§„æ¨¡è¾“å…¥å½±å“è¾ƒå°çš„ç»†èŠ‚ã€‚

> The big-Oh notation gives an upper bound on the growth rate of a function. The statement `f(n) is O(g(n))` means that the growth rate of `f(n)` is no more than the growth rate of `g(n)`. â€¢We can use the big-Oh notation to rank functions according to their growth rate.



<mark>**Big-Oh Rules**</mark>

If is `f(n)` a polynomial of degree `d`, then `f(n)` is $O(n^d)$, i.e.,

â€‹	Drop lower-order terms å¿½ç•¥ä½é˜¶é¡¹

â€‹	Drop constant factors å¿½ç•¥å¸¸æ•°å› å­

Use the smallest possible class of functions ä½¿ç”¨å°½å¯èƒ½å°çš„å‡½æ•°ç±»åˆ«

â€‹	Say $2n$ is $O(n)$ instead of $2n$ is $O(n^2)$

Use the simplest expression of the class ä½¿ç”¨è¯¥ç±»åˆ«ä¸­æœ€ç®€å•çš„è¡¨è¾¾æ–¹å¼

â€‹	Say $3n + 5$ is $O(n)$ instead of $3n + 5$ is $O(3n)$



**Asymptotic Algorithm Analysis** **æ¸è¿‘ç®—æ³•åˆ†æ**

ç®—æ³•çš„æ¸è¿‘åˆ†æç¡®å®šäº†ä»¥å¤§Oè®°å·è¡¨ç¤ºçš„è¿è¡Œæ—¶é—´ã€‚

ä¸ºäº†æ‰§è¡Œæ¸è¿‘åˆ†æï¼Œæ‰¾åˆ°ä½œä¸ºè¾“å…¥è§„æ¨¡å‡½æ•°çš„æœ€åæƒ…å†µä¸‹çš„åŸå§‹æ“ä½œæ•°é‡ï¼Œå¹¶ç”¨å¤§Oè®°å·æ¥è¡¨ç¤ºè¿™ä¸ªå‡½æ•°ã€‚

ä¾‹å­ï¼š

å¯ä»¥è¯´ç®—æ³•find_maxâ€œåœ¨O(n)æ—¶é—´å†…è¿è¡Œâ€

ç”±äºæœ€ç»ˆæ— è®ºå¦‚ä½•éƒ½ä¼šå¿½ç•¥å¸¸æ•°å› å­å’Œä½é˜¶é¡¹ï¼Œæ‰€ä»¥åœ¨è®¡ç®—åŸå§‹æ“ä½œæ—¶å¯ä»¥ä¸è€ƒè™‘å®ƒä»¬ã€‚

> è¿™æ„å‘³ç€ï¼Œåœ¨è¿›è¡Œç®—æ³•åˆ†ææ—¶ï¼Œä¸»è¦å…³æ³¨çš„æ˜¯éšç€è¾“å…¥å¤§å°å¢åŠ ï¼Œç®—æ³•æ€§èƒ½å¦‚ä½•å˜åŒ–çš„è¶‹åŠ¿ã€‚é€šè¿‡å¿½ç•¥é‚£äº›å¯¹äºå¤§è¾“å…¥è§„æ¨¡å½±å“è¾ƒå°çš„ç»†èŠ‚ï¼ˆå¦‚ä½é˜¶é¡¹å’Œå¸¸æ•°å› å­ï¼‰ï¼Œå¯ä»¥ç®€åŒ–åˆ†æï¼Œå¹¶ä¸“æ³¨äºç†è§£ç®—æ³•åœ¨å¤„ç†å¤§è§„æ¨¡æ•°æ®æ—¶çš„è¡Œä¸ºã€‚è¿™ç§åˆ†ææ–¹æ³•å…è®¸æˆ‘ä»¬æ¯”è¾ƒä¸åŒç®—æ³•ä¹‹é—´çš„æ•ˆç‡ï¼Œè€Œä¸éœ€è¦æ·±å…¥åˆ°å…·ä½“çš„å®ç°ç»†èŠ‚ä¸­å»ã€‚
>
> The asymptotic analysis of an algorithm determines the running time in big-Oh notation.
>
> To perform the asymptotic analysis, find the worst-case number of primitive operations executed as a function of the input size, express this function with big-Oh notation
>
> Example:
>
> say that algorithm **find_max** â€œruns in **O**(**n**) timeâ€
>
> Since constant factors and lower-order terms are eventually dropped anyhow, disregard them when counting primitive operations



https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt

![image-20240301091407727](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240301091407727.png)



## 2.2 Sorting Algorithm

**Sorting Algorithm** is used to rearrange a given array or list elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of element in the respective data structure.

There are a lot of different types of sorting algorithms. Some widely used algorithms are:

- [Bubble Sort](http://www.geeksforgeeks.org/bubble-sort/)
- [Selection Sort](http://www.geeksforgeeks.org/selection-sort/)
- [Insertion Sort](http://www.geeksforgeeks.org/insertion-sort/)
- [Quick Sort](http://www.geeksforgeeks.org/quick-sort/)
- [Merge Sort](http://www.geeksforgeeks.org/merge-sort/)
- [ShellSort](https://www.geeksforgeeks.org/shellsort/)

There are several other sorting algorithms also and they are beneficial in different cases. You can learn about them and more in our dedicated article on [Sorting algorithms](https://www.geeksforgeeks.org/sorting-algorithms/).



> https://github.com/GMyhf/2024spring-cs201/blob/main/code/ten_sort_algorithms.md
>
> åŒ…æ‹¬ï¼šå†’æ³¡æ’åºï¼ˆBubble Sortï¼‰ï¼Œæ’å…¥æ’åºï¼ˆInsertion Sortï¼‰ï¼Œé€‰æ‹©æ’åºï¼ˆSelection Sortï¼‰ï¼Œå¸Œå°”æ’åºï¼ˆShell Sortï¼‰ï¼Œå½’å¹¶æ’åºï¼ˆMerge Sortï¼‰ï¼Œå¿«é€Ÿæ’åºï¼ˆQuick Sortï¼‰ï¼Œå †æ’åºï¼ˆHeap Sortï¼‰ï¼Œè®¡æ•°æ’åºï¼ˆCounting Sortï¼‰ï¼Œæ¡¶æ’åºï¼ˆBucket Sortï¼‰ï¼ŒåŸºæ•°æ’åºï¼ˆRadix Sortï¼‰



### 1 Bubble Sort

Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.

Algorithm

> In Bubble Sort algorithm, 
>
> - traverse from left and compare adjacent elements and the higher one is placed at right side. 
> - In this way, the largest element is moved to the rightmost end at first. 
> - This process is then continued to find the second largest and place it and so on until the data is sorted.



```python
# Optimized Python program for implementation of Bubble Sort
def bubbleSort(arr):
    n = len(arr)

    # Traverse through all array elements
    for i in range(n):
        swapped = False

        # Last i elements are already in place
        for j in range(0, n - i - 1):

            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if (swapped == False):
            break


# Driver code to test above
if __name__ == "__main__":
    arr = [64, 34, 25, 12, 22, 11, 90]

    bubbleSort(arr)
    print(' '.join(map(str, arr)))

```



**Complexity Analysis of Bubble Sort:**

Time Complexity: $O(N^2)$
Auxiliary Space: $O(1)$

**Advantages of Bubble Sort:**

- Bubble sort is easy to understand and implement.
- It <mark>does not require any additional memory space</mark>.
- It is a <mark>stable sorting</mark> algorithm, meaning that elements with the same key value maintain their relative order in the sorted output.

**Disadvantages of Bubble Sort:**

- Bubble sort has a time complexity of $O(N^2)$ which makes it very slow for large data sets.
- Bubble sort is a comparison-based sorting algorithm, which means that it requires a comparison operator to determine the relative order of elements in the input data set. It can limit the efficiency of the algorithm in certain cases.



> **Some FAQs related to Bubble Sort:**
>
> **Q1. What is the Boundary Case for Bubble sort?**
>
> Bubble sort takes minimum time (Order of n) when elements are already sorted. Hence it is best to check if the array is already sorted or not beforehand, to avoid $O(N^2)$ time complexity.
>
> **Q2. Does sorting happen in place in Bubble sort?**
>
> Yes, Bubble sort performs the swapping of adjacent pairs without the use of any major data structure. Hence Bubble sort algorithm is an <mark>in-place</mark> algorithm.
>
> **Q3. Is the Bubble sort algorithm stable?**
>
> Yes, the bubble sort algorithm is <mark>stable</mark>.
>
> **Q4. Where is the Bubble sort algorithm used?**
>
> Due to its simplicity, bubble sort is often used to introduce the concept of a sorting algorithm. 
>
> 
>
> **Q:** Suppose you have the following list of numbers to sort: [19, 1, 9, 7, 3, 10, 13, 15, 8, 12] which list represents the partially sorted list after three complete passes of bubble sort?? ï¼ˆ B ï¼‰
>
> Aï¼š [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]	Bï¼š **[1, 3, 7, 9, 10, 8, 12, 13, 15, 19]**	
>
> Cï¼š [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]	Dï¼š[1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
>



### 2 Selection Sort

> **Selection sort** is a simple and efficient sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list. 

The algorithm repeatedly <mark>selects the smallest (or largest)</mark> element from the unsorted portion of the list and swaps it with the first element of the unsorted part. This process is repeated for the remaining unsorted portion until the entire list is sorted. 

> 
>
> ```python
> A = [64, 25, 12, 22, 11]
> 
> # Traverse through all array elements
> for i in range(len(A)):
> 
>     # Find the minimum element in remaining
>     # unsorted array
>     min_idx = i
>     for j in range(i + 1, len(A)):
>         if A[min_idx] > A[j]:
>             min_idx = j
> 
>         # Swap the found minimum element with
>     # the first element
>     A[i], A[min_idx] = A[min_idx], A[i]
> 
> # Driver code to test above
> print(' '.join(map(str, A)))
> 
> # Output: 11 12 22 25 64 
> ```
>



The **selection sort** <mark>improves on the bubble sort by making only one exchange</mark> for every pass through the list. In order to do this, a selection sort looks for the largest value as it makes a pass and, after completing the pass, places it in the proper location. As with a bubble sort, after the first pass, the largest item is in the correct place. After the second pass, the next largest is in place. This process continues and requires nâˆ’1 passes to sort *n* items, since the final item must be in place after the (nâˆ’1) st pass.

Figure 3 shows the entire sorting process. On each pass, the largest remaining item is selected and then placed in its proper location. The first pass places 93, the second pass places 77, the third places 55, and so on. 

![../_images/selectionsortnew.png](https://raw.githubusercontent.com/GMyhf/img/main/img/selectionsortnew.png)

Figure 3: `selectionSort`



```python
def selectionSort(alist):
    for fillslot in range(len(alist)-1, 0, -1):
        positionOfMax = 0
        for location in range(1, fillslot+1):
            if alist[location] > alist[positionOfMax]:
                positionOfMax = location

        if positionOfMax != fillslot:
            alist[fillslot], alist[positionOfMax] = alist[positionOfMax], alist[fillslot]

alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]
selectionSort(alist)
print(alist)

# [17, 20, 26, 31, 44, 54, 55, 77, 93]
```



You may see that the selection sort makes the same number of comparisons as the bubble sort and is therefore also $(O^2)$. However, <mark>due to the reduction in the number of exchanges, the selection sort typically executes faster in benchmark studies</mark>. In fact, for our list, the bubble sort makes 20 exchanges, while the selection sort makes only 8.



**Complexity Analysis of Selection Sort**

**Time Complexity:** The time complexity of Selection Sort is $O(N^2) $as there are two nested loops:

- One loop to select an element of Array one by one = $O(N)$
- Another loop to compare that element with every other Array element = $O(N)$
- Therefore overall complexity = O(N) * O(N) = O(N*N) = $O(N^2)$

**Auxiliary Space:** $O(1)$ as the only extra memory used is for temporary variables while swapping two values in Array. The selection sort never makes more than $O(N)$ swaps and can be useful when memory writing is costly. 



**Advantages of Selection Sort Algorithm**

- Simple and easy to understand.
- Works well with small datasets.



**Disadvantages of the Selection Sort Algorithm**

- Selection sort has a time complexity of $O(n^2)$ in the worst and average case.
- Does not work well on large datasets.
- Does not preserve the relative order of items with equal keys which means it is not stable.



> **Frequently Asked Questions on Selection Sort**
>
> **Q1. Is Selection Sort Algorithm stable?**
>
> The default implementation of the Selection Sort Algorithm is <mark>not stable</mark>. However, it can be made stable. Please see the [stable Selection Sort](https://www.geeksforgeeks.org/stable-selection-sort/) for details.
>
> **Q2. Is Selection Sort Algorithm in-place?**
>
> Yes, Selection Sort Algorithm is an <mark>in-place</mark> algorithm, as it does not require extra space.
>
> 
>
> **Q:** Suppose you have the following list of numbers to sort: [11, 7, 12, 14, 19, 1, 6, 18, 8, 20] which list represents the partially sorted list after three complete passes of selection sort? (D)
>
> A. [7, 11, 12, 1, 6, 14, 8, 18, 19, 20]
> B. [7, 11, 12, 14, 19, 1, 6, 18, 8, 20]
> C. [11, 7, 12, 14, 1, 6, 8, 18, 19, 20]
> D. **[11, 7, 12, 14, 8, 1, 6, 18, 19, 20]**



### 3 Quick Sort

> quickSort is a sorting algorithm based on the[ Divide and Conquer algorithm](https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/) that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.

How does QuickSort work?

> The key process in quickSort is a partition(). The target of partitions is to place the pivot (any element can be chosen to be a pivot) at its correct position in the sorted array and put all smaller elements to the left of the pivot, and all greater elements to the right of the pivot.
>
> Partition is done <mark>recursively</mark> on each side of the pivot after the pivot is placed in its correct position and this finally sorts the array.



> https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm-data-structure-and-algorithm-tutorials/
>
> <mark>**Divide And Conquer** </mark>
> This technique can be divided into the following three parts:
>
> 1. **Divide:** This involves dividing the problem into smaller sub-problems.
> 2. **Conquer:** Solve sub-problems by calling recursively until solved.
> 3. **Combine:** Combine the sub-problems to get the final solution of the whole problem.
>
>
> The following are some standard algorithms that follow Divide and Conquer algorithm. 
>
> 1. [**Quicksort**](https://www.geeksforgeeks.org/quick-sort/) is a sorting algorithm. The algorithm picks a pivot element and rearranges the array elements so that all elements smaller than the picked pivot element move to the left side of the pivot, and all greater elements move to the right side. Finally, the algorithm recursively sorts the subarrays on the left and right of the pivot element.
>
> 2. [**Merge Sort**](https://www.geeksforgeeks.org/merge-sort/) is also a sorting algorithm. The algorithm divides the array into two halves, recursively sorts them, and finally merges the two sorted halves.
>
> 
>
> What does not qualifies as Divide and Conquer:
> Binary Search is a searching algorithm. In each step, the algorithm compares the input element x with the value of the middle element in the array. If the values match, return the index of the middle. Otherwise, if x is less than the middle element, then the algorithm recurs for the left side of the middle element, else recurs for the right side of the middle element. Contrary to popular belief, this is not an example of Divide and Conquer because there is only one sub-problem in each step (<mark>Divide and conquer requires that there must be two or more sub-problems</mark>) and hence this is a case of <mark>Decrease and Conquer</mark>.



åœ¨partitionå‡½æ•°ä¸­ä¸¤ä¸ªæŒ‡é’ˆ `i` å’Œ `j` çš„æ–¹å¼å®ç°ã€‚å¿«æ’ä¸­çš„partitionå¯ä»¥ç”¨åŒæŒ‡é’ˆæˆ–è€…å•æŒ‡é’ˆå®ç°ï¼Œå‰è€…æ›´å®¹æ˜“ç†è§£ï¼Œä¹Ÿæ˜¯æœºè€ƒä¸­å–œæ¬¢å‡ºçš„é¢˜ç›®ç±»å‹ã€‚

```python
def quicksort(arr, left, right):
    if left < right:
        partition_pos = partition(arr, left, right)
        quicksort(arr, left, partition_pos - 1)
        quicksort(arr, partition_pos + 1, right)


def partition(arr, left, right):
    i = left
    j = right - 1
    pivot = arr[right]
    while i <= j:
        while i <= right and arr[i] < pivot:
            i += 1
        while j >= left and arr[j] >= pivot:
            j -= 1
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]
    if arr[i] > pivot:
        arr[i], arr[right] = arr[right], arr[i]
    return i


arr = [22, 11, 88, 66, 55, 77, 33, 44]
quicksort(arr, 0, len(arr) - 1)
print(arr)

# [11, 22, 33, 44, 55, 66, 77, 88]
```



è¦åˆ†æ`quickSort`å‡½æ•°ï¼Œæ³¨æ„å¯¹äºé•¿åº¦ä¸º*n*çš„åˆ—è¡¨ï¼Œå¦‚æœåˆ†åŒºæ€»æ˜¯å‘ç”Ÿåœ¨åˆ—è¡¨ä¸­é—´ï¼Œåˆ™å°†å†æ¬¡æœ‰$logn$æ¬¡åˆ’åˆ†ã€‚ä¸ºäº†æ‰¾åˆ°åˆ†å‰²ç‚¹ï¼Œéœ€è¦æ£€æŸ¥æ¯ä¸ª*n*é¡¹ä¸æ¢è½´å€¼ï¼ˆpivot valueï¼‰ã€‚ç»“æœæ˜¯$nlogn$ã€‚æ­¤å¤–ï¼Œä¸éœ€è¦é¢å¤–çš„å†…å­˜ï¼Œä¸åƒå½’å¹¶æ’åºè¿‡ç¨‹é‚£æ ·ã€‚

ä¸å¹¸çš„æ˜¯ï¼Œåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œåˆ†å‰²ç‚¹å¯èƒ½ä¸åœ¨ä¸­é—´ï¼Œå¹¶ä¸”å¯èƒ½ä¼šæåº¦åå‘å·¦ä¾§æˆ–å³ä¾§ï¼Œå¯¼è‡´éå¸¸ä¸å‡åŒ€çš„åˆ’åˆ†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹*n*é¡¹çš„åˆ—è¡¨è¿›è¡Œæ’åºä¼šè¢«åˆ†ä¸ºå¯¹0é¡¹å’Œnâˆ’1é¡¹çš„ä¸¤ä¸ªåˆ—è¡¨è¿›è¡Œæ’åºã€‚ç„¶åï¼Œå¯¹nâˆ’1é¡¹çš„åˆ—è¡¨æ’åºåˆè¢«åˆ†ä¸ºå¤§å°ä¸º0å’Œå¤§å°ä¸ºnâˆ’2çš„åˆ—è¡¨ï¼Œä¾æ­¤ç±»æ¨ã€‚ç»“æœæ˜¯ä¸€ä¸ª$O(n^2)$çš„æ’åºï¼Œä¼´éšç€é€’å½’æ‰€éœ€çš„æ‰€æœ‰å¼€é”€ã€‚

æˆ‘ä»¬ä¹‹å‰æåˆ°è¿‡<mark>æœ‰å¤šç§æ–¹å¼æ¥é€‰æ‹©æ¢è½´å€¼</mark>ã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•é€šè¿‡ä¸€ç§ç§°ä¸ºâ€œä¸‰æ•°å–ä¸­â€ï¼ˆmedian of threeï¼‰çš„æŠ€æœ¯æ¥ç¼“è§£å› åˆ’åˆ†ä¸å‡å¸¦æ¥çš„é—®é¢˜ã€‚ä¸ºäº†é€‰æ‹©æ¢è½´å€¼ï¼Œæˆ‘ä»¬ä¼šè€ƒè™‘åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªã€ä¸­é—´çš„å’Œæœ€åä¸€ä¸ªå…ƒç´ ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œå®ƒä»¬æ˜¯54ã€77å’Œ20ã€‚ç°åœ¨é€‰å–ä¸­ä½æ•°å€¼ï¼Œåœ¨æˆ‘ä»¬çš„æƒ…å†µä¸­æ˜¯54ï¼Œå¹¶ç”¨å®ƒä½œä¸ºæ¢è½´å€¼ï¼ˆå½“ç„¶ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬æœ€åˆä½¿ç”¨çš„æ¢è½´å€¼ï¼‰ã€‚è¿™ä¸ªæƒ³æ³•æ˜¯åœ¨åˆ—è¡¨ä¸­çš„ç¬¬ä¸€é¡¹ä¸å±äºåˆ—è¡¨ä¸­é—´ä½ç½®æ—¶ï¼Œä½¿ç”¨ä¸‰æ•°å–ä¸­èƒ½é€‰æ‹©ä¸€ä¸ªæ›´å¥½çš„â€œä¸­é—´â€å€¼ã€‚å½“åŸå§‹åˆ—è¡¨åˆå§‹æ—¶å·²éƒ¨åˆ†æ’åºçš„æƒ…å†µä¸‹ï¼Œè¿™ç§æ–¹æ³•å°†ç‰¹åˆ«æœ‰ç”¨ã€‚

> To analyze the `quickSort` function, note that for a list of length *n*, if the partition always occurs in the middle of the list, there will again be $logâ¡n$ divisions. In order to find the split point, each of the *n* items needs to be checked against the pivot value. The result is $nlogn$. In addition, there is no need for additional memory as in the merge sort process.
>
> Unfortunately, in the worst case, the split points may not be in the middle and can be very skewed to the left or the right, leaving a very uneven division. In this case, sorting a list of *n* items divides into sorting a list of 0 items and a list of nâˆ’1 items. Then sorting a list of nâˆ’1 divides into a list of size 0 and a list of size nâˆ’2, and so on. The result is an $O(n^2)$ sort with all of the overhead that recursion requires.
>
> We mentioned earlier that <mark>there are different ways to choose the pivot value</mark>. In particular, we can attempt to alleviate some of the potential for an uneven division by using a technique called **median of three**. To choose the pivot value, we will consider the first, the middle, and the last element in the list. In our example, those are 54, 77, and 20. Now pick the median value, in our case 54, and use it for the pivot value (of course, that was the pivot value we used originally). The idea is that in the case where the first item in the list does not belong toward the middle of the list, the median of three will choose a better â€œmiddleâ€ value. This will be particularly useful when the original list is somewhat sorted to begin with.
>



**Complexity Analysis of Quick Sort:**

Time Complexity:

- Best Case: $\Omega(N log N)$
  The best-case scenario for quicksort occur when the pivot chosen at the each step divides the array into roughly equal halves.
  In this case, the algorithm will make balanced partitions, leading to efficient Sorting.
- <mark>Average Case</mark>: $\Theta ( N log N)$
  Quicksortâ€™s average-case performance is usually very good in practice, making it one of the fastest sorting Algorithm.
- Worst Case: $O(N^2)$
  The worst-case Scenario for Quicksort occur when the pivot at each step consistently results in highly unbalanced partitions. When the array is already sorted and the pivot is always chosen as the smallest or largest element. To mitigate the worst-case Scenario, various techniques are used such as choosing a good pivot (e.g., median of three) and using Randomized algorithm (Randomized Quicksort ) to shuffle the element before sorting.

Auxiliary Space: $O(1)$, if we donâ€™t consider the recursive stack space. If we consider the recursive stack space then, in the worst case quicksort could make $O(N)$.



**Advantages of Quick Sort:**

- It is a divide-and-conquer algorithm that makes it easier to solve problems.
- It is efficient on large data sets.
- It has a low overhead, as it only requires a small amount of memory to function.

**Disadvantages of Quick Sort:**

- It has a worst-case time complexity of $O(N^2)$, which occurs when the pivot is chosen poorly.
- It is not a good choice for small data sets.
- It is <mark>not a stable</mark> sort, meaning that if two elements have the same key, their relative order will not be preserved in the sorted output in case of quick sort, because here we are swapping elements according to the pivotâ€™s position (without considering their original positions).



**Q.** Choose the leftmost element as pivot, given the following list of numbers [14, 17, 13, 15, 19, 10, 3, 16, 9, 12] which answer shows the contents of the list after the second partitioning according to the quicksort algorithm? (D)

A. [9, 3, 10, 13, 12]
B. [9, 3, 10, 13, 12, 14]
C. [9, 3, 10, 13, 12, 14, 17, 16, 15, 19]
**D. [9, 3, 10, 13, 12, 14, 19, 16, 15, 17]**

The first partitioning works on the entire list, and <mark>the second partitioning works on the left partition not the right</mark>. It's important to remember that quicksort works on the entire list and sorts it in place.



> **Q:** Given the following list of numbers [1, 20, 11, 5, 2, 9, 16, 14, 13, 19] what would be the first pivot value using the median of 3 method? (B)
>
> A. 1
> **B. 9**
> C. 16
> D. 19
>
>  although 16 would be the median of 1, 16, 19 the middle is at len(list) // 2.
>



**Q:** Which of the following sort algorithms are guaranteed to be O(n log n) even in the worst case? (C)

A. Shell Sort
B. Quick Sort
**C. Merge Sort**
D. Insertion Sort

<mark>Merge Sort is the only guaranteed O(n log n) even in the worst case</mark>. The cost is that merge sort uses more memory.



### 4 Merge Sort

> Merge sort is defined as a sorting algorithm that works by dividing an array into smaller subarrays, sorting each subarray, and then merging the sorted subarrays back together to form the final sorted array.

In simple terms, we can say that the process of merge sort is to divide the array into two halves, sort each half, and then merge the sorted halves back together. This process is repeated until the entire array is sorted.

How does Merge Sort work?

> Merge sort is a recursive algorithm that continuously splits the array in half until it cannot be further divided i.e., the array has only one element left (an array with one element is always sorted). Then the sorted subarrays are merged into one sorted array.



```python
def mergeSort(arr):
	if len(arr) > 1:
		mid = len(arr)//2

		L = arr[:mid]	# Dividing the array elements
		R = arr[mid:] # Into 2 halves

		mergeSort(L) # Sorting the first half
		mergeSort(R) # Sorting the second half

		i = j = k = 0
		# Copy data to temp arrays L[] and R[]
		while i < len(L) and j < len(R):
			if L[i] <= R[j]:
				arr[k] = L[i]
				i += 1
			else:
				arr[k] = R[j]
				j += 1
			k += 1

		# Checking if any element was left
		while i < len(L):
			arr[k] = L[i]
			i += 1
			k += 1

		while j < len(R):
			arr[k] = R[j]
			j += 1
			k += 1


if __name__ == '__main__':
	arr = [12, 11, 13, 5, 6, 7]
	mergeSort(arr)
	print(' '.join(map(str, arr)))
# Output: 5 6 7 11 12 13
```



**Complexity Analysis of Merge Sort**

Time Complexity: $O(N logN)$,  Merge Sort is a <mark>recursive</mark> algorithm and time complexity can be expressed as following recurrence relation. 

> T(n) = 2T(n/2) + Î¸(n)

The above recurrence can be solved either using the Recurrence Tree method or the Master method. It falls in case II of the Master Method and the solution of the recurrence is Î¸(Nlog(N)). The time complexity of Merge Sort is Î¸(Nlog(N)) in all 3 cases (worst, average, and best) as merge sort always divides the array into two halves and takes linear time to merge two halves.

Auxiliary Space: O(N), In merge sort all elements are copied into an auxiliary array. So <mark>N auxiliary space is required for merge sort</mark>.

**Applications of Merge Sort:**

- Sorting large datasets: Merge sort is particularly well-suited for sorting large datasets due to its guaranteed worst-case time complexity of O(n log n).
- <mark>External sorting</mark>: Merge sort is commonly used in external sorting, where the data to be sorted is too large to fit into memory.
- Custom sorting: Merge sort can be adapted to handle different input distributions, such as partially sorted, nearly sorted, or completely unsorted data.
- [Inversion Count Problem](https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/): <mark>Inversion Count</mark> for an array indicates â€“ how far (or close) the array is from being sorted. If the array is already sorted, then the inversion count is 0, but if the array is sorted in reverse order, the inversion count is the maximum. 

**Advantages of Merge Sort:**

- Stability: <mark>Merge sort is a stable sorting</mark> algorithm, which means it <mark>maintains the relative order of equal elements in the input array</mark>.
- Guaranteed worst-case performance: Merge sort has a worst-case time complexity of O(N logN), which means it performs well even on large datasets.
- Parallelizable: Merge sort is a naturally parallelizable algorithm, which means it can be easily parallelized to take advantage of multiple processors or threads.

**Drawbacks of Merge Sort:**

- Space complexity: Merge sort requires additional memory to store the merged sub-arrays during the sorting process. 
- Not in-place: Merge sort is not an in-place sorting algorithm, which means it requires additional memory to store the sorted data. This can be a disadvantage in applications where memory usage is a concern.
- Not always optimal for small datasets: For small datasets, Merge sort has a higher time complexity than some other sorting algorithms, such as insertion sort. This can result in slower performance for very small datasets.



**Q:** ç»™å®šæ’åºåˆ—è¡¨ [21,1,26,45,29,28,2,9,16,49,39,27,43,34,46,40]ï¼Œåœ¨å½’å¹¶æ’åºçš„ç¬¬ 3 æ¬¡é€’å½’è°ƒç”¨æ—¶ï¼Œæ’åºçš„æ˜¯å“ªä¸ªå­è¡¨? ï¼ˆ B ï¼‰

Aï¼š [16, 49,39,27,43,34,46,40]	Bï¼š **[21,1]**	Cï¼š [21,1,26,45]	Dï¼š[21]

Remember <mark>mergesort doesn't work on the right half of the list until the left half is completely sorted.</mark>



**Q:** æ’åºæ•°æ®åŒä¸Šï¼Œå½’å¹¶æ’åºä¸­ï¼Œå“ªä¸¤ä¸ªå­è¡¨æ˜¯æœ€å…ˆå½’å¹¶çš„?ï¼ˆ C ï¼‰

Aï¼š [21,1] and [26,45]	Bï¼š[1, 2, 9,21,26,28,29,45] and [16,27,34,39,40,43, 46,49] 	

Cï¼š **[21] and [1]**	Dï¼š[9] and [16]

The lists [21] and [1] are the first two base cases encountered by mergesort and will therefore be the first two lists merged.



### 5 Shell Sort

å¸Œå°”æ’åºä¸»è¦æ˜¯**æ’å…¥æ’åº**çš„ä¸€ç§å˜ä½“ã€‚åœ¨æ’å…¥æ’åºä¸­ï¼Œæˆ‘ä»¬åªèƒ½å°†å…ƒç´ å‘å‰ç§»åŠ¨ä¸€ä¸ªä½ç½®ã€‚å½“ä¸€ä¸ªå…ƒç´ éœ€è¦è¢«ç§»åŠ¨å¾ˆè¿œæ—¶ï¼Œä¼šæ¶‰åŠåˆ°å¾ˆå¤šæ¬¡ç§»åŠ¨ã€‚å¸Œå°”æ’åºçš„æ€æƒ³æ˜¯å…è®¸è¿œè·ç¦»çš„å…ƒç´ äº¤æ¢ã€‚åœ¨å¸Œå°”æ’åºä¸­ï¼Œæˆ‘ä»¬ä½¿æ•°ç»„å¯¹äºè¾ƒå¤§çš„hå€¼æˆä¸ºh-sortedã€‚æˆ‘ä»¬ä¸æ–­å‡å°‘ h çš„å€¼ç›´åˆ°å®ƒå˜ä¸º1ã€‚å¦‚æœä¸€ä¸ªæ•°ç»„çš„æ‰€æœ‰æ¯éš” hä¸ªå…ƒç´ çš„å­åˆ—è¡¨éƒ½æ˜¯æ’åºçš„ï¼Œåˆ™ç§°è¯¥æ•°ç»„ä¸º*h*æ’åºçš„ã€‚

> Shell sort is mainly a variation of **Insertion Sort**. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every hâ€™th element are sorted.

**Algorithm:**

Step 1 âˆ’ Start
Step 2 âˆ’ Initialize the value of gap size. Example: h
Step 3 âˆ’ Divide the list into smaller sub-part. Each must have equal intervals to h
Step 4 âˆ’ <mark>Sort these sub-lists using insertion sort</mark>
Step 5 â€“ Repeat this step 2 until the list is sorted.
Step 6 â€“ Print a sorted list.
Step 7 â€“ Stop.



```python
def shellSort(arr, n):
    # code here
    gap = n // 2

    while gap > 0:
        j = gap
        # Check the array in from left to right
        # Till the last possible index of j
        while j < n:
            i = j - gap  # This will keep help in maintain gap value

            while i >= 0:
                # If value on right side is already greater than left side value
                # We don't do swap else we swap
                if arr[i + gap] > arr[i]:
                    break
                else:
                    arr[i + gap], arr[i] = arr[i], arr[i + gap]

                i = i - gap  # To check left side also
            # If the element present is greater than current element
            j += 1
        gap = gap // 2


# driver to check the code
arr2 = [12, 34, 54, 2, 3]

shellSort(arr2, len(arr2))
print(' '.join(map(str, arr2)))

# Output: 2 3 12 34 54
```



**Time Complexity:** Time complexity of the above implementation of Shell sort is $O(n^2)$. In the above implementation, the gap is reduced by half in every iteration. There are many other ways to reduce gaps which leads to better time complexity. See [this ](http://en.wikipedia.org/wiki/Shellsort#Gap_sequences)for more details.

**Worst Case Complexity**
The worst-case complexity for shell sort is  $O(n^2)$



**Shell Sort Applications**

1. Replacement for insertion sort, where it takes a long time to complete a given task.
2. To call stack overhead we use shell sort.
3. when recursion exceeds a particular limit we use shell sort.
4. For medium to large-sized datasets.
5. In insertion sort to reduce the number of operations.



https://en.wikipedia.org/wiki/Shellsort

The running time of Shellsort is heavily dependent on the gap sequence it uses. For many practical variants, determining their time complexity remains an open problem.

Unlike **insertion sort**, <mark>Shellsort is not a **stable sort**</mark> since gapped insertions transport equal elements past one another and thus lose their original order. It is an **adaptive sorting algorithm** in that it executes faster when the input is partially sorted.

<mark>**Stable sort** algorithms sort equal elements in the same order that they appear in the input. </mark>



**Q:** Given the following list of numbers: [5, 16, 20, 12, 3, 8, 9, 17, 19, 7] Which answer illustrates the contents of the list after all swapping is complete for a gap size of 3? (A)

**A. [5, 3, 8, 7, 16, 19, 9, 17, 20, 12]**
B. [3, 7, 5, 8, 9, 12, 19, 16, 20, 17]
C. [3, 5, 7, 8, 9, 12, 16, 17, 19, 20]
D. [5, 16, 20, 3, 8, 12, 9, 17, 20, 7]

Each group of numbers represented by index positions 3 apart are sorted correctly.



### 6 Comparison sorts

> åœ¨æ’åºç®—æ³•ä¸­ï¼Œ<mark>ç¨³å®šæ€§æ˜¯æŒ‡ç›¸ç­‰å…ƒç´ çš„ç›¸å¯¹é¡ºåºæ˜¯å¦åœ¨æ’åºåä¿æŒä¸å˜</mark>ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœæ’åºç®—æ³•åœ¨æ’åºè¿‡ç¨‹ä¸­ä¿æŒäº†ç›¸ç­‰å…ƒç´ çš„ç›¸å¯¹é¡ºåºï¼Œåˆ™ç§°è¯¥ç®—æ³•æ˜¯ç¨³å®šçš„ï¼Œå¦åˆ™æ˜¯ä¸ç¨³å®šçš„ã€‚
>
> å¯¹äºåˆ¤æ–­ä¸€ä¸ªæ’åºç®—æ³•æ˜¯å¦ç¨³å®šï¼Œä¸€ç§å¸¸è§çš„æ–¹æ³•æ˜¯è§‚å¯Ÿäº¤æ¢æ“ä½œã€‚æŒ¨ç€äº¤æ¢ï¼ˆç›¸é‚»å…ƒç´ äº¤æ¢ï¼‰æ˜¯ç¨³å®šçš„ï¼Œè€Œéš”ç€äº¤æ¢ï¼ˆè·³è·ƒå¼äº¤æ¢ï¼‰å¯èƒ½ä¼šå¯¼è‡´ä¸ç¨³å®šæ€§ã€‚

Below is a table of [comparison sorts](https://en.wikipedia.org/wiki/Comparison_sort). A comparison sort cannot perform better than *O*(*n* log *n*) on average.

|      Name      |  Best   |  Average  |   Worst   | Memory | Stable |       Method        |                         Other notes                          |
| :------------: | :-----: | :-------: | :-------: | :----: | :----: | :-----------------: | :----------------------------------------------------------: |
|    Heapsort    | $nlogn$ |  $nlogn$  |  $nlogn$  |   1    |   No   |      Selection      |                                                              |
|   Merge sort   | $nlogn$ |  $nlogn$  |  $nlogn$  |  *n*   |  Yes   |       Merging       | Highly parallelizable (up to *O*(log *n*) using the Three Hungarian's Algorithm) |
|    Timsort     |   *n*   |  $nlogn$  |  $nlogn$  |  *n*   |  Yes   | Insertion & Merging | Makes *n-1* comparisons when the data is already sorted or reverse sorted. |
|   Quicksort    | $nlogn$ |  $nlogn$  |   $n^2$   | $logn$ |   No   |    Partitioning     | Quicksort is usually done in-place with *O*(log *n*) stack space. |
|   Shellsort    | $nlogn$ | $n^{4/3}$ | $n^{3/2}$ |   1    |   No   |      Insertion      |                       Small code size.                       |
| Insertion sort |   *n*   |   $n^2$   |   $n^2$   |   1    |  Yes   |      Insertion      | *O*(n + d), in the worst case over sequences that have *d* inversions. |
|  Bubble sort   |   *n*   |   $n^2$   |   $n^2$   |   1    |  Yes   |     Exchanging      |                       Tiny code size.                        |
| Selection sort |  $n^2$  |   $n^2$   |   $n^2$   |   1    |   No   |      Selection      | Stable with O(n) extra space, when using linked lists, or when made as a variant of Insertion Sort instead of swapping the two items. |



Highly tuned implementations use more sophisticated variants, such as [Timsort](https://en.wikipedia.org/wiki/Timsort) (merge sort, insertion sort, and additional logic), used in [Android](https://en.wikipedia.org/wiki/Android_(operating_system)), [Java](https://en.wikipedia.org/wiki/Java_(programming_language)), and [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), and [introsort](https://en.wikipedia.org/wiki/Introsort) (quicksort and heapsort), used (in variant forms) in some [C++ sort](https://en.wikipedia.org/wiki/Sort_(C%2B%2B)) implementations and in [.NET](https://en.wikipedia.org/wiki/.NET).



## ç¼–ç¨‹é¢˜ç›®

### 02299:Ultra-QuickSort

merge sort, http://cs101.openjudge.cn/practice/02299/



# 3 åŸºæœ¬æ•°æ®ç»“æ„

**What Are Linear Structures? çº¿æ€§ç»“æ„**

æˆ‘ä»¬å°†é€šè¿‡è€ƒè™‘å››ä¸ªç®€å•ä½†éå¸¸å¼ºå¤§çš„æ¦‚å¿µå¼€å§‹æ•°æ®ç»“æ„çš„ç ”ç©¶ã€‚æ ˆã€é˜Ÿåˆ—ã€åŒç«¯é˜Ÿåˆ—å’Œåˆ—è¡¨æ˜¯æ•°æ®é›†åˆçš„ä¾‹å­ï¼Œå®ƒä»¬çš„é¡¹ç›®æ ¹æ®æ·»åŠ æˆ–ç§»é™¤çš„æ–¹å¼æœ‰åºæ’åˆ—ã€‚ä¸€æ—¦ä¸€ä¸ªé¡¹ç›®è¢«æ·»åŠ ï¼Œå®ƒç›¸å¯¹äºä¹‹å‰å’Œä¹‹åæ·»åŠ çš„å…¶ä»–å…ƒç´ çš„ä½ç½®ä¿æŒä¸å˜ã€‚åƒè¿™æ ·çš„é›†åˆé€šå¸¸è¢«ç§°ä¸º**çº¿æ€§æ•°æ®ç»“æ„**ã€‚

> We will begin our study of data structures by considering four simple but very powerful concepts. Stacks, queues, deques, and lists are examples of data collections whose items are ordered depending on how they are added or removed. Once an item is added, it stays in that position relative to the other elements that came before and came after it. Collections such as these are often referred to as **linear data structures**.

çº¿æ€§ç»“æ„å¯ä»¥è¢«è®¤ä¸ºæœ‰ä¸¤ä¸ªç«¯ç‚¹ã€‚æœ‰æ—¶è¿™äº›ç«¯ç‚¹è¢«ç§°ä½œâ€œå·¦â€å’Œâ€œå³â€ï¼Œæˆ–è€…åœ¨æŸäº›æƒ…å†µä¸‹ç§°ä¸ºâ€œå‰â€å’Œâ€œåâ€ã€‚ä½ ä¹Ÿå¯ä»¥ç§°å®ƒä»¬ä¸ºâ€œé¡¶â€å’Œâ€œåº•â€ã€‚èµ‹äºˆè¿™äº›ç«¯ç‚¹çš„åç§°å¹¶ä¸é‡è¦ã€‚åŒºåˆ†ä¸€ç§çº¿æ€§ç»“æ„ä¸å¦ä¸€ç§çº¿æ€§ç»“æ„çš„æ˜¯é¡¹ç›®å¦‚ä½•è¢«æ·»åŠ å’Œç§»é™¤ï¼Œå°¤å…¶æ˜¯è¿™äº›æ·»åŠ å’Œç§»é™¤å‘ç”Ÿçš„ä½ç½®ã€‚ä¾‹å¦‚ï¼ŒæŸç§ç»“æ„å¯èƒ½åªå…è®¸åœ¨ä¸€ç«¯æ·»åŠ æ–°é¡¹ç›®ã€‚è€Œæœ‰äº›ç»“æ„å¯èƒ½å…è®¸ä»ä¸¤ç«¯ç§»é™¤é¡¹ç›®ã€‚

è¿™äº›å˜åŒ–äº§ç”Ÿäº†è®¡ç®—æœºç§‘å­¦ä¸­ä¸€äº›æœ€æœ‰ç”¨çš„æ•°æ®ç»“æ„ã€‚å®ƒä»¬å‡ºç°åœ¨è®¸å¤šç®—æ³•ä¸­ï¼Œå¹¶ä¸”å¯ç”¨äºè§£å†³å„ç§é‡è¦çš„é—®é¢˜ã€‚

> Linear structures can be thought of as having two ends. Sometimes these ends are referred to as the â€œleftâ€ and the â€œrightâ€ or in some cases the â€œfrontâ€ and the â€œrear.â€ You could also call them the â€œtopâ€ and the â€œbottom.â€ The names given to the ends are not significant. What distinguishes one linear structure from another is the way in which items are added and removed, in particular the location where these additions and removals occur. For example, a structure might allow new items to be added at only one end. Some structures might allow items to be removed from either end.
>
> These variations give rise to some of the most useful data structures in computer science. They appear in many algorithms and can be used to solve a variety of important problems.
>



**What is a Stack? æ ˆ**

**æ ˆ**ï¼ˆæœ‰æ—¶è¢«ç§°ä¸ºâ€œå‹å…¥æ ˆâ€ï¼‰æ˜¯ä¸€ç§æœ‰åºçš„é¡¹ç›®é›†åˆï¼Œå…¶ä¸­æ–°é¡¹ç›®çš„æ·»åŠ å’Œç°æœ‰é¡¹ç›®çš„ç§»é™¤æ€»æ˜¯åœ¨åŒä¸€ç«¯è¿›è¡Œã€‚è¿™ä¸€ç«¯é€šå¸¸è¢«ç§°ä¸ºâ€œé¡¶ç«¯â€ã€‚ä¸é¡¶ç«¯ç›¸å¯¹çš„å¦ä¸€ç«¯è¢«ç§°ä¸ºâ€œåŸºåº•â€ã€‚

æ ˆçš„åŸºåº•æ˜¯é‡è¦çš„ï¼Œå› ä¸ºå­˜å‚¨åœ¨æ ˆä¸­é è¿‘åŸºåº•çš„é¡¹ç›®ä»£è¡¨äº†åœ¨æ ˆä¸­æœ€ä¹…çš„é¡¹ç›®ã€‚æœ€è¿‘æ·»åŠ çš„é¡¹ç›®æ˜¯å‡†å¤‡é¦–å…ˆè¢«ç§»é™¤çš„é‚£ä¸ªã€‚è¿™ç§æ’åºåŸåˆ™æœ‰æ—¶è¢«ç§°ä¸º**LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰**ã€‚å®ƒæä¾›äº†ä¸€ç§åŸºäºé¡¹ç›®åœ¨é›†åˆä¸­åœç•™æ—¶é—´é•¿çŸ­çš„æ’åºã€‚è¾ƒæ–°çš„é¡¹ç›®æ¥è¿‘é¡¶ç«¯ï¼Œè€Œè¾ƒæ—§çš„é¡¹ç›®æ¥è¿‘åŸºåº•ã€‚

æ—¥å¸¸ç”Ÿæ´»ä¸­æœ‰è®¸å¤šæ ˆçš„ä¾‹å­ã€‚å‡ ä¹ä»»ä½•è‡ªåŠ©é¤å…éƒ½æœ‰ä¸€ä¸ªæ‰˜ç›˜æˆ–ç›˜å­çš„å †æ ˆï¼Œä½ å¯ä»¥ä»é¡¶éƒ¨å–èµ°ä¸€ä¸ªï¼Œä¸ºä¸‹ä¸€ä½æ’é˜Ÿçš„é¡¾å®¢éœ²å‡ºä¸€ä¸ªæ–°çš„æ‰˜ç›˜æˆ–ç›˜å­ã€‚

> A **stack** (sometimes called a â€œpush-down stackâ€) is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. This end is commonly referred to as the â€œtop.â€ The end opposite the top is known as the â€œbase.â€
>
> The base of the stack is significant since items stored in the stack that are closer to the base represent those that have been in the stack the longest. The most recently added item is the one that is in position to be removed first. This ordering principle is sometimes called **LIFO**, **last-in first-out**. It provides an ordering based on length of time in the collection. Newer items are near the top, while older items are near the base.
>
> Many examples of stacks occur in everyday situations. Almost any cafeteria has a stack of trays or plates where you take the one at the top, uncovering a new tray or plate for the next customer in line.
>



**What Is a Queue? é˜Ÿåˆ—**

é˜Ÿåˆ—æ˜¯ä¸€ç§æœ‰åºçš„é¡¹ç›®é›†åˆï¼Œå…¶ä¸­æ–°é¡¹ç›®çš„æ·»åŠ å‘ç”Ÿåœ¨ä¸€ç«¯ï¼Œè¿™ç«¯è¢«ç§°ä¸ºâ€œå°¾éƒ¨â€ï¼Œè€Œç°æœ‰é¡¹ç›®çš„ç§»é™¤åˆ™å‘ç”Ÿåœ¨å¦ä¸€ç«¯ï¼Œé€šå¸¸ç§°ä¸ºâ€œå‰ç«¯â€ã€‚å½“å…ƒç´ è¿›å…¥é˜Ÿåˆ—æ—¶ï¼Œå®ƒä»å°¾éƒ¨å¼€å§‹ï¼Œå‘å‰ç«¯ç§»åŠ¨ï¼Œç›´åˆ°æˆä¸ºä¸‹ä¸€ä¸ªè¦è¢«ç§»é™¤çš„å…ƒç´ ä¸ºæ­¢ã€‚

é˜Ÿåˆ—ä¸­æœ€æ–°å¢åŠ çš„é¡¹ç›®å¿…é¡»åœ¨é›†åˆçš„æœ«å°¾ç­‰å¾…ã€‚åœ¨é›†åˆä¸­æœ€ä¹…çš„é¡¹ç›®ä½äºå‰ç«¯ã€‚è¿™ç§æ’åºåŸåˆ™æœ‰æ—¶è¢«ç§°ä¸º**FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰**ï¼Œä¹Ÿç§°ä¸ºâ€œå…ˆæ¥å…ˆæœåŠ¡â€ã€‚

> A queue is an ordered collection of items where the addition of new items happens at one end, called the â€œrear,â€ and the removal of existing items occurs at the other end, commonly called the â€œfront.â€ As an element enters the queue it starts at the rear and makes its way toward the front, waiting until that time when it is the next element to be removed.
>
> The most recently added item in the queue must wait at the end of the collection. The item that has been in the collection the longest is at the front. This ordering principle is sometimes called **FIFO**, **first-in first-out**. It is also known as â€œfirst-come first-served.â€
>



**çº¿æ€§è¡¨**/çº¿æ€§ç»“æ„ï¼Œæ˜¯ä¸€ç§é€»è¾‘ç»“æ„ï¼Œæè¿°äº†å…ƒç´ æŒ‰çº¿æ€§é¡ºåºæ’åˆ—çš„è§„åˆ™ã€‚å¸¸è§çš„çº¿æ€§è¡¨å­˜å‚¨æ–¹å¼æœ‰**æ•°ç»„**å’Œ**é“¾è¡¨**ï¼Œå®ƒä»¬åœ¨ä¸åŒåœºæ™¯ä¸‹å…·æœ‰å„è‡ªçš„ä¼˜åŠ¿å’ŒåŠ£åŠ¿ã€‚

æ•°ç»„æ˜¯ä¸€ç§è¿ç»­å­˜å‚¨ç»“æ„ï¼Œå®ƒå°†çº¿æ€§è¡¨çš„å…ƒç´ æŒ‰ç…§ä¸€å®šçš„é¡ºåºä¾æ¬¡å­˜å‚¨åœ¨å†…å­˜ä¸­çš„è¿ç»­åœ°å€ç©ºé—´ä¸Šã€‚æ•°ç»„éœ€è¦é¢„å…ˆåˆ†é…ä¸€å®šçš„å†…å­˜ç©ºé—´ï¼Œæ¯ä¸ªå…ƒç´ å ç”¨ç›¸åŒå¤§å°çš„å†…å­˜ç©ºé—´ï¼Œå¹¶å¯ä»¥é€šè¿‡ç´¢å¼•æ¥è¿›è¡Œå¿«é€Ÿè®¿é—®å’Œæ“ä½œå…ƒç´ ã€‚è®¿é—®å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(1)$ï¼Œå› ä¸ºå¯ä»¥ç›´æ¥è®¡ç®—å…ƒç´ çš„å†…å­˜åœ°å€ã€‚ç„¶è€Œï¼Œæ’å…¥å’Œåˆ é™¤å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ï¼Œå¹³å‡ä¸º$O(n)$ï¼Œå› ä¸ºéœ€è¦ç§»åŠ¨å…¶ä»–å…ƒç´ æ¥ä¿æŒè¿ç»­å­˜å‚¨çš„ç‰¹æ€§ã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250311114427161.png" alt="image-20250311114427161" style="zoom:50%;" />

**é“¾è¡¨**æ˜¯ä¸€ç§å­˜å‚¨ç»“æ„ï¼Œå®ƒæ˜¯çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨æ–¹å¼ã€‚é“¾è¡¨é€šè¿‡èŠ‚ç‚¹çš„ç›¸äº’é“¾æ¥æ¥å®ç°å…ƒç´ çš„å­˜å‚¨ã€‚æ¯ä¸ªèŠ‚ç‚¹åŒ…å«å…ƒç´ æœ¬èº«ä»¥åŠæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚é“¾è¡¨çš„æ’å…¥å’Œåˆ é™¤æ“ä½œéå¸¸é«˜æ•ˆï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(1)$ï¼Œå› ä¸ºåªéœ€è¦è°ƒæ•´èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ç„¶è€Œï¼Œè®¿é—®å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ï¼Œå¹³å‡ä¸º$O(n)$ï¼Œå› ä¸ºå¿…é¡»ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†é“¾è¡¨ç›´åˆ°æ‰¾åˆ°ç›®æ ‡å…ƒç´ ã€‚

é€‰æ‹©ä½¿ç”¨æ•°ç»„è¿˜æ˜¯é“¾è¡¨ä½œä¸ºå­˜å‚¨æ–¹å¼å–å†³äºå…·ä½“é—®é¢˜çš„éœ€æ±‚å’Œé™åˆ¶ã€‚å¦‚æœéœ€è¦é¢‘ç¹è¿›è¡Œéšæœºè®¿é—®æ“ä½œï¼Œæ•°ç»„æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚å¦‚æœéœ€è¦é¢‘ç¹è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œé“¾è¡¨æ›´é€‚åˆã€‚é€šè¿‡äº†è§£å®ƒä»¬çš„ç‰¹ç‚¹å’Œæ€§èƒ½ï¼Œå¯ä»¥æ ¹æ®å®é™…æƒ…å†µåšå‡ºé€‰æ‹©ã€‚



åœ¨Pythonä¸­ï¼Œlist æ›´æ¥è¿‘äºæ•°ç»„çš„å­˜å‚¨ç»“æ„ã€‚

![image-20240301094904537](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240301094904537.png)







# 4 çº¿æ€§è¡¨ä¹‹é¡ºåºè¡¨

çº¿æ€§è¡¨ï¼ˆ$$List$$ï¼‰çš„å®šä¹‰ï¼šé›¶ä¸ªæˆ–å¤šä¸ªæ•°æ®å…ƒç´ çš„**æœ‰é™**åºåˆ—ã€‚

çº¿æ€§è¡¨çš„æ•°æ®é›†åˆä¸º{$$a_{1}$$,$$a_{2}$$â€¦â€¦$$a_{n}$$}ï¼Œè¯¥åºåˆ—æœ‰å”¯ä¸€çš„å¤´å…ƒç´ å’Œå°¾å…ƒç´ ï¼Œé™¤äº†å¤´å…ƒç´ å¤–ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æœ‰å”¯ä¸€çš„å‰é©±å…ƒç´ ï¼Œé™¤äº†å°¾å…ƒç´ å¤–ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æœ‰å”¯ä¸€çš„åç»§å…ƒç´ ã€‚

çº¿æ€§è¡¨ä¸­çš„å…ƒç´ å±äºç›¸åŒçš„æ•°æ®ç±»å‹ï¼Œå³æ¯ä¸ªå…ƒç´ æ‰€å çš„ç©ºé—´ç›¸åŒã€‚

æ¡†æ¶ï¼š
$$
çº¿æ€§è¡¨\begin{cases}
é¡ºåºå­˜å‚¨â€”â€”é¡ºåºè¡¨\\
é“¾å¼å­˜å‚¨\begin{cases}
å•é“¾è¡¨\\
åŒé“¾è¡¨\\
å¾ªç¯é“¾è¡¨
\end{cases}
\end{cases}
$$

## 4.1 é¡ºåºè¡¨

pythonä¸­çš„é¡ºåºè¡¨å°±æ˜¯åˆ—è¡¨ï¼Œå…ƒç´ åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æœ‰å”¯ä¸€åºå·ï¼ˆä¸‹æ ‡ï¼‰ï¼Œä¸”æ ¹æ®åºå·è®¿é—®ï¼ˆåŒ…æ‹¬è¯»å–å’Œä¿®æ”¹ï¼‰å…ƒç´ çš„æ—¶é—´å¤æ‚åº¦æ˜¯$$O(1)$$çš„ï¼ˆ**éšæœºè®¿é—®**ï¼‰ã€‚

ä»£ç ä½¿ç”¨Pythonçš„å†…ç½®åˆ—è¡¨æ¥å®ç°

```python
class SequentialList:
    def __init__(self, n=0):
        """
        åˆå§‹åŒ–é¡ºåºè¡¨ï¼Œå¯ä»¥æŒ‡å®šåˆå§‹å…ƒç´ çš„æ•°é‡nï¼Œé»˜è®¤ä¸º0ã€‚
        å¦‚æœnå¤§äº0ï¼Œåˆ™åˆå§‹åŒ–ä¸€ä¸ªåŒ…å«ä»0åˆ°n-1æ•´æ•°çš„é¡ºåºè¡¨ã€‚
        """
        self.data = list(range(n)) if n > 0 else []

    def is_empty(self):
        """æ£€æŸ¥é¡ºåºè¡¨æ˜¯å¦ä¸ºç©º"""
        return len(self.data) == 0

    def length(self):
        """è¿”å›é¡ºåºè¡¨ä¸­å…ƒç´ çš„æ•°é‡"""
        return len(self.data)

    def append(self, item):
        """åœ¨é¡ºåºè¡¨æœ«å°¾æ·»åŠ ä¸€ä¸ªæ–°å…ƒç´ """
        self.data.append(item)

    def insert(self, index, item):
        """åœ¨æŒ‡å®šä½ç½®æ’å…¥ä¸€ä¸ªæ–°å…ƒç´ """
        if not (0 <= index <= len(self.data)):
            raise IndexError('Index out of range')
        self.data.insert(index, item)

    def delete(self, index):
        """åˆ é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ """
        if not (0 <= index < len(self.data)):
            raise IndexError('Index out of range')
        del self.data[index]

    def get(self, index):
        """è·å–æŒ‡å®šä½ç½®çš„å…ƒç´ """
        if not (0 <= index < len(self.data)):
            raise IndexError('Index out of range')
        return self.data[index]

    def set(self, index, target):
        """è®¾ç½®æŒ‡å®šä½ç½®çš„å…ƒç´ å€¼"""
        if not (0 <= index < len(self.data)):
            raise IndexError('Index out of range')
        self.data[index] = target

    def display(self):
        """æ‰“å°é¡ºåºè¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ """
        print(self.data)

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    # åˆ›å»ºä¸€ä¸ªç©ºçš„é¡ºåºè¡¨
    lst = SequentialList()
    print("Initial empty list:")
    lst.display()  # åº”è¯¥è¾“å‡º: []

    # æ·»åŠ ä¸€äº›å…ƒç´ 
    lst.append(1)
    lst.append(2)
    lst.append(3)
    print("After appending 1, 2, 3:")
    lst.display()  # åº”è¯¥è¾“å‡º: [1, 2, 3]

    # åœ¨ç‰¹å®šä½ç½®æ’å…¥å…ƒç´ 
    lst.insert(1, 5)
    print("After inserting 5 at index 1:")
    lst.display()  # åº”è¯¥è¾“å‡º: [1, 5, 2, 3]

    # è·å–å’Œè®¾ç½®å…ƒç´ 
    print(f"Element at index 2: {lst.get(2)}")  # åº”è¯¥è¾“å‡º: Element at index 2: 2
    lst.set(2, 7)
    print("After setting index 2 to 7:")
    lst.display()  # åº”è¯¥è¾“å‡º: [1, 5, 7, 3]

    # åˆ é™¤å…ƒç´ 
    lst.delete(1)
    print("After deleting element at index 1:")
    lst.display()  # åº”è¯¥è¾“å‡º: [1, 7, 3]

    # æ£€æŸ¥é•¿åº¦å’Œæ˜¯å¦ä¸ºç©º
    print(f"Length of the list: {lst.length()}")  # åº”è¯¥è¾“å‡º: Length of the list: 3
    print(f"Is the list empty? {lst.is_empty()}")  # åº”è¯¥è¾“å‡º: Is the list empty? False

    # å°è¯•åˆ›å»ºä¸€ä¸ªå¸¦æœ‰åˆå§‹å…ƒç´ çš„é¡ºåºè¡¨
    lst_with_initial_elements = SequentialList(5)
    print("List with initial elements (0 to 4):")
    lst_with_initial_elements.display()  # åº”è¯¥è¾“å‡º: [0, 1, 2, 3, 4]

```



å…³äºçº¿æ€§è¡¨çš„æ—¶é—´å¤æ‚åº¦ï¼š

ç”Ÿæˆã€æ±‚è¡¨ä¸­å…ƒç´ ä¸ªæ•°ã€è¡¨å°¾æ·»åŠ /åˆ é™¤å…ƒç´ ã€è¿”å›/ä¿®æ”¹å¯¹åº”ä¸‹æ ‡å…ƒç´ ï¼Œå‡ä¸º$$O(1)$$ï¼›

è€ŒæŸ¥æ‰¾ã€åˆ é™¤ã€æ’å…¥å…ƒç´ ï¼Œå‡ä¸º$$O(n)$$ã€‚



çº¿æ€§è¡¨çš„ä¼˜ç¼ºç‚¹ï¼š

ä¼˜ç‚¹ï¼š1ã€<mark>æ— é¡»ä¸ºè¡¨ä¸­å…ƒç´ ä¹‹é—´çš„é€»è¾‘å…³ç³»è€Œå¢åŠ é¢å¤–çš„å­˜å‚¨ç©ºé—´ï¼›</mark>

â€‹	    2ã€å¯ä»¥å¿«é€Ÿçš„å­˜å–è¡¨ä¸­ä»»ä¸€ä½ç½®çš„å…ƒç´ ã€‚

ç¼ºç‚¹ï¼š1ã€æ’å…¥å’Œåˆ é™¤æ“ä½œéœ€è¦ç§»åŠ¨å¤§é‡å…ƒç´ ï¼›

â€‹	    2ã€å½“çº¿æ€§è¡¨é•¿åº¦è¾ƒå¤§æ—¶ï¼Œéš¾ä»¥ç¡®å®šå­˜å‚¨ç©ºé—´çš„å®¹é‡ï¼›

â€‹	    3ã€é€ æˆå­˜å‚¨ç©ºé—´çš„â€œç¢ç‰‡â€ã€‚





# 5 çº¿æ€§è¡¨ä¹‹é“¾è¡¨

é“¾è¡¨ï¼ˆLinked Listï¼‰æ˜¯ä¸€ç§å¸¸è§çš„æ•°æ®ç»“æ„ï¼Œç”¨äºå­˜å‚¨å’Œç»„ç»‡æ•°æ®ã€‚å®ƒç”±ä¸€ç³»åˆ—èŠ‚ç‚¹ç»„æˆï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ªæ•°æ®å…ƒç´ å’Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæˆ–å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼‰çš„æŒ‡é’ˆã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250311114427161.png" alt="image-20250311114427161" style="zoom:50%;" />

åœ¨é“¾è¡¨ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½åŒ…å«ä¸¤éƒ¨åˆ†ï¼š

1. æ•°æ®å…ƒç´ ï¼ˆæˆ–æ•°æ®é¡¹ï¼‰ï¼šè¿™æ˜¯èŠ‚ç‚¹å­˜å‚¨çš„å®é™…æ•°æ®ã€‚å¯ä»¥æ˜¯ä»»ä½•æ•°æ®ç±»å‹ï¼Œä¾‹å¦‚æ•´æ•°ã€å­—ç¬¦ä¸²ã€å¯¹è±¡ç­‰ã€‚

2. æŒ‡é’ˆï¼ˆæˆ–å¼•ç”¨ï¼‰ï¼šè¯¥æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæˆ–å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ã€‚å®ƒä»¬ç”¨äºå»ºç«‹èŠ‚ç‚¹ä¹‹é—´çš„è¿æ¥å…³ç³»ï¼Œä»è€Œå½¢æˆé“¾è¡¨çš„ç»“æ„ã€‚



æ ¹æ®æŒ‡é’ˆçš„ç±»å‹å’Œè¿æ¥æ–¹å¼ï¼Œé“¾è¡¨å¯ä»¥åˆ†ä¸ºä¸åŒç±»å‹ï¼ŒåŒ…æ‹¬ï¼š

1. å•å‘é“¾è¡¨ï¼šæ¯ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚é“¾è¡¨çš„å¤´éƒ¨æŒ‡é’ˆæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆä¸ºç©ºï¼ˆæŒ‡å‘ `None`ï¼‰ã€‚

2. åŒå‘é“¾è¡¨ï¼šæ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªæŒ‡å‘åä¸€ä¸ªèŠ‚ç‚¹ã€‚åŒå‘é“¾è¡¨å¯ä»¥ä»å¤´éƒ¨æˆ–å°¾éƒ¨å¼€å§‹éå†ï¼Œå¹¶ä¸”å¯ä»¥åœ¨ä»»æ„ä½ç½®æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹ã€‚

3. å¾ªç¯é“¾è¡¨ï¼šæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘é“¾è¡¨çš„å¤´éƒ¨ï¼Œå½¢æˆä¸€ä¸ªç¯å½¢ç»“æ„ã€‚å¾ªç¯é“¾è¡¨å¯ä»¥ä»ä»»æ„èŠ‚ç‚¹å¼€å§‹éå†ï¼Œå¹¶ä¸”å¯ä»¥æ— é™åœ°å¾ªç¯ä¸‹å»ã€‚

   

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```



```python
class DLinkedNode:
    """åŒå‘é“¾è¡¨çš„èŠ‚ç‚¹ç±»"""
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None
```



é“¾è¡¨ç›¸å¯¹äºæ•°ç»„çš„ä¸€ä¸ªé‡è¦ç‰¹ç‚¹æ˜¯ï¼Œé“¾è¡¨çš„å¤§å°å¯ä»¥åŠ¨æ€åœ°å¢é•¿æˆ–ç¼©å°ï¼Œè€Œä¸éœ€è¦é¢„å…ˆå®šä¹‰å›ºå®šçš„å¤§å°ã€‚è¿™ä½¿å¾—é“¾è¡¨åœ¨éœ€è¦é¢‘ç¹æ’å…¥å’Œåˆ é™¤å…ƒç´ çš„åœºæ™¯ä¸­æ›´åŠ çµæ´»ã€‚

ç„¶è€Œï¼Œé“¾è¡¨çš„è®¿é—®å’Œæœç´¢æ“ä½œç›¸å¯¹è¾ƒæ…¢ï¼Œå› ä¸ºéœ€è¦éå†æ•´ä¸ªé“¾è¡¨æ‰èƒ½æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹ã€‚ä¸æ•°ç»„ç›¸æ¯”ï¼Œé“¾è¡¨çš„ä¼˜åŠ¿åœ¨äºæ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ•ˆç‡è¾ƒé«˜ï¼Œå°¤å…¶æ˜¯åœ¨æ“ä½œå¤´éƒ¨æˆ–å°¾éƒ¨èŠ‚ç‚¹æ—¶ã€‚å› æ­¤ï¼Œé“¾è¡¨åœ¨éœ€è¦é¢‘ç¹æ’å…¥å’Œåˆ é™¤å…ƒç´ è€Œä¸å…³å¿ƒéšæœºè®¿é—®çš„æƒ…å†µä¸‹ï¼Œæ˜¯ä¸€ç§å¸¸ç”¨çš„æ•°æ®ç»“æ„ã€‚



> <img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240228230417320.png" alt="image-20240228230417320" style="zoom: 33%;" />
>
> åœ¨ Python ä¸­ï¼Œ`list` æ˜¯ä½¿ç”¨åŠ¨æ€æ•°ç»„ï¼ˆDynamic Arrayï¼‰å®ç°çš„ï¼Œè€Œä¸æ˜¯é“¾è¡¨ã€‚<mark>åŠ¨æ€æ•°ç»„æ˜¯ä¸€ç§è¿ç»­çš„ã€å›ºå®šå¤§å°çš„å†…å­˜å—</mark>ï¼Œå¯ä»¥åœ¨éœ€è¦æ—¶è‡ªåŠ¨è°ƒæ•´å¤§å°ã€‚è¿™ä½¿å¾— `list` æ”¯æŒå¿«é€Ÿçš„éšæœºè®¿é—®å’Œé«˜æ•ˆçš„å°¾éƒ¨æ“ä½œï¼Œä¾‹å¦‚é™„åŠ ï¼ˆappendï¼‰å’Œå¼¹å‡ºï¼ˆpopï¼‰ã€‚
>
> ä¸é“¾è¡¨ä¸åŒï¼ŒåŠ¨æ€æ•°ç»„ä¸­çš„å…ƒç´ åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ã€‚è¿™å…è®¸é€šè¿‡ç´¢å¼•åœ¨ `list` ä¸­çš„ä»»ä½•ä½ç½®è¿›è¡Œå¸¸æ•°æ—¶é—´O(1)çš„è®¿é—®ã€‚æ­¤å¤–ï¼ŒåŠ¨æ€æ•°ç»„è¿˜å…·æœ‰è¾ƒå°çš„å†…å­˜å¼€é”€ï¼Œå› ä¸ºå®ƒä»¬ä¸éœ€è¦ä¸ºæ¯ä¸ªå…ƒç´ å­˜å‚¨é¢å¤–çš„æŒ‡é’ˆã€‚
>
> å½“éœ€è¦åœ¨ `list` çš„ä¸­é—´è¿›è¡Œæ’å…¥æˆ–åˆ é™¤æ“ä½œæ—¶ï¼ŒåŠ¨æ€æ•°ç»„éœ€è¦è¿›è¡Œå…ƒç´ çš„ç§»åŠ¨ï¼Œå› æ­¤è¿™äº›æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„O(n)ã€‚å¦‚æœé¢‘ç¹åœ°æ’å…¥æˆ–åˆ é™¤å…ƒç´ ï¼Œè€Œä¸ä»…ä»…æ˜¯åœ¨å°¾éƒ¨è¿›è¡Œæ“ä½œï¼Œé‚£ä¹ˆé“¾è¡¨å¯èƒ½æ›´é€‚åˆï¼Œå› ä¸ºé“¾è¡¨çš„æ’å…¥å’Œåˆ é™¤æ“ä½œåœ¨å¹³å‡æƒ…å†µä¸‹å…·æœ‰å¸¸æ•°æ—¶é—´å¤æ‚åº¦ã€‚
>
> æ€»ç»“èµ·æ¥ï¼ŒPython ä¸­çš„ `list` æ˜¯ä½¿ç”¨åŠ¨æ€æ•°ç»„å®ç°çš„ï¼Œå…·æœ‰æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®å’Œé«˜æ•ˆå°¾éƒ¨æ“ä½œçš„ä¼˜ç‚¹ã€‚ä½†æ˜¯ï¼Œå¦‚æœéœ€è¦é¢‘ç¹è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œå¯èƒ½éœ€è¦è€ƒè™‘ä½¿ç”¨é“¾è¡¨æˆ–å…¶ä»–æ•°æ®ç»“æ„ã€‚
>
> 
>
> Python ä¸­çš„ list å’Œ C++ ä¸­çš„ STLï¼ˆStandard Template Libraryï¼‰ä¸­çš„ vector å…·æœ‰ç›¸ä¼¼çš„å®ç°å’Œç”¨æ³•ã€‚vector ä¹Ÿæ˜¯ä½¿ç”¨åŠ¨æ€æ•°ç»„å®ç°çš„ï¼Œæä¾›äº†ç±»ä¼¼äº list çš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬éšæœºè®¿é—®ã€å°¾éƒ¨æ’å…¥å’Œåˆ é™¤ç­‰æ“ä½œã€‚
>
> 
>
> é“¾è¡¨åœ¨æŸç§æ„ä¹‰ä¸Šå¯ä»¥ç»™æ ‘æ‰“åŸºç¡€ã€‚



## 5.1 å•å‘é“¾è¡¨

**åŸºæœ¬æ¦‚å¿µ**

å•å‘é“¾è¡¨ï¼ˆSingly Linked Listï¼‰æ˜¯ç”±ä¸€ç³»åˆ—èŠ‚ç‚¹ï¼ˆNodeï¼‰æ„æˆçš„çº¿æ€§æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š

- æ•°æ®éƒ¨åˆ†ï¼šå­˜å‚¨èŠ‚ç‚¹çš„æ•°æ®ã€‚
- æŒ‡é’ˆéƒ¨åˆ†ï¼šå­˜å‚¨æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼ˆæˆ–å¼•ç”¨ï¼‰ã€‚

å•é“¾è¡¨çš„ç‰¹ç‚¹æ˜¯æ¯ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚å› æ­¤ï¼Œå®ƒæ˜¯å•å‘çš„ï¼Œåªèƒ½ä»å¤´åˆ°å°¾éå†ã€‚



**å•å‘é“¾è¡¨ç»“æ„å›¾**

```text
Head -> Node1 -> Node2 -> Node3 -> None
```

- `Head`ï¼šæŒ‡å‘é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚
- æ¯ä¸ª `Node`ï¼šåŒ…å«æ•°æ®å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼ˆ`next`ï¼‰ã€‚
- `NULL`ï¼šè¡¨ç¤ºé“¾è¡¨çš„ç»“æŸï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ `next` æŒ‡å‘ `NULL`ã€‚



**å¸¸è§æ“ä½œ**

- æ’å…¥æ“ä½œï¼šå¯ä»¥åœ¨é“¾è¡¨çš„å¤´éƒ¨ã€å°¾éƒ¨æˆ–ä¸­é—´æ’å…¥æ–°èŠ‚ç‚¹ã€‚

- åˆ é™¤æ“ä½œï¼šå¯ä»¥åˆ é™¤é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹ã€‚

- éå†æ“ä½œï¼šä»å¤´éƒ¨å¼€å§‹ï¼Œé€ä¸€è®¿é—®é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ã€‚

- æŸ¥æ‰¾æ“ä½œï¼šæ ¹æ®èŠ‚ç‚¹æ•°æ®æŸ¥æ‰¾å¯¹åº”çš„èŠ‚ç‚¹ã€‚

  

å•å‘é“¾è¡¨å®ç°1ï¼š<mark>å°¾æ’æ³•</mark>

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def delete(self, value):
        if self.head is None:
            return

        if self.head.value == value:
            self.head = self.head.next
        else:
            current = self.head
            while current.next:
                if current.next.value == value:
                    current.next = current.next.next
                    break
                current = current.next

    def display(self):
        current = self.head
        while current:
            print(current.value, end=" ")
            current = current.next
        print()

# ä½¿ç”¨ç¤ºä¾‹
linked_list = LinkedList()
linked_list.insert(1)
linked_list.insert(2)
linked_list.insert(3)
linked_list.display()  # è¾“å‡ºï¼š1 2 3
linked_list.delete(2)
linked_list.display()  # è¾“å‡ºï¼š1 3
```



å•å‘é“¾è¡¨å®ç°2ï¼Œ<mark>ä¿å­˜äº†é“¾è¡¨çš„é•¿åº¦</mark>

```python
class LinkList:
    class Node:
        def __init__(self, data, next=None):
            self.data = data  # Store data
            self.next = next  # Point to the next node

    def __init__(self):
        self.head = None  # Initialize head as None
        self.tail = None  # Initialize tail as None
        self.size = 0  # Initialize size to 0

    def print(self):
        ptr = self.head
        while ptr is not None:
            if ptr != self.head:  # Avoid printing a comma before the first element
                print(',', end='')
            print(ptr.data, end='')
            ptr = ptr.next
        print()  # Move to the next line after printing all elements

    def insert_after(self, p, data):  
        nd = LinkList.Node(data)
        if p is None:  # If p is None, insert at the beginning
            self.pushFront(data)
        else:
            nd.next = p.next
            p.next = nd
            if p == self.tail:  # Update tail if necessary
                self.tail = nd
            self.size += 1

    def delete_after(self, p):  
        if p is None or p.next is None:
            return  # Nothing to delete
        if self.tail is p.next:  # Update tail if necessary
            self.tail = p
        p.next = p.next.next
        self.size -= 1

    def popFront(self):
        if self.head is None:
            raise Exception("Popping front from empty link list.")
        else:
            data = self.head.data
            self.head = self.head.next
            self.size -= 1
            if self.size == 0:
                self.tail = None
            return data

    def pushFront(self, data):
        nd = LinkList.Node(data, self.head)
        self.head = nd
        if self.size == 0:
            self.tail = nd
        self.size += 1

    def pushBack(self, data):
        if self.size == 0:
            self.pushFront(data)
        else:
            self.insert_after(self.tail, data)

    def clear(self):
        self.head = None
        self.tail = None
        self.size = 0

    def __iter__(self):
        self.ptr = self.head
        return self

    def __next__(self):
        if self.ptr is None:
            raise StopIteration()
        else:
            data = self.ptr.data
            self.ptr = self.ptr.next
            return data

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    ll = LinkList()
    ll.pushFront(1)
    ll.pushFront(2)
    ll.pushBack(3)
    ll.print()  # åº”è¯¥è¾“å‡º: 2,1,3
    ll.delete_after(ll.head)  # åˆ é™¤ç¬¬äºŒä¸ªå…ƒç´  (1)
    ll.print()  # åº”è¯¥è¾“å‡º: 2,3
    print(f"Pop Front: {ll.popFront()}")  # åº”è¯¥è¾“å‡º: Pop Front: 2
    ll.print()  # åº”è¯¥è¾“å‡º: 3
```



**å•é“¾è¡¨çš„åº”ç”¨**

- åŠ¨æ€å†…å­˜ç®¡ç†ï¼šé“¾è¡¨å¯ä»¥çµæ´»åœ°åˆ†é…å†…å­˜ç©ºé—´ï¼Œç‰¹åˆ«é€‚ç”¨äºå†…å­˜ç©ºé—´ä¸å›ºå®šçš„åœºæ™¯ã€‚
- å®ç°é˜Ÿåˆ—å’Œæ ˆï¼šé“¾è¡¨èƒ½å¤Ÿæœ‰æ•ˆåœ°æ”¯æŒæ ˆï¼ˆLIFOï¼‰å’Œé˜Ÿåˆ—ï¼ˆFIFOï¼‰çš„å®ç°ï¼Œå› ä¸ºå…¶åœ¨æ’å…¥å’Œåˆ é™¤æ“ä½œä¸Šæœ‰ä¼˜åŠ¿ã€‚
- åŠ¨æ€é›†åˆç®¡ç†ï¼šå¯¹äºé›†åˆæ“ä½œï¼ˆå¦‚åŠ¨æ€æ’å…¥å’Œåˆ é™¤å…ƒç´ ï¼‰éå¸¸é«˜æ•ˆã€‚



## 5.2 åŒå‘é“¾è¡¨

**åŸºæœ¬æ¦‚å¿µ**

åŒå‘é“¾è¡¨ï¼ˆDoubly Linked Listï¼‰æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹ä¸ä»…åŒ…å«æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼ˆ`next`ï¼‰ï¼Œè¿˜åŒ…å«æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼ˆ`prev`ï¼‰ã€‚è¿™æ ·ï¼ŒåŒå‘é“¾è¡¨èƒ½å¤Ÿåœ¨ä¸¤ç«¯è¿›è¡Œéå†ï¼šä»å¤´åˆ°å°¾å’Œä»å°¾åˆ°å¤´ã€‚

**åŒé“¾è¡¨çš„ç»“æ„å›¾**

```text
None <- Node1 <-> Node2 <-> Node3 -> None
```

- æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼š
  - `next`ï¼šæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚
  - `prev`ï¼šæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚

- `None`ï¼šè¡¨ç¤ºé“¾è¡¨çš„å¤´å’Œå°¾ï¼Œå¤´èŠ‚ç‚¹head/Node1çš„ `prev` æŒ‡å‘ `None`ï¼Œå°¾èŠ‚ç‚¹tail/Node3çš„ `next` æŒ‡å‘ `None`ã€‚

**å¸¸è§æ“ä½œ**

- æ’å…¥æ“ä½œï¼šå¯ä»¥åœ¨é“¾è¡¨çš„å¤´éƒ¨ã€å°¾éƒ¨æˆ–ä¸­é—´æ’å…¥æ–°èŠ‚ç‚¹ï¼Œæ’å…¥æ“ä½œéœ€è¦åŒæ—¶è°ƒæ•´ `next` å’Œ `prev`æŒ‡é’ˆã€‚
- åˆ é™¤æ“ä½œï¼šå¯ä»¥åˆ é™¤é“¾è¡¨ä¸­çš„æŸä¸ªèŠ‚ç‚¹ï¼Œåˆ é™¤æ“ä½œéœ€è¦æ›´æ–°å‰åèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
- éå†æ“ä½œï¼šå¯ä»¥ä»å¤´åˆ°å°¾æˆ–ä»å°¾åˆ°å¤´è¿›è¡Œéå†ã€‚



åŒå‘é“¾è¡¨ä»£ç å®ç°

```python
class Node:
    def __init__(self, data):
        self.data = data  # èŠ‚ç‚¹æ•°æ®
        self.next = None  # æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        self.prev = None  # æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹

class DoublyLinkedList:
    def __init__(self):
        self.head = None  # é“¾è¡¨å¤´éƒ¨
        self.tail = None  # é“¾è¡¨å°¾éƒ¨

    # åœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ èŠ‚ç‚¹
    def append(self, data):
        new_node = Node(data)
        if not self.head:  # å¦‚æœé“¾è¡¨ä¸ºç©º
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    # åœ¨é“¾è¡¨å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹
    def prepend(self, data):
        new_node = Node(data)
        if not self.head:  # å¦‚æœé“¾è¡¨ä¸ºç©º
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

    # åˆ é™¤é“¾è¡¨ä¸­çš„æŒ‡å®šèŠ‚ç‚¹
    def delete(self, node):
        if not self.head:  # é“¾è¡¨ä¸ºç©º
            return

        if node == self.head:  # åˆ é™¤å¤´éƒ¨èŠ‚ç‚¹
            self.head = node.next
            if self.head:  # å¦‚æœé“¾è¡¨éç©º
                self.head.prev = None
        elif node == self.tail:  # åˆ é™¤å°¾éƒ¨èŠ‚ç‚¹
            self.tail = node.prev
            if self.tail:  # å¦‚æœé“¾è¡¨éç©º
                self.tail.next = None
        else:  # åˆ é™¤ä¸­é—´èŠ‚ç‚¹
            node.prev.next = node.next
            node.next.prev = node.prev

        node = None  # åˆ é™¤èŠ‚ç‚¹

    # æ‰“å°é“¾è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œä»å¤´åˆ°å°¾
    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")

    # æ‰“å°é“¾è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œä»å°¾åˆ°å¤´
    def print_reverse(self):
        current = self.tail
        while current:
            print(current.data, end=" <-> ")
            current = current.prev
        print("None")

# åˆ›å»ºåŒå‘é“¾è¡¨å¯¹è±¡
dll = DoublyLinkedList()

# æ·»åŠ èŠ‚ç‚¹
dll.append(10)
dll.append(20)
dll.append(30)

# åœ¨å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹
dll.prepend(5)

# æ‰“å°é“¾è¡¨
print("ä»å¤´åˆ°å°¾æ‰“å°ï¼š")
dll.print_list()    # 5 <-> 10 <-> 20 <-> 30 <-> None

# æ‰“å°é“¾è¡¨ï¼ˆé€†åºï¼‰
print("ä»å°¾åˆ°å¤´æ‰“å°ï¼š")
dll.print_reverse() # 30 <-> 20 <-> 10 <-> 5 <-> None

# åˆ é™¤èŠ‚ç‚¹
dll.delete(dll.head.next)  # åˆ é™¤ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼ˆæ•°æ®ä¸º10ï¼‰

# æ‰“å°é“¾è¡¨
print("åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹åï¼Œé“¾è¡¨ä¸ºï¼š")   
dll.print_list()    # 5 <-> 20 <-> 30 <-> None

```

> - **append**ï¼šå°†æ–°èŠ‚ç‚¹æ·»åŠ åˆ°é“¾è¡¨çš„å°¾éƒ¨ã€‚
> - **prepend**ï¼šå°†æ–°èŠ‚ç‚¹æ·»åŠ åˆ°é“¾è¡¨çš„å¤´éƒ¨ã€‚
> - **delete**ï¼šåˆ é™¤é“¾è¡¨ä¸­çš„æŒ‡å®šèŠ‚ç‚¹ï¼ˆæ— è®ºæ˜¯å¤´èŠ‚ç‚¹ã€å°¾èŠ‚ç‚¹è¿˜æ˜¯ä¸­é—´èŠ‚ç‚¹ï¼‰ã€‚
> - **print_list**ï¼šä»å¤´åˆ°å°¾æ‰“å°é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚
> - **print_reverse**ï¼šä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚
>
> åŒå‘é“¾è¡¨ç›¸å¯¹äºå•å‘é“¾è¡¨çš„ä¼˜åŠ¿åœ¨äºå®ƒèƒ½å®ç°åŒå‘éå†ï¼Œä½¿å¾—åœ¨æŸäº›æ“ä½œä¸Šï¼ˆä¾‹å¦‚åå‘éå†ã€åˆ é™¤ç‰¹å®šèŠ‚ç‚¹ç­‰ï¼‰æ›´åŠ é«˜æ•ˆã€‚





**åŒé“¾è¡¨çš„åº”ç”¨**

- åŒå‘éå†ï¼šç”±äºåŒé“¾è¡¨å¯ä»¥ä»å¤´åˆ°å°¾æˆ–ä»å°¾åˆ°å¤´éå†ï¼Œå› æ­¤åœ¨æŸäº›éœ€è¦åŒå‘éå†çš„æ•°æ®ç»“æ„ï¼ˆå¦‚<mark>æµè§ˆå™¨å†å²è®°å½•</mark>ã€æ“ä½œç³»ç»Ÿä»»åŠ¡è°ƒåº¦ç­‰ï¼‰ä¸­éå¸¸æœ‰ç”¨ã€‚
- å®ç°åŒç«¯é˜Ÿåˆ—ï¼ˆDequeï¼‰ï¼šåŒé“¾è¡¨éå¸¸é€‚åˆç”¨äº<mark>åŒç«¯é˜Ÿåˆ—</mark>çš„å®ç°ï¼Œå¯ä»¥åœ¨é˜Ÿå¤´å’Œé˜Ÿå°¾éƒ½è¿›è¡Œå¿«é€Ÿçš„æ’å…¥å’Œåˆ é™¤ã€‚
- å†…å­˜ç®¡ç†å’Œåƒåœ¾å›æ”¶ï¼šåŒé“¾è¡¨ç”¨äºç®¡ç†åŠ¨æ€å†…å­˜å—ï¼Œå¸¸è§äºæ“ä½œç³»ç»Ÿçš„å†…å­˜ç®¡ç†å’Œåƒåœ¾å›æ”¶æœºåˆ¶ä¸­



### ç¤ºä¾‹1472.è®¾è®¡æµè§ˆå™¨å†å²è®°å½•

åŒå‘é“¾è¡¨ï¼Œhttps://leetcode.cn/problems/design-browser-history/

ä½ æœ‰ä¸€ä¸ªåªæ”¯æŒå•ä¸ªæ ‡ç­¾é¡µçš„ **æµè§ˆå™¨** ï¼Œæœ€å¼€å§‹ä½ æµè§ˆçš„ç½‘é¡µæ˜¯ `homepage` ï¼Œä½ å¯ä»¥è®¿é—®å…¶ä»–çš„ç½‘ç«™ `url` ï¼Œä¹Ÿå¯ä»¥åœ¨æµè§ˆå†å²ä¸­åé€€ `steps` æ­¥æˆ–å‰è¿› `steps` æ­¥ã€‚

è¯·ä½ å®ç° `BrowserHistory` ç±»ï¼š

- `BrowserHistory(string homepage)` ï¼Œç”¨ `homepage` åˆå§‹åŒ–æµè§ˆå™¨ç±»ã€‚
- `void visit(string url)` ä»å½“å‰é¡µè·³è½¬è®¿é—® `url` å¯¹åº”çš„é¡µé¢ ã€‚æ‰§è¡Œæ­¤æ“ä½œä¼šæŠŠæµè§ˆå†å²å‰è¿›çš„è®°å½•å…¨éƒ¨åˆ é™¤ã€‚
- `string back(int steps)` åœ¨æµè§ˆå†å²ä¸­åé€€ `steps` æ­¥ã€‚å¦‚æœä½ åªèƒ½åœ¨æµè§ˆå†å²ä¸­åé€€è‡³å¤š `x` æ­¥ä¸” `steps > x` ï¼Œé‚£ä¹ˆä½ åªåé€€ `x` æ­¥ã€‚è¯·è¿”å›åé€€ **è‡³å¤š** `steps` æ­¥ä»¥åçš„ `url` ã€‚
- `string forward(int steps)` åœ¨æµè§ˆå†å²ä¸­å‰è¿› `steps` æ­¥ã€‚å¦‚æœä½ åªèƒ½åœ¨æµè§ˆå†å²ä¸­å‰è¿›è‡³å¤š `x` æ­¥ä¸” `steps > x` ï¼Œé‚£ä¹ˆä½ åªå‰è¿› `x` æ­¥ã€‚è¯·è¿”å›å‰è¿› **è‡³å¤š** `steps`æ­¥ä»¥åçš„ `url` ã€‚



```python
class ListNode:
    def __init__(self, url: str):
        self.url = url
        self.prev = None
        self.next = None

class BrowserHistory:
    def __init__(self, homepage: str):
        self.current = ListNode(homepage)

    def visit(self, url: str) -> None:
        new_node = ListNode(url)
        self.current.next = new_node
        new_node.prev = self.current
        self.current = new_node

    def back(self, steps: int) -> str:
        while steps > 0 and self.current.prev is not None:
            self.current = self.current.prev
            steps -= 1
        return self.current.url

    def forward(self, steps: int) -> str:
        while steps > 0 and self.current.next is not None:
            self.current = self.current.next
            steps -= 1
        return self.current.url

if __name__ == "__main__":
    browserHistory = BrowserHistory("leetcode.com")
    browserHistory.visit("google.com")
    browserHistory.visit("facebook.com")
    browserHistory.visit("youtube.com")
    print(browserHistory.back(1))  # facebook.com
    print(browserHistory.back(1))  # google.com
    print(browserHistory.forward(1))  # facebook.com
    browserHistory.visit("linkedin.com")
    print(browserHistory.forward(2))  # linkedin.com
    print(browserHistory.back(2))  # google.com
    print(browserHistory.back(7))  # leetcode.com

```

 



## 5.3 å•é“¾è¡¨ä¸åŒé“¾è¡¨çš„å¯¹æ¯”

| ç‰¹æ€§          | å•é“¾è¡¨                                 | åŒé“¾è¡¨                             |
| ------------- | -------------------------------------- | ---------------------------------- |
| æŒ‡é’ˆæ•°é‡      | æ¯ä¸ªèŠ‚ç‚¹ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹       | æ¯ä¸ªèŠ‚ç‚¹ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘å‰åèŠ‚ç‚¹ |
| è®¿é—®æ–¹å‘      | åªèƒ½ä»å¤´åˆ°å°¾è®¿é—®                       | å¯ä»¥ä»å¤´åˆ°å°¾æˆ–ä»å°¾åˆ°å¤´è®¿é—®         |
| å†…å­˜å¼€é”€      | è¾ƒä½ï¼Œä»…éœ€å­˜å‚¨ä¸€ä¸ªæŒ‡é’ˆ                 | è¾ƒé«˜ï¼Œéœ€è¦å­˜å‚¨ä¸¤ä¸ªæŒ‡é’ˆ             |
| æ’å…¥/åˆ é™¤æ•ˆç‡ | åœ¨å¤´éƒ¨æ’å…¥åˆ é™¤é«˜æ•ˆï¼Œä½†ä¸­é—´æ’å…¥åˆ é™¤è¾ƒæ…¢ | åœ¨ä»»æ„ä½ç½®æ’å…¥åˆ é™¤è¾ƒé«˜æ•ˆ           |
| æ“ä½œå¤æ‚åº¦    | æ“ä½œç®€å•ï¼Œé€‚åˆè½»é‡çº§åº”ç”¨               | æ“ä½œå¤æ‚ï¼Œé€‚ç”¨äºåŒå‘æ“ä½œåœºæ™¯       |
| åº”ç”¨åœºæ™¯      | åŠ¨æ€å†…å­˜ç®¡ç†ï¼Œé˜Ÿåˆ—ã€æ ˆå®ç°             | åŒç«¯é˜Ÿåˆ—å®ç°ï¼ŒåŒå‘éå†ç­‰           |

- å•é“¾è¡¨ é€‚ç”¨äºåŠ¨æ€å†…å­˜ç®¡ç†å’Œéœ€è¦ç®€å•æ•°æ®æ“ä½œçš„åœºæ™¯ï¼Œå…¶æ“ä½œæ•ˆç‡ç›¸å¯¹è¾ƒä½ï¼Œç‰¹åˆ«æ˜¯åœ¨ä¸­é—´æ’å…¥å’Œåˆ é™¤æ—¶ã€‚
- åŒé“¾è¡¨ é€šè¿‡æä¾›åŒå‘æŒ‡é’ˆï¼Œå¢å¼ºäº†æ“ä½œçš„çµæ´»æ€§ï¼Œé€‚ç”¨äºéœ€è¦åŒå‘éå†å’Œé«˜æ•ˆæ’å…¥åˆ é™¤çš„åœºæ™¯ï¼Œå¦‚åŒç«¯é˜Ÿåˆ—ã€æµè§ˆå™¨å†å²è®°å½•ç­‰ã€‚
- ä¸¤è€…çš„é€‰æ‹©åº”æ ¹æ®å…·ä½“åº”ç”¨åœºæ™¯è€Œå®šã€‚å¦‚æœéœ€è¦ç®€å•çš„çº¿æ€§éå†å’ŒåŠ¨æ€æ’å…¥ï¼Œå•é“¾è¡¨å³å¯æ»¡è¶³éœ€æ±‚ï¼›è€Œå¦‚æœæ¶‰åŠåˆ°åŒå‘æ“ä½œå’Œå¤æ‚çš„å†…å­˜ç®¡ç†ï¼ŒåŒé“¾è¡¨åˆ™æ›´åŠ åˆé€‚ã€‚

é“¾è¡¨ç»“æ„æ˜¯åŸºç¡€æ•°æ®ç»“æ„ä¹‹ä¸€ï¼Œç†è§£å…¶æ“ä½œå’Œç®—æ³•å¯¹äºæ·±å…¥å­¦ä¹ æ›´å¤æ‚çš„ç®—æ³•å’Œæ•°æ®ç»“æ„å…·æœ‰é‡è¦æ„ä¹‰ã€‚



## 5.4 å¾ªç¯é“¾è¡¨

å°†å•é“¾è¡¨ä¸­ç»ˆç«¯èŠ‚ç‚¹çš„æŒ‡é’ˆç«¯ç”±ç©ºæŒ‡é’ˆæ”¹ä¸ºæŒ‡å‘å¤´ç»“ç‚¹ï¼Œå°±ä½¿æ•´ä¸ªå•é“¾è¡¨å½¢æˆä¸€ä¸ªç¯ï¼Œè¿™ç§å¤´å°¾ç›¸æ¥çš„å•é“¾è¡¨ç§°ä¸ºå•å¾ªç¯é“¾è¡¨ï¼Œç®€ç§°å¾ªç¯é“¾è¡¨ã€‚

ç„¶è€Œè¿™æ ·ä¼šå¯¼è‡´è®¿é—®æœ€åä¸€ä¸ªç»“ç‚¹æ—¶éœ€è¦$$O(n)$$çš„æ—¶é—´ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å†™å‡º**ä»…è®¾å°¾æŒ‡é’ˆçš„å¾ªç¯é“¾è¡¨**ã€‚

```python
class CircleLinkList:
    class Node:
        def __init__(self, data, next=None):
            self.data = data
            self.next = next

    def __init__(self):
        self.tail = None  # å°¾æŒ‡é’ˆï¼ŒæŒ‡å‘æœ€åä¸€ä¸ªèŠ‚ç‚¹
        self.size = 0  # é“¾è¡¨å¤§å°

    def is_empty(self):
        """æ£€æŸ¥é“¾è¡¨æ˜¯å¦ä¸ºç©º"""
        return self.size == 0

    def pushFront(self, data):
        """åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥å…ƒç´ """
        nd = CircleLinkList.Node(data)
        if self.is_empty():
            self.tail = nd
            nd.next = self.tail  # è‡ªå·±æŒ‡å‘è‡ªå·±å½¢æˆç¯
        else:
            nd.next = self.tail.next  # æ–°èŠ‚ç‚¹æŒ‡å‘å½“å‰å¤´èŠ‚ç‚¹
            self.tail.next = nd  # å½“å‰å°¾èŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹
        self.size += 1

    def pushBack(self, data):
        """åœ¨é“¾è¡¨å°¾éƒ¨æ’å…¥å…ƒç´ """
        nd = CircleLinkList.Node(data)
        if self.is_empty():
            self.tail = nd
            nd.next = self.tail  # è‡ªå·±æŒ‡å‘è‡ªå·±å½¢æˆç¯
        else:
            nd.next = self.tail.next  # æ–°èŠ‚ç‚¹æŒ‡å‘å½“å‰å¤´èŠ‚ç‚¹
            self.tail.next = nd  # å½“å‰å°¾èŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹
            self.tail = nd  # æ›´æ–°å°¾æŒ‡é’ˆ
        self.size += 1

    def popFront(self):
        """ç§»é™¤å¹¶è¿”å›é“¾è¡¨å¤´éƒ¨å…ƒç´ """
        if self.is_empty():
            return None
        else:
            old_head = self.tail.next
            if self.size == 1:
                self.tail = None  # å¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæ›´æ–°å°¾æŒ‡é’ˆä¸ºNone
            else:
                self.tail.next = old_head.next  # è·³è¿‡æ—§å¤´èŠ‚ç‚¹
            self.size -= 1
            return old_head.data

    def popBack(self):
        """ç§»é™¤å¹¶è¿”å›é“¾è¡¨å°¾éƒ¨å…ƒç´ """
        if self.is_empty():
            return None
        elif self.size == 1:
            data = self.tail.data
            self.tail = None
            self.size -= 1
            return data
        else:
            prev = self.tail
            while prev.next != self.tail:  # æ‰¾åˆ°å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹
                prev = prev.next
            data = self.tail.data
            prev.next = self.tail.next  # è·³è¿‡å°¾èŠ‚ç‚¹
            self.tail = prev  # æ›´æ–°å°¾æŒ‡é’ˆ
            self.size -= 1
            return data

    def printList(self):
        """æ‰“å°é“¾è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ """
        if self.is_empty():
            print('Empty!')
        else:
            ptr = self.tail.next
            while True:
                print(ptr.data, end=', ' if ptr != self.tail else '\n')
                if ptr == self.tail:
                    break
                ptr = ptr.next

# ç¤ºä¾‹ç”¨æ³•
if __name__ == "__main__":
    clist = CircleLinkList()

    print("Pushing elements to front:")
    for i in range(3):
        clist.pushFront(i)
        clist.printList()  # åº”è¯¥ä¾æ¬¡è¾“å‡º: 0, 1,0, 2,1,0,

    print("Pushing elements to back:")
    for i in range(3, 6):
        clist.pushBack(i)
        clist.printList()  # åº”è¯¥ä¾æ¬¡è¾“å‡º: 2,1,0,3, 2,1,0,3,4, 2,1,0,3,4,5,

    print("Popping from front:")
    for _ in range(3):
        print(f"Popped: {clist.popFront()}")
        clist.printList()  # åº”è¯¥ä¾æ¬¡è¾“å‡º: 2,1,0,3,4,5, 1,0,3,4,5, 0,3,4,5,

    print("Popping from back:")
    for _ in range(3):
        print(f"Popped: {clist.popBack()}")
        clist.printList()  # åº”è¯¥ä¾æ¬¡è¾“å‡º: 5, 3,4, 5, 4, 3, Empty!
```



## 5.5 å¸¸è§é“¾è¡¨çš„æ“ä½œ

### 1 é“¾è¡¨åè½¬ï¼ˆReverse Linked Listï¼‰

é“¾è¡¨åè½¬æ˜¯ä¸€ä¸ªç»å…¸çš„ç®—æ³•ï¼Œå®ƒå°†é“¾è¡¨ä¸­çš„èŠ‚ç‚¹é¡ºåºåè½¬ï¼Œä½¿å¾—åŸæœ¬æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚è¯¥æ“ä½œåœ¨å¤„ç†æ ˆæˆ–é˜Ÿåˆ—æ—¶éå¸¸æœ‰ç”¨ã€‚

**å•é“¾è¡¨åè½¬ç®—æ³•**

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head: ListNode) -> ListNode:
    prev = None
    curr = head
    while curr is not None:
        next_node = curr.next  # æš‚å­˜å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        curr.next = prev       # å°†å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
        prev = curr            # å‰ä¸€ä¸ªèŠ‚ç‚¹å˜ä¸ºå½“å‰èŠ‚ç‚¹
        curr = next_node       # å½“å‰èŠ‚ç‚¹å˜æ›´ä¸ºåŸå…ˆçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    return prev

```



#### ç¤ºä¾‹206.åè½¬é“¾è¡¨

linked list, https://leetcode.cn/problems/reverse-linked-list/

ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šhead = [1,2,3,4,5]
è¾“å‡ºï¼š[5,4,3,2,1]
```

**ç¤ºä¾‹ 2ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šhead = [1,2]
è¾“å‡ºï¼š[2,1]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šhead = []
è¾“å‡ºï¼š[]
```

 

**æç¤ºï¼š**

- é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ `[0, 5000]`
- `-5000 <= Node.val <= 5000`



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        current = head
        while current:
            next_node = current.next
            current.next = pre
            pre = current
            current = next_node

        return pre
        
```







### 2 **åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨**

åˆå¹¶ä¸¤ä¸ªå·²ç»æ’åºçš„é“¾è¡¨æ˜¯ä¸€ç§å¸¸è§çš„æ“ä½œï¼Œç‰¹åˆ«æ˜¯åœ¨å½’å¹¶æ’åºä¸­ã€‚

**åˆå¹¶ä¸¤ä¸ªæ’åºé“¾è¡¨**

```python
def merge_sorted_lists(l1, l2):
    dummy = Node(0)
    tail = dummy
    while l1 and l2:
        if l1.data < l2.data:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    if l1:
        tail.next = l1
    else:
        tail.next = l2
    return dummy.next
```



#### ç¤ºä¾‹21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

https://leetcode.cn/problems/merge-two-sorted-lists/

å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ **å‡åº** é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚ 

 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img" style="zoom:67%;" />

```
è¾“å…¥ï¼šl1 = [1,2,4], l2 = [1,3,4]
è¾“å‡ºï¼š[1,1,2,3,4,4]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šl1 = [], l2 = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šl1 = [], l2 = [0]
è¾“å‡ºï¼š[0]
```

 

**æç¤ºï¼š**

- ä¸¤ä¸ªé“¾è¡¨çš„èŠ‚ç‚¹æ•°ç›®èŒƒå›´æ˜¯ `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` å’Œ `l2` å‡æŒ‰ **éé€’å‡é¡ºåº** æ’åˆ—



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        # åˆ›å»ºä¸€ä¸ªå“¨å…µèŠ‚ç‚¹ï¼ˆdummy nodeï¼‰ï¼Œç®€åŒ–è¾¹ç•Œæ¡ä»¶å¤„ç†
        prehead = ListNode(-200)
        prev = prehead

        # éå†ä¸¤ä¸ªé“¾è¡¨ç›´åˆ°å…¶ä¸­ä¸€ä¸ªä¸ºç©º
        while list1 and list2:
            if list1.val <= list2.val:
                prev.next = list1
                list1 = list1.next
            else:
                prev.next = list2
                list2 = list2.next            
            prev = prev.next

        # è¿æ¥è¿˜æœªéå†å®Œçš„é‚£ä¸ªé“¾è¡¨
        prev.next = list1 if list1 is not None else list2

        # è¿”å›åˆå¹¶åçš„é“¾è¡¨ï¼Œè·³è¿‡å“¨å…µèŠ‚ç‚¹
        return prehead.next
```





### 3 **æŸ¥æ‰¾é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹**

é€šè¿‡<mark>å¿«æ…¢æŒ‡é’ˆ</mark>çš„æ–¹æ³•ï¼Œå¯ä»¥åœ¨ O(n) çš„æ—¶é—´å¤æ‚åº¦å†…æ‰¾åˆ°é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ã€‚

**æŸ¥æ‰¾ä¸­é—´èŠ‚ç‚¹**

```python
def find_middle_node(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
```



#### ç¤ºä¾‹234.å›æ–‡é“¾è¡¨

linked-list, https://leetcode.cn/problems/palindrome-linked-list/

ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸º

å›æ–‡é“¾è¡¨ï¼ˆ**å›æ–‡** åºåˆ—æ˜¯å‘å‰å’Œå‘åè¯»éƒ½ç›¸åŒçš„åºåˆ—ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚



 

**ç¤ºä¾‹ 1ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šhead = [1,2,2,1]
è¾“å‡ºï¼štrue
```

**ç¤ºä¾‹ 2ï¼š**

<img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šhead = [1,2]
è¾“å‡ºï¼šfalse
```

 

**æç¤ºï¼š**

- é“¾è¡¨ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´`[1, 105]` å†…
- `0 <= Node.val <= 9`

 

**è¿›é˜¶ï¼š**ä½ èƒ½å¦ç”¨ `O(n)` æ—¶é—´å¤æ‚åº¦å’Œ `O(1)` ç©ºé—´å¤æ‚åº¦è§£å†³æ­¤é¢˜ï¼Ÿ



å¿«æ…¢æŒ‡é’ˆæŸ¥æ‰¾é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return True
        
        # 1. ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        # 2. åè½¬é“¾è¡¨çš„ååŠéƒ¨åˆ†
        prev = None
        while slow:
            next_node = slow.next
            slow.next = prev
            prev = slow
            slow = next_node
        
        # 3. å¯¹æ¯”å‰åŠéƒ¨åˆ†å’Œåè½¬åçš„ååŠéƒ¨åˆ†
        left, right = head, prev
        while right:  # right æ˜¯åè½¬åçš„é“¾è¡¨çš„å¤´
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        
        return True

```



### 4 å…¶ä»–ç¤ºä¾‹

#### ç¤ºä¾‹20.åˆ é™¤é“¾è¡¨å…ƒç´ 

http://dsbpython.openjudge.cn/dspythonbook/P0020/

ç¨‹åºå¡«ç©ºï¼Œåˆ é™¤é“¾è¡¨å…ƒç´ 

```python
class Node:
	def __init__(self, data, next=None):
		self.data, self.next = data, next
class LinkList:  #å¾ªç¯é“¾è¡¨
	def __init__(self):
		self.tail = None
		self.size = 0
	def isEmpty(self):
		return self.size == 0
	def pushFront(self,data):
		nd = Node(data)
		if self.tail == None:
			self.tail = nd
			nd.next = self.tail
		else:
			nd.next = self.tail.next
			self.tail.next = nd
		self.size += 1
	def pushBack(self,data):
		self.pushFront(data)
		self.tail = self.tail.next
	def popFront(self):
		if self.size == 0:
			return None
		else:
			nd = self.tail.next
			self.size -= 1
			if self.size == 0:
				self.tail = None
			else:
				self.tail.next = nd.next
		return nd.data
	def printList(self):
		if self.size > 0:
			ptr = self.tail.next
			while True:
				print(ptr.data,end = " ")
				if ptr == self.tail:
					break
				ptr = ptr.next
			print("")

	def remove(self,data):
// åœ¨æ­¤å¤„è¡¥å……ä½ çš„ä»£ç 
t = int(input())
for i in range(t):
	lst = list(map(int,input().split()))
	lkList = LinkList()
	for x in lst:
		lkList.pushBack(x)
	lst = list(map(int,input().split()))
	for a in lst:
		result = lkList.remove(a)
		if result == True:
			lkList.printList()
		elif result == False:
			print("NOT FOUND")
		else:
			print("EMPTY")
	print("----------------")
```

è¾“å…¥

ç¬¬ä¸€è¡Œä¸ºæ•´æ•°tï¼Œè¡¨ç¤ºæœ‰tç»„æ•°æ®ã€‚
æ¯ç»„æ•°æ®2è¡Œ
ç¬¬ä¸€è¡Œæ˜¯è‹¥å¹²ä¸ªæ•´æ•°ï¼Œæ„æˆäº†ä¸€å¼ é“¾è¡¨
ç¬¬äºŒè¡Œæ˜¯è‹¥å¹²æ•´æ•°ï¼Œæ˜¯è¦ä»é“¾è¡¨ä¸­åˆ é™¤çš„æ•°ã€‚

è¾“å‡º

å¯¹æ¯ç»„æ•°æ®ç¬¬äºŒè¡Œä¸­çš„æ¯ä¸ªæ•´æ•°x:

1) å¦‚æœé“¾è¡¨å·²ç»ä¸ºç©ºï¼Œåˆ™è¾“å‡º "EMPTY"
2) å¦‚æœxåœ¨é“¾è¡¨ä¸­ï¼Œåˆ™å°†å…¶åˆ é™¤ï¼Œå¹¶ä¸”è¾“å‡ºåˆ é™¤åçš„é“¾è¡¨ã€‚å¦‚æœåˆ é™¤åé“¾è¡¨ä¸ºç©ºï¼Œåˆ™æ²¡è¾“å‡ºã€‚å¦‚æœæœ‰é‡å¤å…ƒç´ ï¼Œåˆ™åˆ å‰é¢çš„ã€‚

3ï¼‰å¦‚æœé“¾è¡¨ä¸ä¸ºç©ºä¸”xä¸åœ¨é“¾è¡¨ä¸­ï¼Œåˆ™è¾“å‡º"NOT FOUND"

æ ·ä¾‹è¾“å…¥

```
2
1 2 3
3 2 2 9 5 1 1 4
1
9 88 1 23
```

æ ·ä¾‹è¾“å‡º

```
1 2 
1 
NOT FOUND
NOT FOUND
NOT FOUND
EMPTY
EMPTY
----------------
NOT FOUND
NOT FOUND
EMPTY
----------------
```

æ¥æº

éƒ­ç‚œ



ç¨‹åºå¡«ç©ºé¢˜ç›®ï¼Œéœ€è¦æŒæ¡â€œè¡¥å……ä»£ç â€é¢˜å‹ï¼Œä¾‹å¦‚å†™å‡ºæŸä¸ªå‡½æ•°çš„å®ç°ä»£ç ï¼Œå¦‚ def remove(self,data):

```python
class Node:
    def __init__(self, data, next=None):
        self.data, self.next = data, next


class LinkList:  # å¾ªç¯é“¾è¡¨
    def __init__(self):
        self.tail = None
        self.size = 0

    def isEmpty(self):
        return self.size == 0

    def pushFront(self, data):
        nd = Node(data)
        if self.tail == None:
            self.tail = nd
            nd.next = self.tail
        else:
            nd.next = self.tail.next
            self.tail.next = nd
        self.size += 1

    def pushBack(self, data):
        self.pushFront(data)
        self.tail = self.tail.next

    def popFront(self):
        if self.size == 0:
            return None
        else:
            nd = self.tail.next
            self.size -= 1
            if self.size == 0:
                self.tail = None
            else:
                self.tail.next = nd.next
        return nd.data

    def printList(self):
        if self.size > 0:
            ptr = self.tail.next
            while True:
                print(ptr.data, end=" ")
                if ptr == self.tail:
                    break
                ptr = ptr.next
            print("")

    def remove(self, data):  # å¡«ç©ºï¼šå®ç°å‡½æ•°
        if self.size == 0:
            return None
        else:
            ptr = self.tail
            while ptr.next.data != data:
                ptr = ptr.next
                if ptr == self.tail:
                    return False
            self.size -= 1
            if ptr.next == self.tail:
                self.tail = ptr
            ptr.next = ptr.next.next
            return True


t = int(input())
for i in range(t):
    lst = list(map(int, input().split()))
    lkList = LinkList()
    for x in lst:
        lkList.pushBack(x)
    lst = list(map(int, input().split()))
    for a in lst:
        result = lkList.remove(a)
        if result == True:
            lkList.printList()
        elif result == False:
            print("NOT FOUND")
        else:
            print("EMPTY")
    print("----------------")

"""
æ ·ä¾‹è¾“å…¥
2
1 2 3
3 2 2 9 5 1 1 4
1
9 88 1 23

æ ·ä¾‹è¾“å‡º
1 2 
1 
NOT FOUND
NOT FOUND
NOT FOUND
EMPTY
EMPTY
----------------
NOT FOUND
NOT FOUND
EMPTY
----------------
"""
```



#### ç¤ºä¾‹4.æ’å…¥é“¾è¡¨å…ƒç´ 

http://dsbpython.openjudge.cn/2024allhw/004/

å¾ˆé—æ†¾ï¼Œä¸€æ„å­¤è¡Œçš„Yå›æ²¡æœ‰ç†ä¼šä½ å‘Šè¯‰ä»–çš„é¥®é£Ÿè®¡åˆ’å¹¶å¾ˆå¿«åƒå®Œäº†ä»–çš„ç²®é£Ÿå‚¨å¤‡ã€‚
ä½†å¥½åœ¨ä»–æ¡åˆ°äº†ä¸€å¼ æ ¡å›­å¡ï¼Œå‡­è¿™ä¸ªä»–å¯ä»¥å·å·æ··å…¥é¢†å–ç‰©èµ„çš„é˜Ÿä¼ã€‚
ä¸ºäº†ä¸è¢«å¿—æ„¿è€…å¯Ÿè§‰è‡ªå·±æ˜¯åªçŒ«ï¼Œä»–æƒ³è¦æ’åˆ°é˜Ÿä¼çš„æœ€ä¸­å¤®ã€‚ï¼ˆæ’å…¥åè‹¥æœ‰å¶æ•°ä¸ªå…ƒç´ åˆ™é€‰å–é åçš„ä½ç½®ï¼‰
äºæ˜¯ä»–åˆæ‰¾åˆ°äº†ä½ ï¼Œå¸Œæœ›ä½ èƒ½å¸®ä»–ä¿®æ”¹å¿—æ„¿è€…å†™å¥½çš„ä»£ç ï¼Œåœ¨å‘æ”¾é¡ºåºçš„ä¸­é—´åŠ ä¸Šä»–çš„å­¦å·6ã€‚
ä½ è™½ç„¶ä¸ç†è§£å¿—æ„¿è€…ä¸ºä»€ä¹ˆè¦ç”¨é“¾è¡¨æ¥å†™è¿™ä»½ä»£ç ï¼Œä½†ä¸ºäº†ä¸è¢«å‘ç°åªå¾—åœ¨æ­¤åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹ï¼š

```python
class Node:
	def __init__(self, data, next=None):
		self.data, self.next = data, next

class LinkList:
	def __init__(self):
		self.head = None

	def initList(self, data):
		self.head = Node(data[0])
		p = self.head
		for i in data[1:]:
			node = Node(i)
			p.next = node
			p = p.next

	def insertCat(self):
// åœ¨æ­¤å¤„è¡¥å……ä½ çš„ä»£ç 
########            
	def printLk(self):
		p = self.head
		while p:
			print(p.data, end=" ")
			p = p.next
		print()

lst = list(map(int,input().split()))
lkList = LinkList()
lkList.initList(lst)
lkList.insertCat()
lkList.printLk()
```

è¾“å…¥

ä¸€è¡Œï¼Œè‹¥å¹²ä¸ªæ•´æ•°ï¼Œç»„æˆä¸€ä¸ªé“¾è¡¨ã€‚

è¾“å‡º

ä¸€è¡Œï¼Œåœ¨é“¾è¡¨ä¸­é—´ä½ç½®æ’å…¥æ•°å­—6åå¾—åˆ°çš„æ–°é“¾è¡¨

æ ·ä¾‹è¾“å…¥

```
### æ ·ä¾‹è¾“å…¥1
8 1 0 9 7 5
### æ ·ä¾‹è¾“å…¥2
1 2 3
```

æ ·ä¾‹è¾“å‡º

```
### æ ·ä¾‹è¾“å‡º1
8 1 0 6 9 7 5
### æ ·ä¾‹è¾“å‡º2
1 2 6 3
```

æ¥æº

Lou Yuke



ç¨‹åºå¡«ç©ºé¢˜ç›®ï¼Œéœ€è¦æŒæ¡â€œè¡¥å……ä»£ç â€é¢˜å‹ï¼Œä¾‹å¦‚å†™å‡ºæŸä¸ªå‡½æ•°çš„å®ç°ä»£ç ï¼Œå¦‚ def insertCat(self):

```python
class Node:
    def __init__(self, data, next=None):
        self.data, self.next = data, next

class LinkList:
    def __init__(self):
        self.head = None

    def initList(self, data):
        self.head = Node(data[0])
        p = self.head
        for i in data[1:]:
            node = Node(i)
            p.next = node
            p = p.next

    def insertCat(self):
        # è®¡ç®—é“¾è¡¨çš„é•¿åº¦
        length = 0
        p = self.head
        while p:
            length += 1
            p = p.next

        # æ‰¾åˆ°æ’å…¥ä½ç½®
        position = length // 2 if length % 2 == 0 else (length // 2) + 1
        p = self.head
        for _ in range(position - 1):
            p = p.next

        # åœ¨æ’å…¥ä½ç½®å¤„æ’å…¥æ•°å­—6
        node = Node(6)
        node.next = p.next
        p.next = node

    def printLk(self):
        p = self.head
        while p:
            print(p.data, end=" ")
            p = p.next
        print()

lst = list(map(int, input().split()))
lkList = LinkList()
lkList.initList(lst)
lkList.insertCat()
lkList.printLk()

"""
### æ ·ä¾‹è¾“å…¥1
8 1 0 9 7 5
### æ ·ä¾‹è¾“å…¥2
1 2 3

### æ ·ä¾‹è¾“å‡º1
8 1 0 6 9 7 5
### æ ·ä¾‹è¾“å‡º2
1 2 6 3
"""
```





# 6 The Stack Abstract Data Type

æ ˆæŠ½è±¡æ•°æ®ç±»å‹é€šè¿‡ä»¥ä¸‹ç»“æ„å’Œæ“ä½œæ¥å®šä¹‰ã€‚å¦‚ä¸Šæ‰€è¿°ï¼Œæ ˆæ˜¯ä¸€ç§æœ‰åºçš„é¡¹é›†åˆï¼Œå…¶ä¸­é¡¹è¢«æ·»åŠ åˆ°è¢«ç§°ä¸ºâ€œé¡¶ç«¯â€çš„ä¸€ç«¯ï¼Œä¹Ÿä»è¿™ä¸€ç«¯ç§»é™¤ã€‚æ ˆæ˜¯æŒ‰ç…§åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰çš„é¡ºåºæ’åˆ—çš„ã€‚ä¸‹é¢ç»™å‡ºäº†æ ˆçš„æ“ä½œã€‚

> The stack abstract data type is defined by the following structure and operations. A stack is structured, as described above, as an ordered collection of items where items are added to and removed from the end called the â€œtop.â€ Stacks are ordered LIFO. The stack operations are given below.

- `Stack()` creates a new stack that is empty. It needs no parameters and returns an empty stack.
- `push(item)` adds a new item to the top of the stack. It needs the item and returns nothing.
- `pop()` removes the top item from the stack. It needs no parameters and returns the item. The stack is modified.
- `peek()` returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.
- `isEmpty()` tests to see whether the stack is empty. It needs no parameters and returns a boolean value.
- `size()` returns the number of items on the stack. It needs no parameters and returns an integer.

For example, if `s` is a stack that has been created and starts out empty, then Table 1 shows the results of a sequence of stack operations. Under stack contents, the top item is listed at the far right.



Table 1: Sample Stack Operations

| **Stack Operation** | **Stack Contents**   | **Return Value** |
| :------------------ | :------------------- | :--------------- |
| `s.isEmpty()`       | `[]`                 | `True`           |
| `s.push(4)`         | `[4]`                |                  |
| `s.push('dog')`     | `[4,'dog']`          |                  |
| `s.peek()`          | `[4,'dog']`          | `'dog'`          |
| `s.push(True)`      | `[4,'dog',True]`     |                  |
| `s.size()`          | `[4,'dog',True]`     | `3`              |
| `s.isEmpty()`       | `[4,'dog',True]`     | `False`          |
| `s.push(8.4)`       | `[4,'dog',True,8.4]` |                  |
| `s.pop()`           | `[4,'dog',True]`     | `8.4`            |
| `s.pop()`           | `[4,'dog']`          | `True`           |
| `s.size()`          | `[4,'dog']`          | `2`              |





## 6.1 Implementing a Stack in Python

ç°åœ¨å·²ç»æ˜ç¡®å®šä¹‰äº†æ ˆä½œä¸ºä¸€ç§æŠ½è±¡æ•°æ®ç±»å‹ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†æ³¨æ„åŠ›è½¬å‘ä½¿ç”¨Pythonæ¥å®ç°æ ˆã€‚å›æƒ³ä¸€ä¸‹ï¼Œå½“æˆ‘ä»¬ä¸ºæŠ½è±¡æ•°æ®ç±»å‹æä¾›ç‰©ç†å®ç°æ—¶ï¼Œç§°è¿™ç§å®ç°ä¸ºæ•°æ®ç»“æ„ã€‚

åœ¨Pythonä¸­ï¼Œå°±åƒåœ¨ä»»ä½•é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€ä¸­ä¸€æ ·ï¼Œå®ç°è¯¸å¦‚æ ˆè¿™æ ·çš„æŠ½è±¡æ•°æ®ç±»å‹çš„é¦–é€‰æ–¹æ³•æ˜¯åˆ›å»ºä¸€ä¸ªæ–°ç±»ã€‚æ ˆæ“ä½œè¢«å®ç°ä¸ºæ–¹æ³•ã€‚æ­¤å¤–ï¼Œä¸ºäº†å®ç°æ ˆï¼ˆå®ƒæ˜¯ä¸€ä¸ªå…ƒç´ çš„é›†åˆï¼‰ï¼Œåˆ©ç”¨Pythonæä¾›çš„ç®€å•è€Œå¼ºå¤§çš„åŸºæœ¬é›†åˆæ˜¯å¾ˆåˆç†çš„ã€‚æˆ‘ä»¬å°†ä½¿ç”¨åˆ—è¡¨æ¥å®ç°ã€‚

> Now that we have clearly defined the stack as an abstract data type we will turn our attention to using Python to implement the stack. Recall that when we give an abstract data type a physical implementation we refer to the implementation as a data structure.
>
> As we described in Chapter 1, in Python, as in any object-oriented programming language, the implementation of choice for an abstract data type such as a stack is the creation of a new class. The stack operations are implemented as methods. Further, to implement a stack, which is a collection of elements, it makes sense to utilize the power and simplicity of the primitive collections provided by Python. We will use a list.
>

```mermaid
classDiagram
    class Stack {
        - items: List
        
        + isEmpty(): bool
        + push(item: T): None
        + pop(): T
        + peek(): T 
        + size(): int
    }
```



```python
class Stack:
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        return self.items == []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        return self.items.pop()
    
    def peek(self):
        return self.items[len(self.items)-1]
    
    def size(self):
        return len(self.items)

s = Stack()

print(s.is_empty())
s.push(4)
s.push('dog')

print(s.peek())
s.push(True)
print(s.size())
print(s.is_empty())
s.push(8.4)
print(s.pop())
print(s.pop())
print(s.size())

"""
True
dog
3
False
8.4
True
2
"""
```



è¦æ±‚è‡ªå·±ä¼šç”¨ç±»å®ç°Stackï¼Œä½†æ˜¯å®é™…ç¼–ç¨‹æ—¶å€™ï¼Œç›´æ¥ä½¿ç”¨ç³»ç»Ÿçš„listæ›´å¥½ã€‚

```python
#function rev_string(my_str) that uses a stack to reverse the characters in a string.
def rev_string(my_str):
    s = [] # Stack()
    rev = []
    for c in my_str:
        s.append(c) # push(c)

    #while not s.is_empty():
    while s:
        rev.append(s.pop())
    return "".join(rev)

test_string = "cutie"

print(rev_string(test_string))

# output: eituc
    
```



## 6.2 åŒ¹é…æ‹¬å·

æˆ‘ä»¬ç°åœ¨å°†æ³¨æ„åŠ›è½¬å‘ä½¿ç”¨æ ˆæ¥è§£å†³çœŸæ­£çš„è®¡ç®—æœºç§‘å­¦é—®é¢˜ã€‚æ¯«æ— ç–‘é—®ï¼Œä½ å·²ç»å†™è¿‡è¯¸å¦‚`(5+6)âˆ—(7+8)/(4+3)`è¿™æ ·çš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œå…¶ä¸­ä½¿ç”¨äº†æ‹¬å·æ¥å®‰æ’æ“ä½œçš„æ‰§è¡Œé¡ºåºã€‚

æ‹¬å·å¿…é¡»ä»¥å¹³è¡¡çš„æ–¹å¼å‡ºç°ã€‚**å¹³è¡¡çš„æ‹¬å·**æ„å‘³ç€æ¯ä¸ªå¼€ç¬¦å·éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„é—­ç¬¦å·ï¼Œå¹¶ä¸”æ‹¬å·å¯¹æ˜¯æ­£ç¡®åµŒå¥—çš„ã€‚è€ƒè™‘ä»¥ä¸‹æ­£ç¡®å¹³è¡¡çš„æ‹¬å·å­—ç¬¦ä¸²ï¼š

> We now turn our attention to using stacks to solve real computer science problems. You have no doubt written arithmetic expressions such as
>
> `(5+6)âˆ—(7+8)/(4+3)` where parentheses are used to order the performance of operations. 
>
> Parentheses must appear in a balanced fashion. **Balanced parentheses** means that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested. Consider the following correctly balanced strings of parentheses:
>

```
(()()()())

(((())))

(()((())()))
```

Compare those with the following, which are not balanced:

```
((((((())

()))

(()()(()
```

åŒºåˆ†æ‹¬å·æ˜¯å¦æ­£ç¡®å¹³è¡¡æ˜¯è¯†åˆ«è®¸å¤šç¼–ç¨‹è¯­è¨€ç»“æ„çš„é‡è¦éƒ¨åˆ†ã€‚

æ¥ä¸‹æ¥çš„æŒ‘æˆ˜æ˜¯ç¼–å†™ä¸€ä¸ªç®—æ³•ï¼Œè¯¥ç®—æ³•èƒ½å¤Ÿä»å·¦åˆ°å³è¯»å–ä¸€ä¸²æ‹¬å·ï¼Œå¹¶åˆ¤æ–­è¿™äº›ç¬¦å·æ˜¯å¦å¹³è¡¡ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦åšä¸€ä¸ªé‡è¦çš„è§‚å¯Ÿã€‚å½“ä½ ä»å·¦åˆ°å³å¤„ç†ç¬¦å·æ—¶ï¼Œæœ€è¿‘çš„å¼€æ‹¬å·å¿…é¡»ä¸ä¸‹ä¸€ä¸ªé—­æ‹¬å·åŒ¹é…ï¼ˆè§å›¾4ï¼‰ã€‚åŒæ—¶ï¼Œç¬¬ä¸€ä¸ªè¢«å¤„ç†çš„å¼€æ‹¬å·å¯èƒ½éœ€è¦ç­‰åˆ°æœ€åä¸€ä¸ªç¬¦å·æ‰èƒ½æ‰¾åˆ°å®ƒçš„åŒ¹é…é¡¹ã€‚é—­æ‹¬å·ä¸å¼€æ‹¬å·çš„åŒ¹é…é¡ºåºä¸å…¶å‡ºç°é¡ºåºç›¸åï¼Œå®ƒä»¬ä»å†…åˆ°å¤–è¿›è¡ŒåŒ¹é…ã€‚è¿™ä¸€ç‚¹æç¤ºæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

> The ability to differentiate between parentheses that are correctly balanced and those that are unbalanced is an important part of recognizing many programming language structures.
>
> The challenge then is to write an algorithm that will read a string of parentheses from left to right and decide whether the symbols are balanced. To solve this problem we need to make an important observation. As you process symbols from left to right, the most recent opening parenthesis must match the next closing symbol (see Figure 4). Also, the first opening symbol processed may have to wait until the very last symbol for its match. Closing symbols match opening symbols in the reverse order of their appearance; they match from the inside out. This is a clue that stacks can be used to solve the problem.
>

![../_images/simpleparcheck.png](https://raw.githubusercontent.com/GMyhf/img/main/img/simpleparcheck.png)

Figure 4: Matching Parentheses



```python
#returns a boolean result as to whether the string of parentheses is balanced
def par_checker(symbol_string):
    s = [] # Stack()
    balanced = True
    index = 0
    while index < len(symbol_string) and balanced:
        symbol = symbol_string[index]
        if symbol == "(":
            s.append(symbol) # push(symbol)
        else:
            #if s.is_empty():
            if not s:
                balanced = False
            else:
                s.pop()
        index = index + 1
    
    #if balanced and s.is_empty():
    if balanced and not s:
        return True
    else:
        return False

print(par_checker('((()))'))
print(par_checker('(()'))

# True
# False
```



### 1 Balanced Symbols (A General Case)

ä¸Šè¿°çš„å¹³è¡¡æ‹¬å·é—®é¢˜æ˜¯å‡ºç°åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­çš„ä¸€ç§æ›´æ™®éæƒ…å†µçš„å…·ä½“æ¡ˆä¾‹ã€‚å¹³è¡¡å’ŒåµŒå¥—ä¸åŒç±»å‹çš„å¼€ç¬¦å·å’Œé—­ç¬¦å·çš„ä¸€èˆ¬é—®é¢˜é¢‘ç¹å‡ºç°ã€‚ä¾‹å¦‚ï¼Œåœ¨Pythonä¸­ï¼Œæ–¹æ‹¬å·`[`å’Œ`]`ç”¨äºåˆ—è¡¨ï¼›èŠ±æ‹¬å·`{`å’Œ`}`ç”¨äºå­—å…¸ï¼›åœ†æ‹¬å·`(`å’Œ`)`ç”¨äºå…ƒç»„å’Œç®—æœ¯è¡¨è¾¾å¼ã€‚åªè¦æ¯ç§ç¬¦å·éƒ½ä¿æŒè‡ªèº«çš„å¼€å’Œå…³å…³ç³»ï¼Œå°±å¯ä»¥æ··åˆä½¿ç”¨è¿™äº›ç¬¦å·ã€‚ä¾‹å¦‚ï¼Œå¦‚ä¸‹æ‰€ç¤ºçš„ç¬¦å·å­—ç¬¦ä¸²ï¼š

> The balanced parentheses problem shown above is a specific case of a more general situation that arises in many programming languages. The general problem of balancing and nesting different kinds of opening and closing symbols occurs frequently. For example, in Python square brackets, `[` and `]`, are used for lists; curly braces, `{` and `}`, are used for dictionaries; and parentheses, `(` and `)`, are used for tuples and arithmetic expressions. It is possible to mix symbols as long as each maintains its own open and close relationship. Strings of symbols such as

```
{ { ( [ ] [ ] ) } ( ) }

[ [ { { ( ( ) ) } } ] ]

[ ] [ ] [ ] ( ) { }
```

are properly balanced in that not only does each opening symbol have a corresponding closing symbol, but the types of symbols match as well.

Compare those with the following strings that are not balanced:

```
( [ ) ]

( ( ( ) ] ) )

[ { ( ) ]
```

ä»å‰ä¸€èŠ‚çš„ç®€å•æ‹¬å·æ£€æŸ¥å™¨å¯ä»¥å¾ˆå®¹æ˜“åœ°æ‰©å±•æ¥å¤„ç†è¿™äº›æ–°çš„ç¬¦å·ç±»å‹ã€‚å›æƒ³ä¸€ä¸‹ï¼Œæ¯ä¸ªå¼€ç¬¦å·åªæ˜¯ç®€å•åœ°å‹å…¥æ ˆä¸­ï¼Œç­‰å¾…åŒ¹é…çš„é—­ç¬¦å·ç¨ååœ¨åºåˆ—ä¸­å‡ºç°ã€‚å½“ä¸€ä¸ªé—­ç¬¦å·ç¡®å®å‡ºç°æ—¶ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æˆ‘ä»¬å¿…é¡»æ£€æŸ¥å®ƒæ˜¯å¦æ­£ç¡®åŒ¹é…æ ˆé¡¶çš„å¼€ç¬¦å·ç±»å‹ã€‚å¦‚æœè¿™ä¸¤ä¸ªç¬¦å·ä¸åŒ¹é…ï¼Œé‚£ä¹ˆå­—ç¬¦ä¸²å°±ä¸å¹³è¡¡ã€‚å†æ¬¡å¼ºè°ƒï¼Œå¦‚æœæ•´ä¸ªå­—ç¬¦ä¸²éƒ½è¢«å¤„ç†ä¸”æ ˆä¸­æ²¡æœ‰å‰©ä¸‹ä»»ä½•æœªåŒ¹é…çš„ç¬¦å·ï¼Œé‚£ä¹ˆè¯¥å­—ç¬¦ä¸²å°±æ˜¯æ­£ç¡®å¹³è¡¡çš„ã€‚

> The simple parentheses checker from the previous section can easily be extended to handle these new types of symbols. Recall that each opening symbol is simply pushed on the stack to wait for the matching closing symbol to appear later in the sequence. When a closing symbol does appear, the only difference is that we must check to be sure that it correctly matches the type of the opening symbol on top of the stack. If the two symbols do not match, the string is not balanced. Once again, if the entire string is processed and nothing is left on the stack, the string is correctly balanced.



```python
def par_checker(symbol_string):
    s = [] # Stack()
    balanced = True
    index = 0 
    while index < len(symbol_string) and balanced:
        symbol = symbol_string[index] 
        if symbol in "([{":
            s.append(symbol) # push(symbol)
        else:
            top = s.pop()
            if not matches(top, symbol):
                balanced = False
        index += 1
        #if balanced and s.is_empty():
        if balanced and not s:
            return True 
        else:
            return False
        
def matches(open, close):
    opens = "([{"
    closes = ")]}"
    return opens.index(open) == closes.index(close)

print(par_checker('{{}}[]]'))

# output: False
```



#### ç¤ºä¾‹OJ03704: æ‹¬å·åŒ¹é…é—®é¢˜

stack, http://cs101.openjudge.cn/practice/03704

åœ¨æŸä¸ªå­—ç¬¦ä¸²ï¼ˆé•¿åº¦ä¸è¶…è¿‡100ï¼‰ä¸­æœ‰å·¦æ‹¬å·ã€å³æ‹¬å·å’Œå¤§å°å†™å­—æ¯ï¼›è§„å®šï¼ˆä¸å¸¸è§çš„ç®—æ•°å¼å­ä¸€æ ·ï¼‰ä»»ä½•ä¸€ä¸ªå·¦æ‹¬å·éƒ½ä»å†…åˆ°å¤–ä¸åœ¨å®ƒå³è¾¹ä¸”è·ç¦»æœ€è¿‘çš„å³æ‹¬å·åŒ¹é…ã€‚å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾åˆ°æ— æ³•åŒ¹é…çš„å·¦æ‹¬å·å’Œå³æ‹¬å·ï¼Œè¾“å‡ºåŸæ¥å­—ç¬¦ä¸²ï¼Œå¹¶åœ¨ä¸‹ä¸€è¡Œæ ‡å‡ºä¸èƒ½åŒ¹é…çš„æ‹¬å·ã€‚ä¸èƒ½åŒ¹é…çš„å·¦æ‹¬å·ç”¨"$"æ ‡æ³¨ï¼Œä¸èƒ½åŒ¹é…çš„å³æ‹¬å·ç”¨"?"æ ‡æ³¨.

**è¾“å…¥**

è¾“å…¥åŒ…æ‹¬å¤šç»„æ•°æ®ï¼Œæ¯ç»„æ•°æ®ä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ŒåªåŒ…å«å·¦å³æ‹¬å·å’Œå¤§å°å†™å­—æ¯ï¼Œ**å­—ç¬¦ä¸²é•¿åº¦ä¸è¶…è¿‡100**
**æ³¨æ„ï¼šcin.getline(str,100)æœ€å¤šåªèƒ½è¾“å…¥99ä¸ªå­—ç¬¦ï¼**

**è¾“å‡º**

å¯¹æ¯ç»„è¾“å‡ºæ•°æ®ï¼Œè¾“å‡ºä¸¤è¡Œï¼Œç¬¬ä¸€è¡ŒåŒ…å«åŸå§‹è¾“å…¥å­—ç¬¦ï¼Œç¬¬äºŒè¡Œç”±"\$","?"å’Œç©ºæ ¼ç»„æˆï¼Œ"$"å’Œ"?"è¡¨ç¤ºä¸ä¹‹å¯¹åº”çš„å·¦æ‹¬å·å’Œå³æ‹¬å·ä¸èƒ½åŒ¹é…ã€‚

æ ·ä¾‹è¾“å…¥

```
((ABCD(x)
)(rttyy())sss)(
```

æ ·ä¾‹è¾“å‡º

```
((ABCD(x)
$$
)(rttyy())sss)(
?            ?$
```



```python
# https://www.cnblogs.com/huashanqingzhu/p/6546598.html

lines = []
while True:
    try:
        lines.append(input())
    except EOFError:
        break
    
ans = []
for s in lines:
    stack = []
    Mark = []
    for i in range(len(s)):
        if s[i] == '(':
            stack.append(i)
            Mark += ' '
        elif s[i] == ')':
            if len(stack) == 0:
                Mark += '?'
            else:
                Mark += ' '
                stack.pop()
        else:
            Mark += ' '
    
    while(len(stack)):
        Mark[stack[-1]] = '$'
        stack.pop()
    
    print(s)
    print(''.join(map(str, Mark)))
```



#### ç»ƒä¹ 20140:ä»Šæ—¥åŒ–å­¦è®ºæ–‡

http://cs101.openjudge.cn/practice/20140/



## 6.3 è¿›åˆ¶è½¬æ¢

### 1 å°†åè¿›åˆ¶æ•°è½¬æ¢æˆäºŒè¿›åˆ¶æ•°

åœ¨ä½ å­¦ä¹ è®¡ç®—æœºç§‘å­¦çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½å·²ç»ä»¥è¿™æ ·æˆ–é‚£æ ·çš„æ–¹å¼æ¥è§¦åˆ°äºŒè¿›åˆ¶æ•°çš„æ¦‚å¿µã€‚äºŒè¿›åˆ¶è¡¨ç¤ºåœ¨è®¡ç®—æœºç§‘å­¦ä¸­éå¸¸é‡è¦ï¼Œå› ä¸ºè®¡ç®—æœºä¸­å­˜å‚¨çš„æ‰€æœ‰å€¼éƒ½ä»¥ä¸€ä¸²äºŒè¿›åˆ¶æ•°å­—çš„å½¢å¼å­˜åœ¨ï¼Œå³ç”±0å’Œ1ç»„æˆçš„å­—ç¬¦ä¸²ã€‚å¦‚æœæ²¡æœ‰èƒ½åŠ›åœ¨å¸¸è§è¡¨ç¤ºæ³•å’ŒäºŒè¿›åˆ¶æ•°ä¹‹é—´æ¥å›è½¬æ¢ï¼Œæˆ‘ä»¬å°†éœ€è¦ä»¥éå¸¸ç¬¨æ‹™çš„æ–¹å¼ä¸è®¡ç®—æœºè¿›è¡Œäº¤äº’ã€‚

æ•´æ•°å€¼æ˜¯å¸¸è§çš„æ•°æ®é¡¹ï¼Œåœ¨è®¡ç®—æœºç¨‹åºå’Œè®¡ç®—ä¸­æ— æ—¶æ— åˆ»ä¸åœ¨ä½¿ç”¨ã€‚æˆ‘ä»¬åœ¨æ•°å­¦è¯¾ä¸Šå­¦ä¹ å®ƒä»¬ï¼Œå¹¶ä¸”å½“ç„¶ä½¿ç”¨åè¿›åˆ¶æ•°ç³»ç»Ÿæˆ–åŸºæ•°ä¸º10çš„æ–¹å¼æ¥è¡¨ç¤ºå®ƒä»¬ã€‚åè¿›åˆ¶æ•°$233_{10}$åŠå…¶å¯¹åº”çš„äºŒè¿›åˆ¶ç­‰ä»·å½¢å¼$11101001_2$åˆ†åˆ«è¢«è§£é‡Šä¸ºï¼š

- åè¿›åˆ¶æ•°$233_{10}$æ„å‘³ç€è¿™æ˜¯ä¸€ä¸ªåŸºäº10çš„æ•°å€¼ï¼Œè®¡ç®—æ–¹å¼ä¸º$2*10^2 + 3*10^1 + 3*10^0$ã€‚
- äºŒè¿›åˆ¶æ•°$11101001_2$åˆ™æ˜¯ä¸€ä¸ªåŸºäº2çš„æ•°å€¼ï¼Œè®¡ç®—æ–¹å¼ä¸º$1*2^7 + 1*2^6 + 1*2^5 + 0*2^4 + 1*2^3 + 0*2^2 + 0*2^1 + 1*2^0$ã€‚

è¿™ç§è½¬æ¢å¯¹äºç†è§£è®¡ç®—æœºå¦‚ä½•å¤„ç†å’Œå­˜å‚¨æ•°å€¼æ•°æ®è‡³å…³é‡è¦ã€‚

> In your study of computer science, you have probably been exposed in one way or another to the idea of a binary number. Binary representation is important in computer science since all values stored within a computer exist as a string of binary digits, a string of 0s and 1s. Without the ability to convert back and forth between common representations and binary numbers, we would need to interact with computers in very awkward ways.
>
> Integer values are common data items. They are used in computer programs and computation all the time. We learn about them in math class and of course represent them using the decimal number system, or base 10. The decimal number $233_{10}$ and its corresponding binary equivalent $11101001_2$ are interpreted respectively as
>

$2Ã—10^2+3Ã—10^1+3Ã—10^0$

and

$1Ã—2^7+1Ã—2^6+1Ã—2^5+0Ã—2^4+1Ã—2^3+0Ã—2^2+0Ã—2^1+1Ã—2^0$

ä½†æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•è½»æ¾åœ°å°†æ•´æ•°å€¼è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ•°å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä¸€ç§ç§°ä¸ºâ€œé™¤ä»¥2â€çš„ç®—æ³•ï¼Œå®ƒä½¿ç”¨æ ˆæ¥è·Ÿè¸ªäºŒè¿›åˆ¶ç»“æœçš„æ•°å­—ã€‚

â€œé™¤ä»¥2â€ç®—æ³•å‡è®¾æˆ‘ä»¬ä»ä¸€ä¸ªå¤§äº0çš„æ•´æ•°å¼€å§‹ã€‚ç„¶åé€šè¿‡ä¸€ä¸ªç®€å•çš„è¿­ä»£è¿‡ç¨‹ä¸æ–­å°†åè¿›åˆ¶æ•°é™¤ä»¥2å¹¶è®°å½•ä½™æ•°ã€‚ç¬¬ä¸€æ¬¡é™¤ä»¥2å¯ä»¥å‘Šè¯‰æˆ‘ä»¬è¯¥å€¼æ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°ã€‚å¶æ•°å€¼çš„ä½™æ•°ä¸º0ï¼Œæ„å‘³ç€åœ¨ä¸ªä½ä¸Šå°†æ˜¯æ•°å­—0ã€‚å¥‡æ•°å€¼çš„ä½™æ•°ä¸º1ï¼Œåœ¨ä¸ªä½ä¸Šå°†æ˜¯æ•°å­—1ã€‚æˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ„å»ºäºŒè¿›åˆ¶æ•°æ˜¯ä¸€ä¸ªæ•°å­—åºåˆ—çš„è¿‡ç¨‹ï¼›æˆ‘ä»¬è®¡ç®—çš„<mark>ç¬¬ä¸€ä¸ªä½™æ•°å®é™…ä¸Šä¼šæ˜¯è¿™ä¸ªåºåˆ—ä¸­çš„æœ€åä¸€ä¸ªæ•°å­—</mark>ã€‚å¦‚å›¾5æ‰€ç¤ºï¼Œæˆ‘ä»¬å†æ¬¡çœ‹åˆ°äº†è¿™ç§<mark>åè½¬ç‰¹æ€§</mark>ï¼Œè¿™è¡¨æ˜æ ˆå¯èƒ½æ˜¯è§£å†³é—®é¢˜çš„åˆé€‚æ•°æ®ç»“æ„ã€‚

> But how can we easily convert integer values into binary numbers? The answer is an algorithm called â€œDivide by 2â€ that uses a stack to keep track of the digits for the binary result.
>
> The Divide by 2 algorithm assumes that we start with an integer greater than 0. A simple iteration then continually divides the decimal number by 2 and keeps track of the remainder. The first division by 2 gives information as to whether the value is even or odd. An even value will have a remainder of 0. It will have the digit 0 in the ones place. An odd value will have a remainder of 1 and will have the digit 1 in the ones place. We think about building our binary number as a sequence of digits; the first remainder we compute will actually be the last digit in the sequence. As shown in Figure 5, we again see the reversal property that signals that a stack is likely to be the appropriate data structure for solving the problem.
>

![../_images/dectobin.png](https://raw.githubusercontent.com/GMyhf/img/main/img/dectobin.png)

Figure 5: Decimal-to-Binary Conversion



```python
def divide_by_2(dec_num):
    rem_stack = [] # Stack()
    
    while dec_num > 0:
        rem  = dec_num % 2
        rem_stack.append(rem) # push(rem)
        dec_num = dec_num // 2
    
    bin_string = ""
    #while not rem_stack.is_empty():
    while rem_stack:
        bin_string = bin_string + str(rem_stack.pop())
        
    return bin_string

print(divide_by_2(233))

# output: 11101001
```



```python
def base_converter(dec_num, base):
    digits = "0123456789ABCDEF"
    
    rem_stack = [] # Stack()
    
    while dec_num > 0:
        rem = dec_num % base
        #rem_stack.push(rem)
        rem_stack.append(rem)
        dec_num = dec_num // base
        
    new_string = ""
    #while not rem_stack.is_empty():
    while rem_stack:
        new_string = new_string + digits[rem_stack.pop()]
        
    return new_string

print(base_converter(25, 2))
print(base_converter(2555, 16))

# 11001
# 9FB
```



#### ç»ƒä¹ OJ02734: åè¿›åˆ¶åˆ°å…«è¿›åˆ¶

http://cs101.openjudge.cn/practice/02734/

æŠŠä¸€ä¸ªåè¿›åˆ¶æ­£æ•´æ•°è½¬åŒ–æˆå…«è¿›åˆ¶ã€‚

**è¾“å…¥**

ä¸€è¡Œï¼Œä»…å«ä¸€ä¸ªåè¿›åˆ¶è¡¨ç¤ºçš„æ•´æ•°a(0 < a < 65536)ã€‚

**è¾“å‡º**

ä¸€è¡Œï¼Œaçš„å…«è¿›åˆ¶è¡¨ç¤ºã€‚

æ ·ä¾‹è¾“å…¥

`9`

æ ·ä¾‹è¾“å‡º

`11`



ä½¿ç”¨æ ˆæ¥å®ç°åè¿›åˆ¶åˆ°å…«è¿›åˆ¶çš„è½¬æ¢å¯ä»¥é€šè¿‡ä¸æ–­é™¤ä»¥8å¹¶å°†ä½™æ•°å‹å…¥æ ˆä¸­çš„æ–¹å¼æ¥å®ç°ã€‚ç„¶åï¼Œå°†æ ˆä¸­çš„å…ƒç´ ä¾æ¬¡å‡ºæ ˆï¼Œæ„æˆå…«è¿›åˆ¶æ•°çš„å„ä¸ªä½ã€‚

```python
decimal = int(input())  # è¯»å–åè¿›åˆ¶æ•°

# åˆ›å»ºä¸€ä¸ªç©ºæ ˆ
stack = []

# ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœè¾“å…¥çš„æ•°ä¸º0ï¼Œç›´æ¥è¾“å‡º0
if decimal == 0:
    print(0)
else:
    # ä¸æ–­é™¤ä»¥8ï¼Œå¹¶å°†ä½™æ•°å‹å…¥æ ˆä¸­
    while decimal > 0:
        remainder = decimal % 8
        stack.append(remainder)
        decimal = decimal // 8

    # ä¾æ¬¡å‡ºæ ˆï¼Œæ„æˆå…«è¿›åˆ¶æ•°çš„å„ä¸ªä½
    octal = ""
    while stack:
        octal += str(stack.pop())

    print(octal)
```



## 6.4 ä¸­åºã€å‰åºå’Œååºè¡¨è¾¾å¼

å½“ä½ å†™ä¸€ä¸ªç®—æœ¯è¡¨è¾¾å¼ï¼Œå¦‚ B * C æ—¶ï¼Œè¡¨è¾¾å¼çš„å½¢å¼ä¸ºä½ æä¾›äº†å¯ä»¥æ­£ç¡®è§£é‡Šå®ƒçš„ä¿¡æ¯ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çŸ¥é“å˜é‡ B æ­£åœ¨ä¹˜ä»¥å˜é‡ Cï¼Œå› ä¸ºä¹˜æ³•æ“ä½œç¬¦ * å‡ºç°åœ¨å®ƒä»¬ä¹‹é—´çš„è¡¨è¾¾å¼ä¸­ã€‚è¿™ç§ç±»å‹çš„è¡¨ç¤ºæ³•è¢«ç§°ä¸º**ä¸­ç¼€**è¡¨ç¤ºæ³•ï¼Œå› ä¸ºæ“ä½œç¬¦ä½äºå®ƒæ‰€æ“ä½œçš„ä¸¤ä¸ªæ“ä½œæ•°*ä¹‹é—´*ã€‚

è€ƒè™‘å¦ä¸€ä¸ªä¸­ç¼€çš„ä¾‹å­ï¼ŒA + B * Cã€‚æ“ä½œç¬¦ + å’Œ * ä»ç„¶å‡ºç°åœ¨æ“ä½œæ•°ä¹‹é—´ï¼Œä½†ç°åœ¨æœ‰ä¸€ä¸ªé—®é¢˜ï¼šå®ƒä»¬å„è‡ªä½œç”¨äºå“ªäº›æ“ä½œæ•°ï¼Ÿæ˜¯ + ä½œç”¨äº A å’Œ Bï¼Œè¿˜æ˜¯ * ä½œç”¨äº B å’Œ Cï¼Ÿè¿™ä¸ªè¡¨è¾¾å¼ä¼¼ä¹æœ‰æ­§ä¹‰ã€‚

å®é™…ä¸Šï¼Œä½ å·²ç»é˜…è¯»å’Œä¹¦å†™è¿™ç±»è¡¨è¾¾å¼å¾ˆé•¿æ—¶é—´äº†ï¼Œå¹¶ä¸”å®ƒä»¬å¹¶ä¸ä¼šç»™ä½ é€ æˆä»»ä½•é—®é¢˜ã€‚åŸå› æ˜¯ä½ äº†è§£å…³äºæ“ä½œç¬¦ + å’Œ * çš„ä¸€äº›äº‹æƒ…ã€‚æ¯ä¸ªæ“ä½œç¬¦éƒ½æœ‰ä¸€ä¸ª**ä¼˜å…ˆçº§**çº§åˆ«ã€‚ä¼˜å…ˆçº§è¾ƒé«˜çš„æ“ä½œç¬¦å…ˆäºä¼˜å…ˆçº§è¾ƒä½çš„æ“ä½œç¬¦ä½¿ç”¨ã€‚å”¯ä¸€èƒ½æ”¹å˜è¯¥é¡ºåºçš„æ˜¯æ‹¬å·çš„å­˜åœ¨ã€‚å¯¹äºç®—æœ¯æ“ä½œç¬¦çš„ä¼˜å…ˆçº§é¡ºåºå°†ä¹˜é™¤æ”¾åœ¨åŠ å‡ä¹‹ä¸Šã€‚å¦‚æœå‡ºç°ç›¸åŒä¼˜å…ˆçº§çš„æ“ä½œç¬¦ï¼Œåˆ™æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæˆ–ç»“åˆæ€§æ¥å†³å®šã€‚

è®©æˆ‘ä»¬ä½¿ç”¨æ“ä½œç¬¦ä¼˜å…ˆçº§æ¥è§£é‡Šä»¤äººå›°æƒ‘çš„è¡¨è¾¾å¼ A + B * Cã€‚é¦–å…ˆå¯¹ B å’Œ C è¿›è¡Œä¹˜æ³•è¿ç®—ï¼Œç„¶åå°† A åŠ åˆ°é‚£ä¸ªç»“æœä¸Šã€‚(A + B) * C å°†å¼ºåˆ¶å…ˆæ‰§è¡Œ A å’Œ B çš„åŠ æ³•è¿ç®—ï¼Œç„¶åå†è¿›è¡Œä¹˜æ³•è¿ç®—ã€‚åœ¨è¡¨è¾¾å¼ A + B + C ä¸­ï¼Œæ ¹æ®ä¼˜å…ˆçº§ï¼ˆé€šè¿‡ç»“åˆæ€§ï¼‰ï¼Œæœ€å·¦è¾¹çš„ + ä¼šé¦–å…ˆè¢«æ‰§è¡Œã€‚

å°½ç®¡è¿™ä¸€åˆ‡å¯¹ä½ æ¥è¯´å¯èƒ½æ˜¯æ˜¾è€Œæ˜“è§çš„ï¼Œè¯·è®°ä½è®¡ç®—æœºéœ€è¦ç¡®åˆ‡çŸ¥é“è¦æ‰§è¡Œä»€ä¹ˆæ“ä½œä»¥åŠå®ƒä»¬çš„é¡ºåºã€‚ä¸€ç§ç¡®ä¿ä¸ä¼šå› æ“ä½œé¡ºåºå¼•èµ·æ··æ·†çš„æ–¹å¼æ˜¯åˆ›å»ºæ‰€è°“çš„**å®Œå…¨æ‹¬å·åŒ–**è¡¨è¾¾å¼ã€‚è¿™ç§ç±»å‹çš„è¡¨è¾¾å¼ä¸ºæ¯ä¸ªæ“ä½œç¬¦ä½¿ç”¨ä¸€å¯¹æ‹¬å·ã€‚æ‹¬å·è§„å®šäº†æ“ä½œçš„é¡ºåºï¼›æ²¡æœ‰æ­§ä¹‰ã€‚ä¹Ÿä¸éœ€è¦è®°å¿†ä»»ä½•ä¼˜å…ˆçº§è§„åˆ™ã€‚

è¡¨è¾¾å¼ A + B * C + D å¯ä»¥é‡å†™ä¸º ((A + (B * C)) + D)ï¼Œä»¥æ˜¾ç¤ºé¦–å…ˆè¿›è¡Œä¹˜æ³•ï¼Œéšåæ˜¯æœ€å·¦è¾¹çš„åŠ æ³•ã€‚A + B + C + D å¯ä»¥å†™ä½œ (((A + B) + C) + D)ï¼Œå› ä¸ºåŠ æ³•æ“ä½œä»å·¦å‘å³ç»“åˆã€‚

è¿˜æœ‰ä¸¤ç§å…¶ä»–éå¸¸é‡è¦çš„è¡¨è¾¾å¼æ ¼å¼ï¼Œä¸€å¼€å§‹å¯èƒ½å¹¶ä¸æ˜æ˜¾ã€‚è€ƒè™‘ä¸­ç¼€è¡¨è¾¾å¼ A + Bã€‚å¦‚æœæˆ‘ä»¬æŠŠæ“ä½œç¬¦ç§»åˆ°ä¸¤ä¸ªæ“ä½œæ•°ä¹‹å‰ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿç”Ÿæˆçš„è¡¨è¾¾å¼å°†æ˜¯ + A Bã€‚åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ“ä½œç¬¦ç§»åˆ°æœ€åã€‚æˆ‘ä»¬å¾—åˆ° A B +ã€‚è¿™äº›çœ‹èµ·æ¥æœ‰ç‚¹å¥‡æ€ªã€‚

æ“ä½œç¬¦ç›¸å¯¹äºæ“ä½œæ•°ä½ç½®çš„è¿™äº›å˜åŒ–åˆ›é€ äº†ä¸¤ç§æ–°çš„è¡¨è¾¾å¼æ ¼å¼ï¼Œ**å‰ç¼€**å’Œ**åç¼€**ã€‚<mark>å‰ç¼€è¡¨è¾¾å¼è¦æ±‚æ‰€æœ‰æ“ä½œç¬¦éƒ½åœ¨å…¶å·¥ä½œçš„ä¸¤ä¸ªæ“ä½œæ•°ä¹‹å‰</mark>ã€‚è€Œåç¼€åˆ™è¦æ±‚å…¶æ“ä½œç¬¦åœ¨å…¶å¯¹åº”çš„æ“ä½œæ•°ä¹‹åã€‚æ›´å¤šçš„ä¾‹å­åº”è¯¥æœ‰åŠ©äºæ›´æ¸…æ™°åœ°ç†è§£è¿™ä¸€ç‚¹ã€‚

A + B * C åœ¨å‰ç¼€ä¸­ä¼šè¢«å†™ä½œ + A * B Cã€‚ä¹˜æ³•æ“ä½œç¬¦ç›´æ¥å‡ºç°åœ¨æ“ä½œæ•° B å’Œ C ä¹‹å‰ï¼Œè¡¨ç¤º * çš„ä¼˜å…ˆçº§é«˜äº +ã€‚ç„¶ååŠ æ³•æ“ä½œç¬¦å‡ºç°åœ¨ A å’Œä¹˜æ³•çš„ç»“æœä¹‹å‰ã€‚

åœ¨åç¼€ä¸­ï¼Œè¡¨è¾¾å¼ä¼šæ˜¯ A B C * +ã€‚å†æ¬¡ï¼Œæ“ä½œé¡ºåºè¢«ä¿ç•™ï¼Œå› ä¸º * ç´§æ¥åœ¨ B å’Œ C ä¹‹åå‡ºç°ï¼Œè¡¨æ˜ * æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ï¼Œéšåæ˜¯ +ã€‚è™½ç„¶æ“ä½œç¬¦ç§»åŠ¨äº†ï¼Œç°åœ¨è¦ä¹ˆå‡ºç°åœ¨å„è‡ªæ“ä½œæ•°ä¹‹å‰ï¼Œè¦ä¹ˆå‡ºç°åœ¨ä¹‹åï¼Œä½†æ“ä½œæ•°ä¹‹é—´çš„ç›¸å¯¹é¡ºåºä¿æŒä¸å˜ã€‚

> When you write an arithmetic expression such as B * C, the form of the expression provides you with information so that you can interpret it correctly. In this case we know that the variable B is being multiplied by the variable C since the multiplication operator * appears between them in the expression. This type of notation is referred to as **infix** since the operator is *in between* the two operands that it is working on.
>
> Consider another infix example, A + B * C. The operators + and * still appear between the operands, but there is a problem. Which operands do they work on? Does the + work on A and B or does the * take B and C? The expression seems ambiguous.
>
> In fact, you have been reading and writing these types of expressions for a long time and they do not cause you any problem. The reason for this is that you know something about the operators + and *. Each operator has a **precedence** level. Operators of higher precedence are used before operators of lower precedence. The only thing that can change that order is the presence of parentheses. The precedence order for arithmetic operators places multiplication and division above addition and subtraction. If two operators of equal precedence appear, then a left-to-right ordering or associativity is used.
>
> Letâ€™s interpret the troublesome expression A + B * C using operator precedence. B and C are multiplied first, and A is then added to that result. (A + B) * C would force the addition of A and B to be done first before the multiplication. In expression A + B + C, by precedence (via associativity), the leftmost + would be done first.
>
> Although all this may be obvious to you, remember that computers need to know exactly what operators to perform and in what order. One way to write an expression that guarantees there will be no confusion with respect to the order of operations is to create what is called a **fully parenthesized** expression. This type of expression uses one pair of parentheses for each operator. The parentheses dictate the order of operations; there is no ambiguity. There is also no need to remember any precedence rules.
>
> The expression A + B * C + D can be rewritten as ((A + (B * C)) + D) to show that the multiplication happens first, followed by the leftmost addition. A + B + C + D can be written as (((A + B) + C) + D) since the addition operations associate from left to right.
>
> There are two other very important expression formats that may not seem obvious to you at first. Consider the infix expression A + B. What would happen if we moved the operator before the two operands? The resulting expression would be + A B. Likewise, we could move the operator to the end. We would get A B +. These look a bit strange.
>
> These changes to the position of the operator with respect to the operands create two new expression formats, **prefix** and **postfix**. Prefix expression notation requires that all operators precede the two operands that they work on. Postfix, on the other hand, requires that its operators come after the corresponding operands. A few more examples should help to make this a bit clearer (see Table 2).
>
> A + B * C would be written as + A * B C in prefix. The multiplication operator comes immediately before the operands B and C, denoting that * has precedence over +. The addition operator then appears before the A and the result of the multiplication.
>
> In postfix, the expression would be A B C * +. Again, the order of operations is preserved since the * appears immediately after the B and the C, denoting that * has precedence, with + coming after. Although the operators moved and now appear either before or after their respective operands, the order of the operands stayed exactly the same relative to one another.
>

Table 2: Exmples of Infix, Prefix, and Postfix

| **Infix Expression** | **Prefix Expression** | **Postfix Expression** |
| :------------------- | :-------------------- | :--------------------- |
| A + B                | + A B                 | A B +                  |
| A + B * C            | + A * B C             | A B C * +              |

ç°åœ¨è€ƒè™‘ä¸­ç¼€è¡¨è¾¾å¼ (A + B) * Cã€‚å›æƒ³ä¸€ä¸‹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ<mark>ä¸­ç¼€</mark>è¦æ±‚ä½¿ç”¨æ‹¬å·ä»¥å¼ºåˆ¶åœ¨ä¹˜æ³•ä¹‹å‰æ‰§è¡ŒåŠ æ³•è¿ç®—ã€‚ç„¶è€Œï¼Œå½“æˆ‘ä»¬å°† A + B å†™æˆå‰ç¼€æ—¶ï¼Œåªéœ€å°†åŠ æ³•æ“ä½œç¬¦ç§»åˆ°æ“ä½œæ•°ä¹‹å‰ï¼Œå³ + A Bã€‚æ­¤æ“ä½œçš„ç»“æœæˆä¸ºä¹˜æ³•çš„ç¬¬ä¸€ä¸ªæ“ä½œæ•°ã€‚ç„¶åå°†ä¹˜æ³•æ“ä½œç¬¦ç§»åˆ°æ•´ä¸ªè¡¨è¾¾å¼çš„å‰é¢ï¼Œå¾—åˆ° * + A B Cã€‚åŒæ ·ï¼Œåœ¨åç¼€è¡¨è¾¾å¼ä¸­ï¼ŒA B + å¼ºåˆ¶å…ˆè¿›è¡ŒåŠ æ³•è¿ç®—ã€‚ç„¶åå¯ä»¥å°†ä¹˜æ³•åº”ç”¨äºè¯¥ç»“æœå’Œå‰©ä½™çš„æ“ä½œæ•° Cã€‚å› æ­¤ï¼Œæ­£ç¡®çš„åç¼€è¡¨è¾¾å¼æ˜¯ A B + C *ã€‚

å†æ¬¡è€ƒè™‘è¿™ä¸‰ä¸ªè¡¨è¾¾å¼ï¼ˆè§è¡¨3ï¼‰ã€‚è¿™é‡Œå‘ç”Ÿäº†ä¸€ä»¶éå¸¸é‡è¦çš„äº‹æƒ…ã€‚æ‹¬å·å»å“ªäº†ï¼Ÿä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨å‰ç¼€å’Œåç¼€ä¸­ä¸éœ€è¦å®ƒä»¬ï¼Ÿç­”æ¡ˆæ˜¯ï¼Œ<mark>æ“ä½œç¬¦ç›¸å¯¹äºå®ƒä»¬æ‰€æ“ä½œçš„æ“ä½œæ•°ä¸å†æœ‰æ­§ä¹‰</mark>ã€‚åªæœ‰ä¸­ç¼€è¡¨ç¤ºæ³•éœ€è¦é¢å¤–çš„ç¬¦å·ã€‚å‰ç¼€å’Œåç¼€è¡¨è¾¾å¼ä¸­çš„æ“ä½œé¡ºåºå®Œå…¨ç”±æ“ä½œç¬¦çš„ä½ç½®å†³å®šï¼Œè€Œä¸å—å…¶ä»–å› ç´ å½±å“ã€‚åœ¨å¾ˆå¤šæ–¹é¢ï¼Œè¿™ä½¿å¾—ä¸­ç¼€æˆä¸ºæœ€ä¸ç†æƒ³çš„è¡¨ç¤ºæ³•ã€‚

> Now consider the infix expression (A + B) * C. Recall that in this case, infix requires the parentheses to force the performance of the addition before the multiplication. However, when A + B was written in prefix, the addition operator was simply moved before the operands, + A B. The result of this operation becomes the first operand for the multiplication. The multiplication operator is moved in front of the entire expression, giving us * + A B C. Likewise, in postfix A B + forces the addition to happen first. The multiplication can be done to that result and the remaining operand C. The proper postfix expression is then A B + C *.
>
> Consider these three expressions again (see Table 3). Something very important has happened. Where did the parentheses go? Why donâ€™t we need them in prefix and postfix? The answer is that the operators are no longer ambiguous with respect to the operands that they work on. Only infix notation requires the additional symbols. The order of operations within prefix and postfix expressions is completely determined by the position of the operator and nothing else. In many ways, this makes infix the least desirable notation to use.
>



Table 3: An Expression with Parentheses

| **Infix Expression** | **Prefix Expression** | **Postfix Expression** |
| :------------------- | :-------------------- | :--------------------- |
| (A + B) * C          | * + A B C             | A B + C *              |

Table 4 shows some additional examples of infix expressions and the equivalent prefix and postfix expressions. Be sure that you understand how they are equivalent in terms of the order of the operations being performed.

Table 4: Additional Examples of Infix, Prefix and Postfix

| **Infix Expression** | **Prefix Expression** | **Postfix Expression** |
| :------------------- | :-------------------- | :--------------------- |
| A + B * C + D        | + + A * B C D         | A B C * + D +          |
| (A + B) * (C + D)    | * + A B + C D         | A B + C D + *          |
| A * B + C * D        | + * A B * C D         | A B * C D * +          |
| A + B + C + D        | + + + A B C D         | A B + C + D +          |



### 1 Conversion of Infix Expressions to Prefix and Postfix

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸´æ—¶çš„æ–¹æ³•åœ¨ä¸­ç¼€è¡¨è¾¾å¼å’Œç­‰ä»·çš„å‰ç¼€åŠåç¼€è¡¨è¾¾å¼è¡¨ç¤ºæ³•ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚æ­£å¦‚ä½ å¯èƒ½é¢„æœŸçš„é‚£æ ·ï¼Œå­˜åœ¨ç®—æ³•æ–¹æ³•å¯ä»¥æ‰§è¡Œè¿™ç§è½¬æ¢ï¼Œä½¿å¾—ä»»ä½•å¤æ‚åº¦çš„è¡¨è¾¾å¼éƒ½èƒ½è¢«æ­£ç¡®åœ°å˜æ¢ã€‚

æˆ‘ä»¬å°†é¦–å…ˆè€ƒè™‘çš„æŠ€æœ¯ä½¿ç”¨äº†ä¹‹å‰è®¨è®ºè¿‡çš„å®Œå…¨æ‹¬å·åŒ–è¡¨è¾¾å¼çš„æ¦‚å¿µã€‚å›æƒ³ä¸€ä¸‹ï¼ŒA + B * C å¯ä»¥å†™æˆ (A + (B * C)) æ¥æ˜ç¡®æ˜¾ç¤ºä¹˜æ³•ä¼˜å…ˆäºåŠ æ³•ã€‚ç„¶è€Œï¼Œä»”ç»†è§‚å¯Ÿåä½ å¯ä»¥çœ‹åˆ°ï¼Œ<mark>æ¯å¯¹æ‹¬å·ä¹Ÿæ ‡æ˜äº†ä¸€ä¸ªæ“ä½œæ•°å¯¹çš„å¼€å§‹å’Œç»“æŸ</mark>ï¼Œå…¶ä¸­é—´æ˜¯ç›¸åº”çš„æ“ä½œç¬¦ã€‚

çœ‹çœ‹ä¸Šé¢å­è¡¨è¾¾å¼ (B * C) ä¸­çš„å³æ‹¬å·ã€‚<mark>å¦‚æœæˆ‘ä»¬æŠŠä¹˜æ³•ç¬¦å·ç§»åˆ°è¯¥ä½ç½®å¹¶ç§»é™¤åŒ¹é…çš„å·¦æ‹¬å·</mark>ï¼Œå¾—åˆ° B C *ï¼Œå®é™…ä¸Šæˆ‘ä»¬å°±å°†å­è¡¨è¾¾å¼è½¬æ¢ä¸ºäº†åç¼€è¡¨ç¤ºæ³•ã€‚å¦‚æœä¹Ÿå°†åŠ æ³•æ“ä½œç¬¦ç§»åŠ¨åˆ°å…¶å¯¹åº”çš„å³æ‹¬å·ä½ç½®ï¼Œå¹¶ç§»é™¤åŒ¹é…çš„å·¦æ‹¬å·ï¼Œå°±ä¼šå¾—åˆ°å®Œæ•´çš„åç¼€è¡¨è¾¾å¼ï¼ˆè§å›¾6ï¼‰ã€‚ 

é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ç³»ç»Ÿåœ°å°†åŒ…å«ä»»æ„å¤æ‚åº¦çš„ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢ä¸ºåç¼€å½¢å¼ï¼Œç¡®ä¿äº†è½¬æ¢è¿‡ç¨‹çš„å‡†ç¡®æ€§å’Œä¸€è‡´æ€§ï¼Œè€Œæ— éœ€ä¾èµ–è®°å¿†æ“ä½œç¬¦ä¼˜å…ˆçº§è§„åˆ™ã€‚åŒæ ·çš„åŸåˆ™ä¹Ÿå¯åº”ç”¨äºåˆ›å»ºå‰ç¼€è¡¨è¾¾å¼ï¼Œåªæ˜¯æ“ä½œç¬¦çš„ä½ç½®ç›¸å¯¹äºæ“ä½œæ•°æœ‰æ‰€ä¸åŒã€‚

> So far, we have used ad hoc methods to convert between infix expressions and the equivalent prefix and postfix expression notations. As you might expect, there are algorithmic ways to perform the conversion that allow any expression of any complexity to be correctly transformed.
>
> The first technique that we will consider uses the notion of a fully parenthesized expression that was discussed earlier. Recall that A + B * C can be written as (A + (B * C)) to show explicitly that the multiplication has precedence over the addition. On closer observation, however, you can see that each parenthesis pair also denotes the beginning and the end of an operand pair with the corresponding operator in the middle.
>
> Look at the right parenthesis in the subexpression (B * C) above. If we were to move the multiplication symbol to that position and remove the matching left parenthesis, giving us B C *, we would in effect have converted the subexpression to postfix notation. If the addition operator were also moved to its corresponding right parenthesis position and the matching left parenthesis were removed, the complete postfix expression would result (see Figure 6).
>

![../_images/moveright.png](https://raw.githubusercontent.com/GMyhf/img/main/img/moveright.png)

<center>Figure 6: Moving Operators to the Right for Postfix Notation</center>

If we do the same thing but instead of moving the symbol to the position of the right parenthesis, we move it to the left, we get prefix notation (see Figure 7). The position of the parenthesis pair is actually a clue to the final position of the enclosed operator.

![../_images/moveleft.png](https://raw.githubusercontent.com/GMyhf/img/main/img/moveleft.png)

<center>Figure 7: Moving Operators to the Left for Prefix Notation</center>

å› æ­¤ï¼Œä¸ºäº†å°†ä¸€ä¸ªè¡¨è¾¾å¼ï¼ˆæ— è®ºå¤šä¹ˆå¤æ‚ï¼‰è½¬æ¢ä¸ºå‰ç¼€æˆ–åç¼€è¡¨ç¤ºæ³•ï¼Œé¦–å…ˆä½¿ç”¨è¿ç®—é¡ºåºå®Œå…¨åŠ ä¸Šæ‹¬å·ã€‚ç„¶åï¼Œ<mark>æ ¹æ®ä½ æƒ³è¦å¾—åˆ°å‰ç¼€è¿˜æ˜¯åç¼€è¡¨ç¤ºæ³•ï¼Œå°†æ‹¬å·å†…çš„æ“ä½œç¬¦ç§»åŠ¨åˆ°å·¦æ‹¬å·æˆ–å³æ‹¬å·çš„ä½ç½®</mark>ã€‚

> So in order to convert an expression, no matter how complex, to either prefix or postfix notation, fully parenthesize the expression using the order of operations. Then <mark>move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation</mark>.

Here is a more complex expression: (A + B) * C - (D - E) * (F + G). Figure 8 shows the conversion to postfix and prefix notations.

![../_images/complexmove.png](https://raw.githubusercontent.com/GMyhf/img/main/img/complexmove.png)

Figure 8: Converting a Complex Expression to Prefix and Postfix Notations



### 2 ä¸­ç¼€è½¬åç¼€ç®—æ³•Shunting Yard

æˆ‘ä»¬éœ€è¦å¼€å‘ä¸€ç§ç®—æ³•ï¼Œå°†ä»»ä½•ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢ä¸ºåç¼€è¡¨è¾¾å¼ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†æ›´ä»”ç»†åœ°è§‚å¯Ÿè½¬æ¢è¿‡ç¨‹ã€‚

å†æ¬¡è€ƒè™‘è¡¨è¾¾å¼ A + B * Cã€‚å¦‚ä¸Šæ‰€ç¤ºï¼Œå…¶å¯¹åº”çš„åç¼€è¡¨è¾¾å¼æ˜¯ A B C * +ã€‚æˆ‘ä»¬å·²ç»æ³¨æ„åˆ°æ“ä½œæ•° Aã€B å’Œ C ä¿æŒå®ƒä»¬çš„ç›¸å¯¹ä½ç½®ä¸å˜ã€‚<mark>åªæœ‰æ“ä½œç¬¦æ”¹å˜äº†ä½ç½®</mark>ã€‚è®©æˆ‘ä»¬å†æ¬¡æŸ¥çœ‹ä¸­ç¼€è¡¨è¾¾å¼ä¸­çš„æ“ä½œç¬¦ã€‚ä»å·¦åˆ°å³é¦–å…ˆå‡ºç°çš„æ“ä½œç¬¦æ˜¯ +ã€‚ç„¶è€Œï¼Œåœ¨åç¼€è¡¨è¾¾å¼ä¸­ï¼Œç”±äºä¸‹ä¸€ä¸ªæ“ä½œç¬¦ * çš„ä¼˜å…ˆçº§é«˜äºåŠ æ³•ï¼Œ+ è¢«æ”¾åœ¨äº†æœ€åã€‚åŸå§‹è¡¨è¾¾å¼ä¸­çš„æ“ä½œç¬¦é¡ºåºåœ¨å¾—åˆ°çš„åç¼€è¡¨è¾¾å¼ä¸­è¢«åè½¬äº†ã€‚

å½“æˆ‘ä»¬å¤„ç†è¡¨è¾¾å¼æ—¶ï¼Œç”±äºç›¸åº”çš„å³æ“ä½œæ•°è¿˜æœªå‡ºç°ï¼Œæ“ä½œç¬¦éœ€è¦æš‚æ—¶å­˜å‚¨åœ¨æŸå¤„ã€‚æ­¤å¤–ï¼Œè¿™äº›<mark>å·²ä¿å­˜çš„æ“ä½œç¬¦çš„é¡ºåºå¯èƒ½éœ€è¦æ ¹æ®å®ƒä»¬çš„ä¼˜å…ˆçº§è¿›è¡Œåè½¬</mark>ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­çš„åŠ æ³•å’Œä¹˜æ³•å°±æ˜¯è¿™ç§æƒ…å†µã€‚ç”±äºåŠ æ³•æ“ä½œç¬¦å‡ºç°åœ¨ä¹˜æ³•æ“ä½œç¬¦ä¹‹å‰ä¸”ä¼˜å…ˆçº§è¾ƒä½ï¼Œå®ƒéœ€è¦åœ¨ä¹˜æ³•æ“ä½œç¬¦ä¹‹åå‡ºç°ã€‚ç”±äºè¿™ç§<mark>é¡ºåºçš„åè½¬ï¼Œä½¿ç”¨æ ˆæ¥ä¿å­˜æ“ä½œç¬¦</mark>ç›´åˆ°éœ€è¦å®ƒä»¬ä¸ºæ­¢æ˜¯æœ‰æ„ä¹‰çš„ã€‚

é‚£ä¹ˆå¯¹äº (A + B) * C æ€ä¹ˆåŠå‘¢ï¼Ÿå›æƒ³ä¸€ä¸‹ï¼Œå…¶å¯¹åº”çš„åç¼€è¡¨è¾¾å¼æ˜¯ A B + C *ã€‚åŒæ ·ï¼Œä»å·¦åˆ°å³å¤„ç†è¿™ä¸ªä¸­ç¼€è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹åˆ°çš„æ˜¯ +ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå½“æˆ‘ä»¬çœ‹åˆ° * æ—¶ï¼Œç”±äºæ‹¬å·çš„ä½œç”¨ï¼Œ+ å·²ç»è¢«æ”¾ç½®åœ¨ç»“æœè¡¨è¾¾å¼ä¸­ï¼Œå› ä¸ºå®ƒå¯¹ * å…·æœ‰ä¼˜å…ˆæƒã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹<mark>äº†è§£è½¬æ¢ç®—æ³•çš„å·¥ä½œåŸç†</mark>äº†ã€‚å½“æˆ‘ä»¬çœ‹åˆ°ä¸€ä¸ªå·¦æ‹¬å·æ—¶ï¼Œæˆ‘ä»¬ä¼šå°†å…¶ä¿å­˜ä»¥æŒ‡ç¤ºå³å°†å‡ºç°ä¸€ä¸ªé«˜ä¼˜å…ˆçº§çš„æ“ä½œç¬¦ã€‚é‚£ä¸ªæ“ä½œç¬¦éœ€è¦ç­‰å¾…ç›´åˆ°å‡ºç°ç›¸åº”çš„å³æ‹¬å·æ¥æ ‡æ˜å®ƒçš„ä½ç½®ï¼ˆå›å¿†å®Œå…¨æ‹¬å·åŒ–çš„æ–¹æ³•ï¼‰ã€‚å½“å³æ‹¬å·å‡ºç°æ—¶ï¼Œæ“ä½œç¬¦å¯ä»¥ä»æ ˆä¸­å¼¹å‡ºã€‚

å½“æˆ‘ä»¬ä»å·¦åˆ°å³æ‰«æä¸­ç¼€è¡¨è¾¾å¼æ—¶ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªæ ˆæ¥ä¿å­˜æ“ä½œç¬¦ã€‚è¿™æä¾›äº†æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­æåˆ°çš„åè½¬ã€‚æ ˆé¡¶æ€»æ˜¯æœ€è¿‘ä¿å­˜çš„æ“ä½œç¬¦ã€‚æ¯å½“æˆ‘ä»¬<mark>è¯»å–ä¸€ä¸ªæ–°çš„æ“ä½œç¬¦æ—¶ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘è¯¥æ“ä½œç¬¦ä¸å·²ç»åœ¨æ ˆä¸Šçš„æ“ä½œç¬¦ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ç›¸æ¯”ï¼Œå…¶ä¼˜å…ˆçº§å¦‚ä½•</mark>ã€‚

å‡è®¾ä¸­ç¼€è¡¨è¾¾å¼æ˜¯ç”±ç©ºæ ¼åˆ†éš”çš„æ ‡è®°å­—ç¬¦ä¸²ã€‚æ“ä½œç¬¦æ ‡è®°åŒ…æ‹¬ *, /, + å’Œ -ï¼Œä»¥åŠå·¦å³æ‹¬å· ( å’Œ )ã€‚æ“ä½œæ•°æ ‡è®°æ˜¯å•å­—ç¬¦æ ‡è¯†ç¬¦ A, B, C ç­‰ç­‰ã€‚éµå¾ªä»¥ä¸‹æ­¥éª¤å¯ä»¥äº§ç”ŸæŒ‰åç¼€é¡ºåºæ’åˆ—çš„æ ‡è®°å­—ç¬¦ä¸²ï¼š

1. åˆ›å»ºä¸€ä¸ªåä¸º `opstack` çš„ç©ºæ ˆç”¨äºå­˜æ”¾æ“ä½œç¬¦ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨ç”¨äºè¾“å‡ºã€‚
2. ä½¿ç”¨å­—ç¬¦ä¸²æ–¹æ³• `split` å°†è¾“å…¥çš„ä¸­ç¼€å­—ç¬¦ä¸²è½¬æ¢æˆåˆ—è¡¨ã€‚
3. ä»å·¦åˆ°å³æ‰«ææ ‡è®°åˆ—è¡¨ï¼š
   - å¦‚æœæ ‡è®°æ˜¯æ“ä½œæ•°ï¼Œåˆ™å°†å…¶é™„åŠ åˆ°è¾“å‡ºåˆ—è¡¨çš„æœ«å°¾ã€‚
   - å¦‚æœæ ‡è®°æ˜¯å·¦æ‹¬å·ï¼Œåˆ™å°†å…¶å‹å…¥ `opstack` æ ˆä¸­ã€‚
   - å¦‚æœæ ‡è®°æ˜¯å³æ‹¬å·ï¼Œåˆ™ä» `opstack` ä¸­å¼¹å‡ºå…ƒç´ ç›´åˆ°ç§»é™¤ç›¸åº”çš„å·¦æ‹¬å·ä¸ºæ­¢ï¼Œå¹¶å°†æ¯ä¸ªæ“ä½œç¬¦é™„åŠ åˆ°è¾“å‡ºåˆ—è¡¨çš„æœ«å°¾ã€‚
   - å¦‚æœæ ‡è®°æ˜¯æ“ä½œç¬¦ *, /, + æˆ– -ï¼Œåˆ™å°†å…¶å‹å…¥ `opstack` æ ˆä¸­ã€‚ä½†æ˜¯ï¼Œé¦–å…ˆç§»é™¤å·²åœ¨ `opstack` ä¸Šä¸”å…·æœ‰æ›´é«˜æˆ–ç›¸åŒä¼˜å…ˆçº§çš„æ‰€æœ‰æ“ä½œç¬¦ï¼Œå¹¶å°†å®ƒä»¬é™„åŠ åˆ°è¾“å‡ºåˆ—è¡¨çš„æœ«å°¾ã€‚
4. å½“è¾“å…¥è¡¨è¾¾å¼è¢«å®Œå…¨å¤„ç†åï¼Œæ£€æŸ¥ `opstack`ã€‚æ ˆä¸Šä»»ä½•å‰©ä½™çš„æ“ä½œç¬¦éƒ½å¯ä»¥è¢«ç§»é™¤å¹¶é™„åŠ åˆ°è¾“å‡ºåˆ—è¡¨çš„æœ«å°¾ã€‚

> We need to develop an algorithm to convert any infix expression to a postfix expression. To do this we will look closer at the conversion process.
>
> Consider once again the expression A + B * C. As shown above, A B C * + is the postfix equivalent. We have already noted that the operands A, B, and C stay in their relative positions. It is only the operators that change position. Letâ€™s look again at the operators in the infix expression. The first operator that appears from left to right is +. However, in the postfix expression, + is at the end since the next operator, *, has precedence over addition. The order of the operators in the original expression is reversed in the resulting postfix expression.
>
> As we process the expression, the operators have to be saved somewhere since their corresponding right operands are not seen yet. Also, the order of these saved operators may need to be reversed due to their precedence. This is the case with the addition and the multiplication in this example. Since the addition operator comes before the multiplication operator and has lower precedence, it needs to appear after the multiplication operator is used. Because of this reversal of order, it makes sense to consider using a stack to keep the operators until they are needed.
>
> What about (A + B) * C? Recall that A B + C * is the postfix equivalent. Again, processing this infix expression from left to right, we see + first. In this case, when we see *, + has already been placed in the result expression because it has precedence over * by virtue of the parentheses. We can now start to see how the conversion algorithm will work. When we see a left parenthesis, we will save it to denote that another operator of high precedence will be coming. That operator will need to wait until the corresponding right parenthesis appears to denote its position (recall the fully parenthesized technique). When that right parenthesis does appear, the operator can be popped from the stack.
>
> As we scan the infix expression from left to right, we will use a stack to keep the operators. This will provide the reversal that we noted in the first example. The top of the stack will always be the most recently saved operator. Whenever we read a new operator, we will need to consider how that operator compares in precedence with the operators, if any, already on the stack.
>
> Assume the infix expression is a string of tokens delimited by spaces. The operator tokens are *, /, +, and -, along with the left and right parentheses, ( and ). The operand tokens are the single-character identifiers A, B, C, and so on. The following steps will produce a string of tokens in postfix order.
>
> 1. Create an empty stack called `opstack` for keeping operators. Create an empty list for output.
> 2. Convert the input infix string to a list by using the string method `split`.
> 3. Scan the token list from left to right.
>    - If the token is an operand, append it to the end of the output list.
>    - If the token is a left parenthesis, push it on the `opstack`.
>    - If the token is a right parenthesis, pop the `opstack` until the corresponding left parenthesis is removed. Append each operator to the end of the output list.
>    - If the token is an operator, *, /, +, or -, push it on the `opstack`. However, first remove any operators already on the `opstack` that have higher or equal precedence and append them to the output list.
> 4. When the input expression has been completely processed, check the `opstack`. Any operators still on the stack can be removed and appended to the end of the output list.
>



```python
def infixToPostfix(infixexpr):
    prec = {}
    prec["*"] = 3
    prec["/"] = 3
    prec["+"] = 2
    prec["-"] = 2
    prec["("] = 1
    opStack = [] # Stack()
    postfixList = []
    tokenList = infixexpr.split()

    for token in tokenList:
        if token in "ABCDEFGHIJKLMNOPQRSTUVWXYZ" or token in "0123456789":
            postfixList.append(token)
        elif token == '(':
            #opStack.push(token)
            opStack.append(token)
        elif token == ')':
            topToken = opStack.pop()
            while topToken != '(':
                postfixList.append(topToken)
                topToken = opStack.pop()
        else:
            #while (not opStack.is_empty()) and (prec[opStack.peek()] >= prec[token]):
            while opStack and (prec[opStack[-1]] >= prec[token]):
                postfixList.append(opStack.pop())
            #opStack.push(token)
            opStack.append(token)

    #while not opStack.is_empty():
    while opStack:
        postfixList.append(opStack.pop())
    return " ".join(postfixList)

print(infixToPostfix("A * B + C * D"))
print(infixToPostfix("( A + B ) * C - ( D - E ) * ( F + G )"))

print(infixToPostfix("( A + B ) * ( C + D )"))
print(infixToPostfix("( A + B ) * C"))
print(infixToPostfix("A + B * C"))

"""
A B * C D * +
A B + C * D E - F G + * -
A B + C D + *
A B + C *
A B C * +
"""
```



#### <mark>å…³äºæ ˆä½¿ç”¨çš„é‡è¦åŸåˆ™</mark>

ã€æå† é» 24å·¥å­¦é™¢ã€‘

1. **æ ˆçš„åŸºæœ¬ç”¨é€”æ˜¯ç”¨äºâ€œç­‰å¾…â€**ã€‚å…·ä½“æ¥è¯´ï¼Œå½“é‡åˆ°ä¸€æ¡æŒ‡ä»¤ï¼Œè€Œè¿™æ¡æŒ‡ä»¤çš„æ“ä½œä¾èµ–äºåç»­çš„æŒ‡ä»¤æ—¶ï¼Œå¯ä»¥é€‰æ‹©å°†è¿™æ¡æŒ‡ä»¤å…ˆå…¥æ ˆï¼Œâ€œç¨ä½œç­‰å¾…â€ï¼Œç›´åˆ°éå†åˆ°åé¢éƒ¨åˆ†äº†è§£åˆ°å…·ä½“å¦‚ä½•æ“ä½œåå†åˆ©ç”¨`pop`æ–¹æ³•å›è¿‡å¤´æ¥å¤„ç†è¯¥æŒ‡ä»¤ã€‚è¿™æ˜¯æ ˆä½¿ç”¨çš„æ€»ä½“åŸåˆ™ã€‚

2. **æ ˆä¸æ‹¬å·åŒ¹é…çš„å…³ç³»å¯†åˆ‡**ã€‚å¾ˆå¤šæ¶‰åŠæ ˆçš„é—®é¢˜éƒ½æ¶‰åŠåˆ°æ‹¬å·åŒ¹é…é—®é¢˜ï¼Œå…¶æ ¸å¿ƒåœ¨äºè¯†åˆ«ä¸€å¯¹æ‹¬å·å†…æ‰€åŒ…å«çš„å†…å®¹ã€‚è¿™æ—¶åŒæ ·å¯ä»¥åº”ç”¨ç¬¬ä¸€æ¡åŸåˆ™ã€‚å½“æˆ‘ä»¬é‡åˆ°å·¦æ‹¬å·æ—¶ï¼Œç”±äºä¸æ¸…æ¥šå®ƒå¯¹åº”çš„å³æ‹¬å·åœ¨å“ªé‡Œï¼Œæ‰€ä»¥å…ˆå°†å…¶å…¥æ ˆã€‚ç­‰åˆ°é‡åˆ°å³æ‹¬å·æ—¶ï¼Œå†å›å¤´æ‰¾åˆ°åŒ¹é…çš„å·¦æ‹¬å·ï¼Œå¹¶è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚

3. **ç†è§£æ ˆç›¸å…³é—®é¢˜æ—¶ï¼Œç ”ç©¶ç»™å®šç¤ºä¾‹éå¸¸é‡è¦**ã€‚åœ¨è§£å†³æ ˆç›¸å…³çš„é—®é¢˜ä¹‹å‰ï¼Œå…ˆå¤§è‡´ç ”ç©¶ä¸€ä¸‹ç»™å‡ºçš„ç¤ºä¾‹ï¼Œåˆ†æç­”æ¡ˆå’Œè¾“å…¥æ•°æ®ï¼ˆæˆ–ç§°â€œå¯†æ–‡â€ï¼‰ä¹‹é—´çš„å…³ç³»éå¸¸æœ‰å¸®åŠ©ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸­åºè¡¨è¾¾å¼è½¬ååºè¡¨è¾¾å¼çš„é¢˜ç›®ä¸­ï¼Œé€šè¿‡è§‚å¯Ÿè½¬æ¢åçš„ç»“æœå¯ä»¥å‘ç°æ•°å­—çš„é¡ºåºä¿æŒä¸å˜ï¼Œè€Œå¯¹äºæ¯ä¸€ä¸ªè¿ç®—å•å…ƒï¼Œç¬¦å·æ€»æ˜¯ä½äºæœ€åã€‚è¿™è¡¨æ˜ï¼šæ•°å­—ä¸éœ€è¦å…¥æ ˆï¼Œå› ä¸ºå®ƒä»¬çš„æ“ä½œä¸ä¾èµ–äºåç»­çš„æŒ‡ä»¤ï¼Œå¯ä»¥ç›´æ¥æ·»åŠ åˆ°ç»“æœä¸­ã€‚ç›¸åï¼Œè¿ç®—ç¬¦éœ€è¦å…¥æ ˆï¼Œå› ä¸ºæˆ‘ä»¬å°šæœªç¡®å®šè¯¥è¿ç®—ç¬¦æ‰€å±çš„è¿ç®—å•å…ƒå°†åœ¨ä½•å¤„ç»“æŸã€‚ä¸€æ—¦æ ¹æ®æŸäº›æ¡ä»¶åˆ¤æ–­å‡ºè¿ç®—å•å…ƒç»“æŸï¼Œå°±å¯ä»¥æœ‰åºåœ°å°†è¿ç®—ç¬¦ä»æ ˆä¸­å¼¹å‡ºï¼Œå¹¶åŠ å…¥åˆ°ç»“æœä¸­ã€‚



#### <mark>Shunting yard algorightm</mark>

Shunting yard algorightmï¼ˆè°ƒåº¦åœºç®—æ³•ï¼‰æ˜¯ä¸€ç§ç”¨äºå°†ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢ä¸ºåç¼€è¡¨è¾¾å¼çš„ç®—æ³•ã€‚å®ƒç”±è·å…°è®¡ç®—æœºç§‘å­¦å®¶ Edsger Dijkstra åœ¨1960å¹´ä»£æå‡ºï¼Œç”¨äºè§£æå’Œè®¡ç®—æ•°å­¦è¡¨è¾¾å¼ã€‚

![image-20240305142138853](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20240305142138853.png)

<mark>Shunting Yard ç®—æ³•çš„ä¸»è¦æ€æƒ³æ˜¯ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼ˆè¿ç®—ç¬¦æ ˆå’Œè¾“å‡ºæ ˆï¼‰æ¥å¤„ç†è¡¨è¾¾å¼çš„ç¬¦å·</mark>ã€‚ç®—æ³•æŒ‰ç…§è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å’Œç»“åˆæ€§ï¼Œå°†ç¬¦å·é€ä¸ªå¤„ç†å¹¶æ”¾ç½®åˆ°æ­£ç¡®çš„ä½ç½®ã€‚æœ€ç»ˆï¼Œè¾“å‡ºæ ˆä¸­çš„å…ƒç´ å°±æ˜¯è½¬æ¢åçš„åç¼€è¡¨è¾¾å¼ã€‚

ä»¥ä¸‹æ˜¯ Shunting Yard ç®—æ³•çš„åŸºæœ¬æ­¥éª¤ï¼š

1. åˆå§‹åŒ–è¿ç®—ç¬¦æ ˆå’Œè¾“å‡ºæ ˆä¸ºç©ºã€‚
2. ä»å·¦åˆ°å³éå†ä¸­ç¼€è¡¨è¾¾å¼çš„æ¯ä¸ªç¬¦å·ã€‚
   - å¦‚æœæ˜¯æ“ä½œæ•°ï¼ˆæ•°å­—ï¼‰ï¼Œåˆ™å°†å…¶æ·»åŠ åˆ°è¾“å‡ºæ ˆã€‚
   - å¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œåˆ™å°†å…¶æ¨å…¥è¿ç®—ç¬¦æ ˆã€‚
   - å¦‚æœæ˜¯è¿ç®—ç¬¦ï¼š
     - å¦‚æœè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å¤§äºè¿ç®—ç¬¦æ ˆé¡¶çš„è¿ç®—ç¬¦ï¼Œæˆ–è€…è¿ç®—ç¬¦æ ˆé¡¶æ˜¯å·¦æ‹¬å·ï¼Œåˆ™å°†å½“å‰è¿ç®—ç¬¦æ¨å…¥è¿ç®—ç¬¦æ ˆã€‚
     - å¦åˆ™ï¼Œå°†è¿ç®—ç¬¦æ ˆé¡¶çš„è¿ç®—ç¬¦å¼¹å‡ºå¹¶æ·»åŠ åˆ°è¾“å‡ºæ ˆä¸­ï¼Œç›´åˆ°æ»¡è¶³ä¸Šè¿°æ¡ä»¶ï¼ˆæˆ–è€…è¿ç®—ç¬¦æ ˆä¸ºç©ºï¼‰ã€‚
     - å°†å½“å‰è¿ç®—ç¬¦æ¨å…¥è¿ç®—ç¬¦æ ˆã€‚
   - å¦‚æœæ˜¯å³æ‹¬å·ï¼Œåˆ™å°†è¿ç®—ç¬¦æ ˆé¡¶çš„è¿ç®—ç¬¦å¼¹å‡ºå¹¶æ·»åŠ åˆ°è¾“å‡ºæ ˆä¸­ï¼Œç›´åˆ°é‡åˆ°å·¦æ‹¬å·ã€‚å°†å·¦æ‹¬å·å¼¹å‡ºä½†ä¸æ·»åŠ åˆ°è¾“å‡ºæ ˆä¸­ã€‚
3. å¦‚æœè¿˜æœ‰å‰©ä½™çš„è¿ç®—ç¬¦åœ¨è¿ç®—ç¬¦æ ˆä¸­ï¼Œå°†å®ƒä»¬ä¾æ¬¡å¼¹å‡ºå¹¶æ·»åŠ åˆ°è¾“å‡ºæ ˆä¸­ã€‚
4. è¾“å‡ºæ ˆä¸­çš„å…ƒç´ å°±æ˜¯è½¬æ¢åçš„åç¼€è¡¨è¾¾å¼ã€‚



##### ç»ƒä¹ OJ24591:ä¸­åºè¡¨è¾¾å¼è½¬ååºè¡¨è¾¾å¼

http://cs101.openjudge.cn/practice/24591/

ä¸­åºè¡¨è¾¾å¼æ˜¯è¿ç®—ç¬¦æ”¾åœ¨ä¸¤ä¸ªæ•°ä¸­é—´çš„è¡¨è¾¾å¼ã€‚ä¹˜ã€é™¤è¿ç®—ä¼˜å…ˆçº§é«˜äºåŠ å‡ã€‚å¯ä»¥ç”¨"()"æ¥æå‡ä¼˜å…ˆçº§ --- å°±æ˜¯å°å­¦ç”Ÿå†™çš„å››åˆ™ç®—æœ¯è¿ç®—è¡¨è¾¾å¼ã€‚ä¸­åºè¡¨è¾¾å¼å¯ç”¨å¦‚ä¸‹æ–¹å¼é€’å½’å®šä¹‰ï¼š

1ï¼‰ä¸€ä¸ªæ•°æ˜¯ä¸€ä¸ªä¸­åºè¡¨è¾¾å¼ã€‚è¯¥è¡¨è¾¾å¼çš„å€¼å°±æ˜¯æ•°çš„å€¼ã€‚

2) è‹¥aæ˜¯ä¸­åºè¡¨è¾¾å¼ï¼Œåˆ™"(a)"ä¹Ÿæ˜¯ä¸­åºè¡¨è¾¾å¼(å¼•å·ä¸ç®—)ï¼Œå€¼ä¸ºaçš„å€¼ã€‚
3) è‹¥a,bæ˜¯ä¸­åºè¡¨è¾¾å¼ï¼Œcæ˜¯è¿ç®—ç¬¦ï¼Œåˆ™"acb"æ˜¯ä¸­åºè¡¨è¾¾å¼ã€‚"acb"çš„å€¼æ˜¯å¯¹aå’Œbåšcè¿ç®—çš„ç»“æœï¼Œä¸”aæ˜¯å·¦æ“ä½œæ•°ï¼Œbæ˜¯å³æ“ä½œæ•°ã€‚

è¾“å…¥ä¸€ä¸ªä¸­åºè¡¨è¾¾å¼ï¼Œè¦æ±‚è½¬æ¢æˆä¸€ä¸ªååºè¡¨è¾¾å¼è¾“å‡ºã€‚

**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°n(n<100)ã€‚æ¥ä¸‹æ¥nè¡Œï¼Œæ¯è¡Œä¸€ä¸ªä¸­åºè¡¨è¾¾å¼ï¼Œæ•°å’Œè¿ç®—ç¬¦ä¹‹é—´æ²¡æœ‰ç©ºæ ¼ï¼Œé•¿åº¦ä¸è¶…è¿‡700ã€‚

**è¾“å‡º**

å¯¹æ¯ä¸ªä¸­åºè¡¨è¾¾å¼ï¼Œè¾“å‡ºè½¬æˆååºè¡¨è¾¾å¼åçš„ç»“æœã€‚ååºè¡¨è¾¾å¼çš„æ•°ä¹‹é—´ã€æ•°å’Œè¿ç®—ç¬¦ä¹‹é—´ç”¨ä¸€ä¸ªç©ºæ ¼åˆ†å¼€ã€‚

æ ·ä¾‹è¾“å…¥

```
3
7+8.3 
3+4.5*(7+2)
(3)*((3+4)*(2+3.5)/(4+5)) 
```

æ ·ä¾‹è¾“å‡º

```
7 8.3 +
3 4.5 7 2 + * +
3 3 4 + 2 3.5 + * 4 5 + / *
```

æ¥æº: Guo wei



<mark>æ¥æ”¶æµ®ç‚¹æ•°ï¼Œæ˜¯number bufferæŠ€å·§ã€‚</mark>

```python
def infix_to_postfix(expression):
    precedence = {'+':1, '-':1, '*':2, '/':2}
    stack = []
    postfix = []
    number = ''

    for char in expression:
        if char.isnumeric() or char == '.':
            number += char
        else:
            if number:
                num = float(number)
                postfix.append(int(num) if num.is_integer() else num)
                number = ''
            if char in '+-*/':
                while stack and stack[-1] in '+-*/' and precedence[char] <= precedence[stack[-1]]:
                    postfix.append(stack.pop())
                stack.append(char)
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    postfix.append(stack.pop())
                stack.pop()

    if number:
        num = float(number)
        postfix.append(int(num) if num.is_integer() else num)

    while stack:
        postfix.append(stack.pop())

    return ' '.join(str(x) for x in postfix)

n = int(input())
for _ in range(n):
    expression = input()
    print(infix_to_postfix(expression))
```



æ¥æ”¶æ•°æ®ï¼Œè¿˜å¯ä»¥ç”¨<mark>reå¤„ç†</mark>ã€‚

```python
# 24591:ä¸­åºè¡¨è¾¾å¼è½¬ååºè¡¨è¾¾å¼
# http://cs101.openjudge.cn/practice/24591/

def inp(s):
    #s=input().strip()
    import re
    s=re.split(r'([\(\)\+\-\*\/])',s)
    s=[item for item in s if item.strip()]
    return s

exp = "(3)*((3+4)*(2+3.5)/(4+5)) "
print(inp(exp))
```





### 3 Postfix Evaluation

ä½œä¸ºæ ˆçš„æœ€åä¸€ä¸ªç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†è€ƒè™‘å·²ç»å¤„äºåç¼€è¡¨ç¤ºæ³•ä¸­çš„è¡¨è¾¾å¼çš„æ±‚å€¼ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ ˆå†æ¬¡æˆä¸ºé¦–é€‰çš„æ•°æ®ç»“æ„ã€‚ç„¶è€Œï¼Œå½“ä½ <mark>æ‰«æåç¼€è¡¨è¾¾å¼æ—¶ï¼Œéœ€è¦ç­‰å¾…çš„æ˜¯æ“ä½œæ•°ï¼Œè€Œä¸æ˜¯åƒåœ¨ä¸Šè¿°è½¬æ¢ç®—æ³•ä¸­é‚£æ ·ç­‰å¾…æ“ä½œç¬¦</mark>ã€‚å¦ä¸€ç§æ€è€ƒè§£å†³æ–¹æ¡ˆçš„æ–¹å¼æ˜¯ï¼Œ<mark>æ¯å½“åœ¨è¾“å…¥ä¸­çœ‹åˆ°ä¸€ä¸ªæ“ä½œç¬¦æ—¶ï¼Œå°†ä¼šä½¿ç”¨æœ€è¿‘çš„ä¸¤ä¸ªæ“ä½œæ•°è¿›è¡Œæ±‚å€¼ã€‚</mark>

è¿™æ„å‘³ç€ï¼Œåœ¨è¯»å–åç¼€è¡¨è¾¾å¼çš„è¿‡ç¨‹ä¸­ï¼Œæ¯å½“ä½ é‡åˆ°ä¸€ä¸ªæ“ä½œæ•°ï¼Œå°±å°†å…¶å‹å…¥æ ˆä¸­ã€‚ä¸€æ—¦é‡åˆ°æ“ä½œç¬¦ï¼Œå°±ä»æ ˆä¸­å¼¹å‡ºé€‚å½“æ•°é‡çš„æ“ä½œæ•°ï¼ˆå¯¹äºäºŒå…ƒæ“ä½œç¬¦æ¥è¯´æ˜¯ä¸¤ä¸ªï¼‰ï¼Œæ‰§è¡Œç›¸åº”çš„è®¡ç®—ï¼Œå¹¶å°†ç»“æœå‹å›åˆ°æ ˆä¸­ã€‚è¿™ä¸ªè¿‡ç¨‹ä¼šä¸€ç›´æŒç»­åˆ°è¡¨è¾¾å¼çš„æœ«å°¾ï¼Œæœ€ç»ˆæ ˆé¡¶å…ƒç´ å°±æ˜¯æ•´ä¸ªè¡¨è¾¾å¼çš„è®¡ç®—ç»“æœã€‚è¿™ç§æ–¹æ³•ç®€æ´è€Œæœ‰æ•ˆåœ°è§£å†³äº†åç¼€è¡¨è¾¾å¼çš„æ±‚å€¼é—®é¢˜ï¼Œå› ä¸ºå®ƒå……åˆ†åˆ©ç”¨äº†æ ˆçš„åè¿›å…ˆå‡ºç‰¹æ€§æ¥ç®¡ç†æ“ä½œæ•°å’Œæ“ä½œç¬¦çš„é¡ºåºã€‚

> As a final stack example, we will consider the evaluation of an expression that is already in postfix notation. In this case, a stack is again the data structure of choice. However, as you scan the postfix expression, it is the operands that must wait, not the operators as in the conversion algorithm above. Another way to think about the solution is that whenever an operator is seen on the input, the two most recent operands will be used in the evaluation.

```python
def postfixEval(postfixExpr):
    operandStack = []
    tokenList = postfixExpr.split()

    for token in tokenList:
        if token in "0123456789":
            operandStack.append(int(token))
        else:
            operand2 = operandStack.pop()
            operand1 = operandStack.pop()
            result = doMath(token,operand1,operand2)
            operandStack.append(result)
    return operandStack.pop()

def doMath(op, op1, op2):
    if op == "*":
        return op1 * op2
    elif op == "/":
        return op1 / op2
    elif op == "+":
        return op1 + op2
    else:
        return op1 - op2

print(postfixEval('7 8 + 3 2 + /'))

# output: 3.0
```



#### ç¤ºä¾‹OJ24588: ååºè¡¨è¾¾å¼æ±‚å€¼

http://cs101.openjudge.cn/practice/24588/

ååºè¡¨è¾¾å¼ç”±æ“ä½œæ•°å’Œè¿ç®—ç¬¦æ„æˆã€‚æ“ä½œæ•°æ˜¯æ•´æ•°æˆ–å°æ•°ï¼Œè¿ç®—ç¬¦æœ‰ + - * / å››ç§ï¼Œå…¶ä¸­ * / ä¼˜å…ˆçº§é«˜äº + -ã€‚ååºè¡¨è¾¾å¼å¯ç”¨å¦‚ä¸‹æ–¹å¼é€’å½’å®šä¹‰ï¼š

1) ä¸€ä¸ªæ“ä½œæ•°æ˜¯ä¸€ä¸ªååºè¡¨è¾¾å¼ã€‚è¯¥è¡¨è¾¾å¼çš„å€¼å°±æ˜¯æ“ä½œæ•°çš„å€¼ã€‚
2) è‹¥a,bæ˜¯ååºè¡¨è¾¾å¼ï¼Œcæ˜¯è¿ç®—ç¬¦ï¼Œåˆ™"a b c"æ˜¯ååºè¡¨è¾¾å¼ã€‚â€œa b câ€çš„å€¼æ˜¯ (a) c (b),å³å¯¹aå’Œbåšcè¿ç®—ï¼Œä¸”aæ˜¯ç¬¬ä¸€ä¸ªæ“ä½œæ•°ï¼Œbæ˜¯ç¬¬äºŒä¸ªæ“ä½œæ•°ã€‚ä¸‹é¢æ˜¯ä¸€äº›ååºè¡¨è¾¾å¼åŠå…¶å€¼çš„ä¾‹å­(æ“ä½œæ•°ã€è¿ç®—ç¬¦ä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”)ï¼š

3.4       å€¼ä¸ºï¼š3.4
5        å€¼ä¸ºï¼š5
5 3.4 +     å€¼ä¸ºï¼š5 + 3.4
5 3.4 + 6 /   å€¼ä¸ºï¼š(5+3.4)/6
5 3.4 + 6 * 3 + å€¼ä¸ºï¼š(5+3.4)*6+3



**è¾“å…¥**

ç¬¬ä¸€è¡Œæ˜¯æ•´æ•°n(n<100)ï¼Œæ¥ä¸‹æ¥æœ‰nè¡Œï¼Œæ¯è¡Œæ˜¯ä¸€ä¸ªååºè¡¨è¾¾å¼ï¼Œé•¿åº¦ä¸è¶…è¿‡1000ä¸ªå­—ç¬¦

**è¾“å‡º**

å¯¹æ¯ä¸ªååºè¡¨è¾¾å¼ï¼Œè¾“å‡ºå…¶å€¼ï¼Œä¿ç•™å°æ•°ç‚¹åé¢2ä½

æ ·ä¾‹è¾“å…¥

```
3
5 3.4 +
5 3.4 + 6 /
5 3.4 + 6 * 3 +
```

æ ·ä¾‹è¾“å‡º

```
8.40
1.40
53.40
```

æ¥æº: Guo wei



è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦ç†è§£å¦‚ä½•è®¡ç®—ååºè¡¨è¾¾å¼ã€‚ååºè¡¨è¾¾å¼çš„è®¡ç®—å¯ä»¥é€šè¿‡ä½¿ç”¨ä¸€ä¸ªæ ˆæ¥å®Œæˆï¼ŒæŒ‰ç…§ä»¥ä¸‹æ­¥éª¤ï¼š

1. ä»å·¦åˆ°å³æ‰«æååºè¡¨è¾¾å¼ã€‚
2. é‡åˆ°æ•°å­—æ—¶ï¼Œå°†å…¶å‹å…¥æ ˆä¸­ã€‚
3. é‡åˆ°è¿ç®—ç¬¦æ—¶ï¼Œä»æ ˆä¸­å¼¹å‡ºä¸¤ä¸ªæ•°å­—ï¼Œå…ˆå¼¹å‡ºçš„æ˜¯å³æ“ä½œæ•°ï¼Œåå¼¹å‡ºçš„æ˜¯å·¦æ“ä½œæ•°ã€‚å°†è¿™ä¸¤ä¸ªæ•°å­—è¿›è¡Œç›¸åº”çš„è¿ç®—ï¼Œç„¶åå°†ç»“æœå‹å…¥æ ˆä¸­ã€‚
4. å½“è¡¨è¾¾å¼æ‰«æå®Œæ¯•æ—¶ï¼Œæ ˆé¡¶çš„æ•°å­—å°±æ˜¯è¡¨è¾¾å¼çš„ç»“æœã€‚

```python
def evaluate_postfix(expression):
    stack = []
    tokens = expression.split()
    
    for token in tokens:
        if token in '+-*/':
            # å¼¹å‡ºæ ˆé¡¶çš„ä¸¤ä¸ªå…ƒç´ 
            right_operand = stack.pop()
            left_operand = stack.pop()
            # æ‰§è¡Œè¿ç®—
            if token == '+':
                stack.append(left_operand + right_operand)
            elif token == '-':
                stack.append(left_operand - right_operand)
            elif token == '*':
                stack.append(left_operand * right_operand)
            elif token == '/':
                stack.append(left_operand / right_operand)
        else:
            # å°†æ“ä½œæ•°è½¬æ¢ä¸ºæµ®ç‚¹æ•°åå…¥æ ˆ
            stack.append(float(token))
    
    # æ ˆé¡¶å…ƒç´ å°±æ˜¯è¡¨è¾¾å¼çš„ç»“æœ
    return stack[0]

# è¯»å–è¾“å…¥è¡Œæ•°
n = int(input())

# å¯¹æ¯ä¸ªååºè¡¨è¾¾å¼æ±‚å€¼
for _ in range(n):
    expression = input()
    result = evaluate_postfix(expression)
    # è¾“å‡ºç»“æœï¼Œä¿ç•™ä¸¤ä½å°æ•°
    print(f"{result:.2f}")
```

è¿™ä¸ªç¨‹åºå°†è¯»å–è¾“å…¥è¡Œæ•°ï¼Œç„¶åå¯¹æ¯è¡Œè¾“å…¥çš„ååºè¡¨è¾¾å¼æ±‚å€¼ï¼Œå¹¶æŒ‰è¦æ±‚ä¿ç•™ä¸¤ä½å°æ•°è¾“å‡ºç»“æœã€‚



## 6.5 ç»å…¸å…«çš‡åç”¨å›æº¯æˆ–è€…æ ˆå®ç°

### ç¤ºä¾‹OJ02754: å…«çš‡å

dfs and similar, http://cs101.openjudge.cn/practice/02754

ä¼šä¸‹å›½é™…è±¡æ£‹çš„äººéƒ½å¾ˆæ¸…æ¥šï¼šçš‡åå¯ä»¥åœ¨æ¨ªã€ç«–ã€æ–œçº¿ä¸Šä¸é™æ­¥æ•°åœ°åƒæ‰å…¶ä»–æ£‹å­ã€‚å¦‚ä½•å°†8ä¸ªçš‡åæ”¾åœ¨æ£‹ç›˜ä¸Šï¼ˆæœ‰8 * 8ä¸ªæ–¹æ ¼ï¼‰ï¼Œä½¿å®ƒä»¬è°ä¹Ÿä¸èƒ½è¢«åƒæ‰ï¼è¿™å°±æ˜¯è‘—åçš„å…«çš‡åé—®é¢˜ã€‚
å¯¹äºæŸä¸ªæ»¡è¶³è¦æ±‚çš„8çš‡åçš„æ‘†æ”¾æ–¹æ³•ï¼Œå®šä¹‰ä¸€ä¸ªçš‡åä¸²aä¸ä¹‹å¯¹åº”ï¼Œå³$a=b_1b_2...b_8~$,å…¶ä¸­$b_i$ä¸ºç›¸åº”æ‘†æ³•ä¸­ç¬¬iè¡Œçš‡åæ‰€å¤„çš„åˆ—æ•°ã€‚å·²ç»çŸ¥é“8çš‡åé—®é¢˜ä¸€å…±æœ‰92ç»„è§£ï¼ˆå³92ä¸ªä¸åŒçš„çš‡åä¸²ï¼‰ã€‚
ç»™å‡ºä¸€ä¸ªæ•°bï¼Œè¦æ±‚è¾“å‡ºç¬¬bä¸ªä¸²ã€‚ä¸²çš„æ¯”è¾ƒæ˜¯è¿™æ ·çš„ï¼šçš‡åä¸²xç½®äºçš‡åä¸²yä¹‹å‰ï¼Œå½“ä¸”ä»…å½“å°†xè§†ä¸ºæ•´æ•°æ—¶æ¯”yå°ã€‚

â€‹	å…«çš‡åæ˜¯ä¸€ä¸ªå¤è€çš„ç»å…¸é—®é¢˜ï¼š**å¦‚ä½•åœ¨ä¸€å¼ å›½é™…è±¡æ£‹çš„æ£‹ç›˜ä¸Šï¼Œæ‘†æ”¾8ä¸ªçš‡åï¼Œä½¿å…¶ä»»æ„ä¸¤ä¸ªçš‡åäº’ç›¸ä¸å—æ”»å‡»ã€‚**è¯¥é—®é¢˜ç”±ä¸€ä½å¾·å›½**å›½é™…è±¡æ£‹æ’å±€å®¶** **Max Bezzel** äº 1848å¹´æå‡ºã€‚ä¸¥æ ¼æ¥è¯´ï¼Œé‚£ä¸ªå¹´ä»£ï¼Œè¿˜æ²¡æœ‰â€œå¾·å›½â€è¿™ä¸ªå›½å®¶ï¼Œå½¼æ—¶ç§°ä½œâ€œæ™®é²å£«â€ã€‚1850å¹´ï¼Œ**Franz Nauck** ç»™å‡ºäº†ç¬¬ä¸€ä¸ªè§£ï¼Œå¹¶å°†å…¶æ‰©å±•æˆäº†â€œ **nçš‡å** â€é—®é¢˜ï¼Œå³**åœ¨ä¸€å¼  n** x **n çš„æ£‹ç›˜ä¸Šï¼Œå¦‚ä½•æ‘†æ”¾ n ä¸ªçš‡åï¼Œä½¿å…¶ä¸¤ä¸¤äº’ä¸æ”»å‡»**ã€‚å†å²ä¸Šï¼Œå…«çš‡åé—®é¢˜æ›¾æƒŠåŠ¨è¿‡â€œæ•°å­¦ç‹å­â€é«˜æ–¯(Gauss)ï¼Œè€Œä¸”æ­£æ˜¯ Franz Nauck å†™ä¿¡æ‰¾é«˜æ–¯è¯·æ•™çš„ã€‚

**è¾“å…¥**

ç¬¬1è¡Œæ˜¯æµ‹è¯•æ•°æ®çš„ç»„æ•°nï¼Œåé¢è·Ÿç€nè¡Œè¾“å…¥ã€‚æ¯ç»„æµ‹è¯•æ•°æ®å 1è¡Œï¼ŒåŒ…æ‹¬ä¸€ä¸ªæ­£æ•´æ•°b(1 â‰¤â€‰ b â‰¤â€‰ 92)

**è¾“å‡º**

è¾“å‡ºæœ‰nè¡Œï¼Œæ¯è¡Œè¾“å‡ºå¯¹åº”ä¸€ä¸ªè¾“å…¥ã€‚è¾“å‡ºåº”æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ˜¯å¯¹åº”äºbçš„çš‡åä¸²ã€‚

æ ·ä¾‹è¾“å…¥

```
2
1
92
```

æ ·ä¾‹è¾“å‡º

```
15863724
84136275
```



å…ˆç»™å‡ºä¸¤ä¸ªdfså›æº¯å®ç°çš„å…«çš‡åï¼Œæ¥ç€ç»™å‡ºä¸¤ä¸ªstackè¿­ä»£å®ç°çš„å…«çš‡åã€‚

å…«çš‡åæ€è·¯ï¼šå›æº¯ç®—æ³•é€šè¿‡å°è¯•ä¸åŒçš„é€‰æ‹©ï¼Œé€æ­¥æ„å»ºè§£å†³æ–¹æ¡ˆï¼Œå¹¶åœ¨è¾¾åˆ°æŸä¸ªæ¡ä»¶æ—¶è¿›è¡Œå›æº¯ï¼Œä»¥æ‰¾åˆ°æ‰€æœ‰çš„è§£å†³æ–¹æ¡ˆã€‚ä»ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—å¼€å§‹æ”¾ç½®çš‡åï¼Œç„¶ååœ¨æ¯ä¸€è¡Œçš„ä¸åŒåˆ—éƒ½æ”¾ç½®ï¼Œå¦‚æœä¸å‰é¢ä¸å†²çªå°±ç»§ç»­ï¼Œæœ‰å†²çªåˆ™å›åˆ°ä¸Šä¸€è¡Œç»§ç»­ä¸‹ä¸€ä¸ªå¯èƒ½æ€§ã€‚

```python
def solve_n_queens(n):
    solutions = []  # å­˜å‚¨æ‰€æœ‰è§£å†³æ–¹æ¡ˆçš„åˆ—è¡¨
    queens = [-1] * n  # å­˜å‚¨æ¯ä¸€è¡Œçš‡åæ‰€åœ¨çš„åˆ—æ•°
    
    def backtrack(row):
        if row == n:  # æ‰¾åˆ°ä¸€ä¸ªåˆæ³•è§£å†³æ–¹æ¡ˆ
            solutions.append(queens.copy())
        else:
            for col in range(n):
                if is_valid(row, col):  # æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åˆæ³•
                    queens[row] = col  # åœ¨å½“å‰è¡Œæ”¾ç½®çš‡å
                    backtrack(row + 1)  # é€’å½’å¤„ç†ä¸‹ä¸€è¡Œ
                    queens[row] = -1  # å›æº¯ï¼Œæ’¤é”€å½“å‰è¡Œçš„é€‰æ‹©
    
    def is_valid(row, col):
        for r in range(row):
            if queens[r] == col or abs(row - r) == abs(col - queens[r]):
                return False
        return True
    
    backtrack(0)  # ä»ç¬¬ä¸€è¡Œå¼€å§‹å›æº¯
    
    return solutions


# è·å–ç¬¬ b ä¸ªçš‡åä¸²
def get_queen_string(b):
    solutions = solve_n_queens(8)
    if b > len(solutions):
        return None
    queen_string = ''.join(str(col + 1) for col in solutions[b - 1])
    return queen_string


test_cases = int(input())  # è¾“å…¥çš„æµ‹è¯•æ•°æ®ç»„æ•°
for _ in range(test_cases):
    b = int(input())  # è¾“å…¥çš„ b å€¼
    queen_string = get_queen_string(b)
    print(queen_string)
```



```python
def is_safe(board, row, col):
    # æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦å®‰å…¨
    # æ£€æŸ¥åŒä¸€åˆ—æ˜¯å¦æœ‰çš‡å
    for i in range(row):
        if board[i] == col:
            return False
    # æ£€æŸ¥å·¦ä¸Šæ–¹æ˜¯å¦æœ‰çš‡å
    i = row - 1
    j = col - 1
    while i >= 0 and j >= 0:
        if board[i] == j:
            return False
        i -= 1
        j -= 1
    # æ£€æŸ¥å³ä¸Šæ–¹æ˜¯å¦æœ‰çš‡å
    i = row - 1
    j = col + 1
    while i >= 0 and j < 8:
        if board[i] == j:
            return False
        i -= 1
        j += 1
    return True

def queen_dfs(board, row):
    if row == 8:
        # æ‰¾åˆ°ç¬¬bä¸ªè§£ï¼Œå°†è§£å­˜å‚¨åˆ°resultåˆ—è¡¨ä¸­
        ans.append(''.join([str(x+1) for x in board]))
        return
    for col in range(8):
        if is_safe(board, row, col):
            # å½“å‰ä½ç½®å®‰å…¨ï¼Œæ”¾ç½®çš‡å
            board[row] = col
            # ç»§ç»­é€’å½’æ”¾ç½®ä¸‹ä¸€è¡Œçš„çš‡å
            queen_dfs(board, row + 1)
            # å›æº¯ï¼Œæ’¤é”€å½“å‰ä½ç½®çš„çš‡å
            board[row] = 0

ans = []
queen_dfs([None]*8, 0)
#print(ans)
for _ in range(int(input())):
    print(ans[int(input()) - 1])
```



å¦‚æœè¦ä½¿ç”¨æ ˆæ¥å®ç°å…«çš‡åé—®é¢˜ï¼Œå¯ä»¥é‡‡ç”¨è¿­ä»£çš„æ–¹å¼ï¼Œæ¨¡æ‹Ÿé€’å½’çš„è¿‡ç¨‹ã€‚åœ¨æ¯ä¸€æ­¥è¿­ä»£ä¸­ï¼Œä½¿ç”¨æ ˆæ¥ä¿å­˜çŠ¶æ€ï¼Œå¹¶æ ¹æ®è§„åˆ™è¿›è¡Œæ¨è¿›å’Œå›æº¯ã€‚

```python
def queen_stack(n):
    stack = []  # ç”¨äºä¿å­˜çŠ¶æ€çš„æ ˆ
    solutions = [] # å­˜å‚¨æ‰€æœ‰è§£å†³æ–¹æ¡ˆçš„åˆ—è¡¨

    stack.append((0, []))  # åˆå§‹çŠ¶æ€ä¸ºç¬¬ä¸€è¡Œï¼Œæ‰€æœ‰åˆ—éƒ½æœªæ”¾ç½®çš‡å,æ ˆä¸­çš„å…ƒç´ æ˜¯ (row, queens) çš„å…ƒç»„

    while stack:
        row, cols = stack.pop() # ä»æ ˆä¸­å–å‡ºå½“å‰å¤„ç†çš„è¡Œæ•°å’Œå·²æ”¾ç½®çš„çš‡åä½ç½®
        if row == n:    # æ‰¾åˆ°ä¸€ä¸ªåˆæ³•è§£å†³æ–¹æ¡ˆ
            solutions.append(cols)
        else:
            for col in range(n):
                if is_valid(row, col, cols): # æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åˆæ³•
                    stack.append((row + 1, cols + [col]))

    return solutions

def is_valid(row, col, queens):
    for r in range(row):
        if queens[r] == col or abs(row - r) == abs(col - queens[r]):
            return False
    return True


# è·å–ç¬¬ b ä¸ªçš‡åä¸²
def get_queen_string(b):
    solutions = queen_stack(8)
    if b > len(solutions):
        return None
    b = len(solutions) + 1 - b

    queen_string = ''.join(str(col + 1) for col in solutions[b - 1])
    return queen_string

test_cases = int(input())  # è¾“å…¥çš„æµ‹è¯•æ•°æ®ç»„æ•°
for _ in range(test_cases):
    b = int(input())  # è¾“å…¥çš„ b å€¼
    queen_string = get_queen_string(b)
    print(queen_string)
```



```python
def solve_n_queens(n):
    stack = []  # ç”¨äºä¿å­˜çŠ¶æ€çš„æ ˆ
    solutions = []  # å­˜å‚¨æ‰€æœ‰è§£å†³æ–¹æ¡ˆçš„åˆ—è¡¨

    stack.append((0, [-1] * n))  # åˆå§‹çŠ¶æ€ä¸ºç¬¬ä¸€è¡Œï¼Œæ‰€æœ‰åˆ—éƒ½æœªæ”¾ç½®çš‡å

    while stack:
        row, queens = stack.pop()

        if row == n:  # æ‰¾åˆ°ä¸€ä¸ªåˆæ³•è§£å†³æ–¹æ¡ˆ
            solutions.append(queens.copy())
        else:
            for col in range(n):
                if is_valid(row, col, queens):  # æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åˆæ³•
                    new_queens = queens.copy()
                    new_queens[row] = col  # åœ¨å½“å‰è¡Œæ”¾ç½®çš‡å
                    stack.append((row + 1, new_queens))  # æ¨è¿›åˆ°ä¸‹ä¸€è¡Œ

    return solutions


def is_valid(row, col, queens):
    for r in range(row):
        if queens[r] == col or abs(row - r) == abs(col - queens[r]):
            return False
    return True


# è·å–ç¬¬ b ä¸ªçš‡åä¸²
def get_queen_string(b):
    solutions = solve_n_queens(8)
    if b > len(solutions):
        return None
    b = len(solutions) + 1 - b

    queen_string = ''.join(str(col + 1) for col in solutions[b - 1])
    return queen_string


test_cases = int(input())  # è¾“å…¥çš„æµ‹è¯•æ•°æ®ç»„æ•°
for _ in range(test_cases):
    b = int(input())  # è¾“å…¥çš„ b å€¼
    queen_string = get_queen_string(b)
    print(queen_string)

```



# 7 The Queue Abstract Data Type

åƒæ ˆä¸€æ ·ï¼Œé˜Ÿåˆ—ä¹Ÿæ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œå®ƒä»¥å…ˆå…¥å…ˆå‡ºï¼ˆFIFO, First In First Outï¼‰çš„æ–¹å¼å­˜å‚¨é¡¹ç›®ã€‚åœ¨é˜Ÿåˆ—ä¸­ï¼Œæœ€æ—©æ·»åŠ çš„é¡¹ä¼šæœ€å…ˆè¢«ç§»é™¤ã€‚é˜Ÿåˆ—çš„ä¸€ä¸ªå¾ˆå¥½çš„<mark>ä¾‹å­æ˜¯èµ„æºçš„æ¶ˆè´¹è€…é˜Ÿåˆ—</mark>ï¼Œå…¶ä¸­æœ€æ—©æ¥çš„æ¶ˆè´¹è€…ä¼šè¢«ä¼˜å…ˆæœåŠ¡ã€‚è¿™æ„å‘³ç€ï¼Œé˜Ÿåˆ—ä¸­çš„å…ƒç´ æŒ‰ç…§å®ƒä»¬è¿›å…¥çš„é¡ºåºè¿›è¡Œå¤„ç†ï¼Œç¡®ä¿äº†ç¬¬ä¸€ä¸ªè¿›å…¥é˜Ÿåˆ—çš„å…ƒç´ ä¹Ÿæ˜¯ç¬¬ä¸€ä¸ªä»é˜Ÿåˆ—ä¸­å‡ºæ¥çš„ï¼Œä½“ç°äº†â€œå…ˆåˆ°å…ˆå¾—â€çš„åŸåˆ™ã€‚

> Like a stack, the queue is a linear data structure that stores items in a First In First Out (FIFO) manner. With a queue, the least recently added item is removed first. A good example of a queue is any queue of consumers for a resource where the consumer that came first is served first.


![Queue in Python](https://raw.githubusercontent.com/GMyhf/img/main/img/Queue.png)


Operations associated with queue are: 

- Enqueue: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition â€“ Time Complexity : O(1)
- Dequeue: Removes an item from the queue. <mark>The items are popped in the same order in which they are pushed</mark>. If the queue is empty, then it is said to be an Underflow condition â€“ Time Complexity : O(1)
- Front: Get the front item from queue â€“ Time Complexity : O(1)
- Rear: Get the last item from queue â€“ Time Complexity : O(1)



The queue abstract data type is defined by the following structure and operations. A queue is structured, as described above, as <mark>an ordered collection of items which are added at one end, called the â€œrear,â€ and removed from the other end, called the â€œfront.â€ </mark>mQueues maintain a FIFO ordering property. The queue operations are given below.

- `Queue()` creates a new queue that is empty. It needs no parameters and returns an empty queue.
- `enqueue(item)` adds a new item to the rear of the queue. It needs the item and returns nothing.
- `dequeue()` removes the front item from the queue. It needs no parameters and returns the item. The queue is modified.
- `isEmpty()` tests to see whether the queue is empty. It needs no parameters and returns a boolean value.
- `size()` returns the number of items in the queue. It needs no parameters and returns an integer.

As an example, if we assume that `q` is a queue that has been created and is currently empty, then [Table 1](https://runestone.academy/ns/books/published/pythonds/BasicDS/TheQueueAbstractDataType.html#tbl-queueoperations) shows the results of a sequence of queue operations. The queue contents are shown such that the front is on the right. 4 was the first item enqueued so it is the first item returned by dequeue.



| **Queue Operation** | **Queue Contents**   | **Return Value** |
| :------------------ | :------------------- | :--------------- |
| `q.isEmpty()`       | `[]`                 | `True`           |
| `q.enqueue(4)`      | `[4]`                |                  |
| `q.enqueue('dog')`  | `['dog',4]`          |                  |
| `q.enqueue(True)`   | `[True,'dog',4]`     |                  |
| `q.size()`          | `[True,'dog',4]`     | `3`              |
| `q.isEmpty()`       | `[True,'dog',4]`     | `False`          |
| `q.enqueue(8.4)`    | `[8.4,True,'dog',4]` |                  |
| `q.dequeue()`       | `[8.4,True,'dog']`   | `4`              |
| `q.dequeue()`       | `[8.4,True]`         | `'dog'`          |
| `q.size()`          | `[8.4,True]`         | `2`              |



## 7.1 Implementing a Queue in Python

å†æ¬¡åˆ›å»ºä¸€ä¸ªæ–°ç±»æ¥å®ç°é˜Ÿåˆ—è¿™ç§æŠ½è±¡æ•°æ®ç±»å‹æ˜¯åˆé€‚çš„ã€‚åƒä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å°†åˆ©ç”¨åˆ—è¡¨é›†åˆçš„å¼ºå¤§å’Œç®€æ´æ€§æ¥æ„å»ºé˜Ÿåˆ—çš„å†…éƒ¨è¡¨ç¤ºã€‚

æˆ‘ä»¬éœ€è¦å†³å®šä½¿ç”¨åˆ—è¡¨çš„å“ªä¸€ç«¯ä½œä¸ºé˜Ÿåˆ—çš„å°¾éƒ¨ï¼ˆrearï¼‰ï¼Œå“ªä¸€ç«¯ä½œä¸ºå‰ç«¯ï¼ˆfrontï¼‰ã€‚æ¸…å•1ä¸­æ‰€ç¤ºçš„å®ç°<mark>å‡è®¾åˆ—è¡¨çš„ä½ç½®0å¤„ä¸ºé˜Ÿåˆ—çš„å°¾éƒ¨</mark>ã€‚è¿™å…è®¸æˆ‘ä»¬å¯¹åˆ—è¡¨ä½¿ç”¨`insert`å‡½æ•°åœ¨é˜Ÿåˆ—å°¾éƒ¨æ·»åŠ æ–°å…ƒç´ ã€‚å¯ä»¥<mark>ä½¿ç”¨`pop`æ“ä½œç§»é™¤å‰ç«¯çš„å…ƒç´ ï¼ˆå³åˆ—è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼‰</mark>ã€‚è¯·è®°ä½ï¼Œè¿™ä¹Ÿæ„å‘³ç€å…¥é˜Ÿï¼ˆenqueueï¼‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œè€Œå‡ºé˜Ÿï¼ˆdequeueï¼‰æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(1)ã€‚

è¿™ç§æ–¹æ³•ä¸‹ï¼Œè™½ç„¶åœ¨é˜Ÿåˆ—çš„å°¾éƒ¨æ·»åŠ å…ƒç´ éœ€è¦ç§»åŠ¨å…¶ä»–å…ƒç´ ä»¥è…¾å‡ºç©ºé—´ï¼Œå¯¼è‡´äº†è¾ƒé«˜çš„æ—¶é—´å¤æ‚åº¦O(n)ï¼Œä½†æ˜¯ä»é˜Ÿåˆ—å‰ç«¯ç§»é™¤å…ƒç´ åˆ™éå¸¸é«˜æ•ˆï¼Œä¸éœ€è¦é¢å¤–çš„å…ƒç´ ç§»åŠ¨ï¼ˆæ—¶é—´å¤æ‚åº¦ä¸ºO(1)ï¼‰ã€‚å› æ­¤ï¼Œé€‰æ‹©åˆ—è¡¨çš„å“ªä¸€ç«¯ä½œä¸ºé˜Ÿåˆ—çš„å‰ç«¯æˆ–å°¾éƒ¨å–å†³äºåº”ç”¨çš„å…·ä½“éœ€æ±‚ä»¥åŠå¯¹äºå…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œæ€§èƒ½çš„ä¸åŒè€ƒè™‘ã€‚ç„¶è€Œï¼Œé€šå¸¸æ›´å¸¸è§çš„æ˜¯å°†åˆ—è¡¨çš„æœ«å°¾è§†ä¸ºé˜Ÿåˆ—çš„å°¾éƒ¨ï¼Œè¿™æ ·å¯ä»¥ä¼˜åŒ–å…¥é˜Ÿæ“ä½œçš„æ•ˆç‡ï¼Œå°½ç®¡è¿™ä¸ä¸Šè¿°ç¤ºä¾‹ä¸­çš„åšæ³•ç›¸åã€‚

> It is again appropriate to create a new class for the implementation of the abstract data type queue. As before, we will use the power and simplicity of the list collection to build the internal representation of the queue.
>
> We need to decide which end of the list to use as the rear and which to use as the front. The implementation shown in Listing 1 assumes that the rear is at position 0 in the list. This allows us to use the `insert` function on lists to add new elements to the rear of the queue. The `pop` operation can be used to remove the front element (the last element of the list). Recall that this also means that enqueue will be O(n) and dequeue will be O(1).
>

```mermaid
classDiagram
    class Queue {
        - items: list
        
        + is_empty(self): boolean
        + enqueue(self, item: T): void
        + dequeue(self): T
        + size(self): int
    }
```



Listing 1

```python
class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, item):
        self.items.insert(0, item)

    def dequeue(self):
        return self.items.pop()

    def size(self):
        return len(self.items)


q = Queue()

q.enqueue('hello')
q.enqueue('dog')
q.enqueue(3)
print(q.items)

q.dequeue()
print(q.items)
# output:
# [3, 'dog', 'hello']
# [3, 'dog']
```



![image-20240227223254341](https://raw.githubusercontent.com/GMyhf/img/main/img/202402272233609.png)



**Q:** Suppose you have the following series of queue operations.

```
q = Queue()
q.enqueue('hello')
q.enqueue('dog')
q.enqueue(3)
q.dequeue()
```

What items are left on the queue? (B)

A. 'hello', 'dog'
**B. 'dog', 3**
C. 'hello', 3
D. 'hello', 'dog', 3



### ç¤ºä¾‹OJ02746: çº¦ç‘Ÿå¤«é—®é¢˜

implementation, http://cs101.openjudge.cn/practice/02746

çº¦ç‘Ÿå¤«é—®é¢˜ï¼šæœ‰ï½åªçŒ´å­ï¼ŒæŒ‰é¡ºæ—¶é’ˆæ–¹å‘å›´æˆä¸€åœˆé€‰å¤§ç‹ï¼ˆç¼–å·ä»ï¼‘åˆ°ï½ï¼‰ï¼Œä»ç¬¬ï¼‘å·å¼€å§‹æŠ¥æ•°ï¼Œä¸€ç›´æ•°åˆ°ï½ï¼Œæ•°åˆ°ï½çš„çŒ´å­é€€å‡ºåœˆå¤–ï¼Œå‰©ä¸‹çš„çŒ´å­å†æ¥ç€ä»1å¼€å§‹æŠ¥æ•°ã€‚å°±è¿™æ ·ï¼Œç›´åˆ°åœˆå†…åªå‰©ä¸‹ä¸€åªçŒ´å­æ—¶ï¼Œè¿™ä¸ªçŒ´å­å°±æ˜¯çŒ´ç‹ï¼Œç¼–ç¨‹æ±‚è¾“å…¥ï½ï¼Œï½åï¼Œè¾“å‡ºæœ€åçŒ´ç‹çš„ç¼–å·ã€‚

**è¾“å…¥**

æ¯è¡Œæ˜¯ç”¨ç©ºæ ¼åˆ†å¼€çš„ä¸¤ä¸ªæ•´æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯ n, ç¬¬äºŒä¸ªæ˜¯ m ( 0 < m,n <=300)ã€‚æœ€åä¸€è¡Œæ˜¯ï¼š

0 0

**è¾“å‡º**

å¯¹äºæ¯è¡Œè¾“å…¥æ•°æ®ï¼ˆæœ€åä¸€è¡Œé™¤å¤–)ï¼Œè¾“å‡ºæ•°æ®ä¹Ÿæ˜¯ä¸€è¡Œï¼Œå³æœ€åçŒ´ç‹çš„ç¼–å·

æ ·ä¾‹è¾“å…¥

```
6 2
12 4
8 3
0 0
```

æ ·ä¾‹è¾“å‡º

```
5
1
7
```



è¯´æ˜ï¼šä½¿ç”¨ é˜Ÿåˆ—queue è¿™ç§æ•°æ®ç»“æ„ä¼šæ–¹ä¾¿ã€‚å®ƒæœ‰ä¸‰ç§å®ç°æ–¹å¼ï¼Œæˆ‘ä»¬æœ€å¸¸ç”¨çš„ list å°±æ”¯æŒï¼Œè¯´æ˜ï¼Œhttps://www.geeksforgeeks.org/queue-in-python/



ç”¨listå®ç°é˜Ÿåˆ—ï¼ŒO(n)

```python
# å…ˆä½¿ç”¨popä»åˆ—è¡¨ä¸­å–å‡ºï¼Œå¦‚æœä¸ç¬¦åˆè¦æ±‚å†appendå›åˆ—è¡¨ï¼Œç›¸å½“äºæ„æˆäº†ä¸€ä¸ªåœˆ
def hot_potato(name_list, num):
    queue = []
    for name in name_list:
        queue.append(name)

    while len(queue) > 1:
        for i in range(num):
            queue.append(queue.pop(0))	# O(N)
        queue.pop(0)										# O(N)
    return queue.pop(0)									# O(N)


while True:
    n, m = map(int, input().split())
    if {n,m} == {0}:
        break
    monkey = [i for i in range(1, n+1)]
    print(hot_potato(monkey, m-1))

```



ç”¨å†…ç½®dequeï¼ŒO(1)

```python
from collections import deque

# å…ˆä½¿ç”¨popä»åˆ—è¡¨ä¸­å–å‡ºï¼Œå¦‚æœä¸ç¬¦åˆè¦æ±‚å†appendå›åˆ—è¡¨ï¼Œç›¸å½“äºæ„æˆäº†ä¸€ä¸ªåœˆ
def hot_potato(name_list, num):
    queue = deque()
    for name in name_list:
        queue.append(name)

    while len(queue) > 1:
        for i in range(num):
            queue.append(queue.popleft()) # O(1)
        queue.popleft()
    return queue.popleft()


while True:
    n, m = map(int, input().split())
    if {n,m} == {0}:
        break
    monkey = [i for i in range(1, n+1)]
    print(hot_potato(monkey, m-1))
```



## 7.2 æ¨¡æ‹Ÿå™¨æ‰“å°æœº

ä¸€ä¸ªæ›´æœ‰è¶£çš„ä¾‹å­æ˜¯æ¨¡æ‹Ÿæ‰“å°ä»»åŠ¡é˜Ÿåˆ—ã€‚å­¦ç”Ÿå‘å…±äº«æ‰“å°æœºå‘é€æ‰“å°è¯·æ±‚ï¼Œè¿™äº›æ‰“å°ä»»åŠ¡è¢«å­˜åœ¨ä¸€ä¸ªé˜Ÿåˆ—ä¸­ï¼Œå¹¶ä¸”æŒ‰ç…§å…ˆåˆ°å…ˆå¾—çš„é¡ºåºæ‰§è¡Œã€‚è¿™æ ·çš„è®¾å®šå¯èƒ½å¯¼è‡´å¾ˆå¤šé—®é¢˜ã€‚å…¶ä¸­æœ€é‡è¦çš„æ˜¯ï¼Œæ‰“å°æœºèƒ½å¦å¤„ç†ä¸€å®šé‡çš„å·¥ä½œã€‚å¦‚æœä¸èƒ½ï¼Œå­¦ç”Ÿå¯èƒ½ä¼šç”±äºç­‰å¾…è¿‡é•¿æ—¶é—´è€Œé”™è¿‡
è¦ä¸Šçš„è¯¾ã€‚

è€ƒè™‘è®¡ç®—æœºç§‘å­¦å®éªŒå®¤é‡Œçš„è¿™æ ·ä¸€ä¸ªåœºæ™¯ï¼šåœ¨ä»»ä½•ç»™å®šçš„ä¸€å°æ—¶å†…ï¼Œå®éªŒå®¤é‡Œéƒ½æœ‰çº¦ 10 ä¸ªå­¦ç”Ÿã€‚ä»–ä»¬åœ¨è¿™ä¸€å°æ—¶å†…æœ€å¤šæ‰“å° 2 æ¬¡ï¼Œå¹¶ä¸”æ‰“å°çš„é¡µæ•°ä» 1 åˆ° 20 ä¸ç­‰ã€‚å®éªŒå®¤çš„æ‰“å°æœºæ¯”è¾ƒè€æ—§ï¼Œæ¯åˆ†é’Ÿåªèƒ½ä»¥ä½è´¨é‡æ‰“å° 10 é¡µã€‚å¯ä»¥å°†æ‰“å°è´¨é‡è°ƒé«˜ï¼Œä½†æ˜¯è¿™æ ·åšä¼šå¯¼è‡´æ‰“å°æœºæ¯åˆ†é’Ÿåªèƒ½æ‰“å° 5 é¡µã€‚é™ä½æ‰“å°é€Ÿåº¦å¯èƒ½å¯¼è‡´å­¦ç”Ÿç­‰å¾…è¿‡é•¿æ—¶é—´ã€‚é‚£ä¹ˆï¼Œåº”è¯¥å¦‚ä½•è®¾ç½®æ‰“å°é€Ÿåº¦å‘¢ï¼Ÿ

å¯ä»¥é€šè¿‡æ„å»ºä¸€ä¸ªå®éªŒå®¤æ¨¡å‹æ¥è§£å†³è¯¥é—®é¢˜ã€‚æˆ‘ä»¬éœ€è¦ä¸ºå­¦ç”Ÿã€æ‰“å°ä»»åŠ¡å’Œæ‰“å°æœºæ„å»ºå¯¹è±¡ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚å½“å­¦ç”Ÿæäº¤æ‰“å°ä»»åŠ¡æ—¶ï¼Œå°†å®ƒä»¬åŠ å…¥ç­‰å¾…åˆ—è¡¨ä¸­ï¼Œè¯¥åˆ—è¡¨æ˜¯æ‰“å°æœºä¸Šçš„<mark>æ‰“å°ä»»åŠ¡é˜Ÿåˆ—</mark>ã€‚å½“æ‰“å°æœºæ‰§è¡Œå®Œä¸€ä¸ªä»»åŠ¡åï¼Œå®ƒä¼šæ£€æŸ¥è¯¥é˜Ÿåˆ—ï¼Œçœ‹çœ‹å…¶ä¸­æ˜¯å¦è¿˜æœ‰éœ€è¦å¤„ç†çš„ä»»åŠ¡ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯å­¦ç”Ÿ<mark>å¹³å‡éœ€è¦ç­‰å¾…å¤šä¹…</mark>æ‰èƒ½æ‹¿åˆ°æ‰“å°å¥½çš„æ–‡ç« ã€‚è¿™ä¸ªæ—¶é—´<mark>ç­‰äºæ‰“å°ä»»åŠ¡åœ¨é˜Ÿåˆ—ä¸­çš„å¹³å‡ç­‰å¾…æ—¶é—´</mark>ã€‚

![../_images/simulationsetup.png](https://raw.githubusercontent.com/GMyhf/img/main/img/simulationsetup.png)

Figure 4: Computer Science Laboratory Printing Queue

åœ¨æ¨¡æ‹Ÿæ—¶ï¼Œéœ€è¦åº”ç”¨ä¸€äº›æ¦‚ç‡å­¦çŸ¥è¯†ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œå­¦ç”Ÿæ‰“å°çš„æ–‡ç« å¯èƒ½æœ‰ 1~20 é¡µã€‚å¦‚æœå„é¡µæ•°å‡ºç°çš„æ¦‚ç‡ç›¸ç­‰ï¼Œé‚£ä¹ˆæ‰“å°ä»»åŠ¡çš„å®é™…æ—¶é•¿å¯ä»¥é€šè¿‡ 1~20 çš„ä¸€ä¸ªéšæœºæ•°æ¥æ¨¡æ‹Ÿã€‚

å¦‚æœå®éªŒå®¤é‡Œæœ‰ 10 ä¸ªå­¦ç”Ÿï¼Œå¹¶ä¸”åœ¨ä¸€å°æ—¶å†…æ¯ä¸ªäººéƒ½æ‰“å°ä¸¤æ¬¡ï¼Œé‚£ä¹ˆæ¯å°æ—¶å¹³å‡å°±æœ‰ 20 ä¸ªæ‰“å°ä»»åŠ¡ã€‚åœ¨ä»»æ„ä¸€ç§’ï¼Œåˆ›å»ºä¸€ä¸ªæ‰“å°ä»»åŠ¡çš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Ÿå›ç­”è¿™ä¸ªé—®é¢˜éœ€è¦è€ƒè™‘ä»»åŠ¡ä¸æ—¶é—´çš„æ¯”å€¼ã€‚æ¯å°æ—¶ 20 ä¸ªä»»åŠ¡ç›¸å½“äºæ¯ 180 ç§’ 1 ä¸ªä»»åŠ¡ã€‚



$\frac {20\ tasks}{1\ hour} \times \frac {1\ hour}  {60\ minutes} \times \frac {1\ minute} {60\ seconds}=\frac {1\ task} {180\ seconds}$



**1.ä¸»è¦æ¨¡æ‹Ÿæ­¥éª¤**
ä¸‹é¢æ˜¯ä¸»è¦çš„æ¨¡æ‹Ÿæ­¥éª¤ã€‚
(1) åˆ›å»ºä¸€ä¸ªæ‰“å°ä»»åŠ¡é˜Ÿåˆ—ã€‚æ¯ä¸€ä¸ªä»»åŠ¡åˆ°æ¥æ—¶éƒ½ä¼šæœ‰ä¸€ä¸ªæ—¶é—´æˆ³ã€‚ä¸€å¼€å§‹ï¼Œé˜Ÿåˆ—æ˜¯ç©ºçš„ã€‚

(2) é’ˆå¯¹æ¯ä¸€ç§’ï¼ˆcurrent_secondï¼‰ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œã€‚
â æ˜¯å¦æœ‰æ–°åˆ›å»ºçš„æ‰“å°ä»»åŠ¡ï¼Ÿå¦‚æœæ˜¯ï¼Œä»¥current_secondä½œä¸ºå…¶æ—¶é—´æˆ³å¹¶å°†è¯¥ä»»åŠ¡åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ã€‚
â å¦‚æœæ‰“å°æœºç©ºé—²ï¼Œå¹¶ä¸”æœ‰æ­£åœ¨ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
â–  ä»é˜Ÿåˆ—ä¸­å–å‡ºç¬¬ä¸€ä¸ªä»»åŠ¡å¹¶æäº¤ç»™æ‰“å°æœºï¼›
â–  ç”¨current_secondå‡å»è¯¥ä»»åŠ¡çš„æ—¶é—´æˆ³ï¼Œä»¥æ­¤è®¡ç®—å…¶ç­‰å¾…æ—¶é—´ï¼›
â–  å°†è¯¥ä»»åŠ¡çš„ç­‰å¾…æ—¶é—´å­˜å…¥ä¸€ä¸ªåˆ—è¡¨ï¼Œä»¥å¤‡åç”¨ï¼›
â–  æ ¹æ®è¯¥ä»»åŠ¡çš„é¡µæ•°ï¼Œè®¡ç®—æ‰§è¡Œæ—¶é—´ã€‚
â æ‰“å°æœºè¿›è¡Œä¸€ç§’çš„æ‰“å°ï¼ŒåŒæ—¶ä»è¯¥ä»»åŠ¡çš„æ‰§è¡Œæ—¶é—´ä¸­å‡å»ä¸€ç§’ã€‚
â å¦‚æœæ‰“å°ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼Œæˆ–è€…è¯´ä»»åŠ¡éœ€è¦çš„æ—¶é—´å‡ä¸º0ï¼Œåˆ™è¯´æ˜æ‰“å°æœºå›åˆ°ç©ºé—²çŠ¶æ€ã€‚

(3) å½“æ¨¡æ‹Ÿå®Œæˆä¹‹åï¼Œæ ¹æ®ç­‰å¾…æ—¶é—´åˆ—è¡¨ä¸­çš„å€¼è®¡ç®—å¹³å‡ç­‰å¾…æ—¶é—´ã€‚

**2.Pythonå®ç°**
æˆ‘ä»¬åˆ›å»º3ä¸ªç±»ï¼šPrinterã€Taskå’ŒPrintQueueã€‚å®ƒä»¬åˆ†åˆ«æ¨¡æ‹Ÿæ‰“å°æœºã€æ‰“å°ä»»åŠ¡å’Œé˜Ÿåˆ—ã€‚

Printerç±»éœ€è¦æ£€æŸ¥å½“å‰æ˜¯å¦æœ‰å¾…å®Œæˆçš„ä»»åŠ¡ã€‚å¦‚æœæœ‰ï¼Œé‚£ä¹ˆæ‰“å°æœºå°±å¤„äºå·¥ä½œçŠ¶æ€ï¼ˆbusyæ–¹æ³•ï¼‰ï¼Œå¹¶ä¸”å…¶å·¥ä½œæ‰€éœ€çš„æ—¶é—´å¯ä»¥é€šè¿‡è¦æ‰“å°çš„é¡µæ•°æ¥è®¡ç®—ã€‚å…¶æ„é€ æ–¹æ³•ä¼šåˆå§‹åŒ–æ‰“å°é€Ÿåº¦ï¼Œå³æ¯åˆ†é’Ÿæ‰“å°å¤šå°‘é¡µã€‚tickæ–¹æ³•ä¼šå‡é‡è®¡æ—¶ï¼Œå¹¶ä¸”åœ¨æ‰§è¡Œå®Œä»»åŠ¡ä¹‹åå°†æ‰“å°æœºè®¾ç½®æˆç©ºé—²çŠ¶æ€Noneã€‚

Taskç±»ä»£è¡¨å•ä¸ªæ‰“å°ä»»åŠ¡ã€‚å½“ä»»åŠ¡è¢«åˆ›å»ºæ—¶ï¼Œéšæœºæ•°ç”Ÿæˆå™¨ä¼šéšæœºæä¾›é¡µæ•°ï¼Œå–å€¼èŒƒå›´æ˜¯1ï½20ã€‚æˆ‘ä»¬ä½¿ç”¨randomæ¨¡å—ä¸­çš„randrangeå‡½æ•°æ¥ç”Ÿæˆéšæœºæ•°ã€‚




```mermaid
classDiagram
		class Queue {
        - items: list
        
        + is_empty(self)
        + enqueue(self, item)
        + dequeue(self)
        + size(self): int
    }

    class Printer {
        - page_rate: int
        - current_task: Task
        - time_remaining: int
        
        + tick(self)
        + busy(self)
        + start_next(self, newtask)
    }

    class Task {
        - timestamp: int
        - pages: int
        
        + get_stamp(self)
        + get_pages(self)
        + wait_ime(self, currenttime)
    }
```



ä»£ç æ¸…å•3-11 Printerç±»

```python
import random

class Queue:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def enqueue(self, item):
        self.items.insert(0, item)

    def dequeue(self):
        return self.items.pop()

    def size(self):
        return len(self.items)


class Printer:
    def __init__(self, ppm):
        self.page_rate = ppm
        self.current_task = None
        self.time_remaining = 0

    def tick(self):
        if self.current_task != None:
            self.time_remaining = self.time_remaining - 1
            if self.time_remaining <= 0:
                self.current_task = None

    def busy(self):
        if self.current_task != None:
            return True
        else:
            return False

    def start_next(self, new_task):
        self.current_task = new_task
        self.time_remaining = new_task.get_pages() * 60 / self.page_rate


class Task:
    def __init__(self, time):
        self.timestamp = time
        self.pages = random.randrange(1, 21)

    def get_stamp(self):
        return self.timestamp

    def get_pages(self):
        return self.pages

    def wait_time(self, current_time):
        return current_time - self.timestamp


def simulation(num_seconds, pages_per_minute):
    lab_printer = Printer(pages_per_minute)
    print_queue = Queue()
    waiting_times = []

    for current_second in range(num_seconds):

        if new_print_task():
            task = Task(current_second)
            print_queue.enqueue(task)

        if (not lab_printer.busy()) and (not print_queue.is_empty()):
            nexttask = print_queue.dequeue()
            waiting_times.append(nexttask.wait_time(current_second))
            lab_printer.start_next(nexttask)

        lab_printer.tick()

    average_wait = sum(waiting_times) / len(waiting_times)
    print(f"Average Wait {average_wait:6.2f} secs {print_queue.size():3d} tasks remaining.")


def new_print_task():
    num = random.randrange(1, 181)
    if num == 180:
        return True
    else:
        return False


for i in range(10):
    simulation(3600, 10) # è®¾ç½®æ€»æ—¶é—´å’Œæ‰“å°æœºæ¯åˆ†é’Ÿæ‰“å°å¤šå°‘é¡µ

"""
Average Wait  20.05 secs   0 tasks remaining.
Average Wait  20.12 secs   0 tasks remaining.
Average Wait  28.32 secs   0 tasks remaining.
Average Wait   7.65 secs   0 tasks remaining.
Average Wait  13.17 secs   1 tasks remaining.
Average Wait  45.97 secs   0 tasks remaining.
Average Wait  14.94 secs   0 tasks remaining.
Average Wait   1.81 secs   0 tasks remaining.
Average Wait   0.00 secs   0 tasks remaining.
Average Wait   6.71 secs   0 tasks remaining.
"""
```



æ¯ä¸€ä¸ªä»»åŠ¡éƒ½éœ€è¦ä¿å­˜ä¸€ä¸ªæ—¶é—´æˆ³ï¼Œç”¨äºè®¡ç®—ç­‰å¾…æ—¶é—´ã€‚è¿™ä¸ªæ—¶é—´æˆ³ä»£è¡¨ä»»åŠ¡è¢«åˆ›å»ºå¹¶æ”¾å…¥æ‰“å°ä»»åŠ¡é˜Ÿåˆ—çš„æ—¶é—´ã€‚ wait_time æ–¹æ³•å¯ä»¥è·å¾—ä»»åŠ¡åœ¨é˜Ÿåˆ—ä¸­ç­‰å¾…çš„æ—¶é—´ã€‚

ä¸»æ¨¡æ‹Ÿç¨‹åºsimulationå®ç°äº†ä¹‹å‰æè¿°çš„ç®—æ³•ã€‚ print_queue å¯¹è±¡æ˜¯é˜Ÿåˆ—æŠ½è±¡æ•°æ®ç±»å‹çš„å®ä¾‹ã€‚å¸ƒå°”è¾…åŠ©å‡½æ•°new_print_taskåˆ¤æ–­æ˜¯å¦æœ‰æ–°åˆ›å»ºçš„æ‰“å°ä»»åŠ¡ã€‚æˆ‘ä»¬å†ä¸€æ¬¡ä½¿ç”¨randomæ¨¡å—ä¸­çš„ randrange å‡½æ•°æ¥ç”Ÿæˆéšæœºæ•°ï¼Œä¸è¿‡è¿™ä¸€æ¬¡çš„å–å€¼èŒƒå›´æ˜¯ 1~180ã€‚å¹³å‡æ¯ 180 ç§’æœ‰ä¸€ä¸ªæ‰“å°ä»»åŠ¡ã€‚é€šè¿‡ä»éšæœºæ•°ä¸­é€‰å– 180ï¼Œå¯ä»¥æ¨¡æ‹Ÿè¿™ä¸ªéšæœºäº‹ä»¶ã€‚

æ¯æ¬¡æ¨¡æ‹Ÿçš„ç»“æœä¸ä¸€å®šç›¸åŒã€‚å¯¹æ­¤ï¼Œæˆ‘ä»¬ä¸éœ€è¦åœ¨æ„ã€‚è¿™æ˜¯ç”±äºéšæœºæ•°çš„æœ¬è´¨å¯¼è‡´çš„ã€‚æˆ‘ä»¬æ„Ÿå…´è¶£çš„æ˜¯å½“å‚æ•°æ”¹å˜æ—¶ç»“æœå‡ºç°çš„è¶‹åŠ¿ã€‚

é¦–å…ˆï¼Œæ¨¡æ‹Ÿ 60 åˆ†é’Ÿï¼ˆ 3600 ç§’ï¼‰å†…æ‰“å°é€Ÿåº¦ä¸ºæ¯åˆ†é’Ÿ 5 é¡µã€‚å¹¶ä¸”ï¼Œæˆ‘ä»¬è¿›è¡Œ 10 æ¬¡è¿™æ ·çš„æ¨¡æ‹Ÿã€‚ç”±äºæ¨¡æ‹Ÿä¸­ä½¿ç”¨äº†éšæœºæ•°ï¼Œå› æ­¤æ¯æ¬¡è¿”å›çš„ç»“æœéƒ½ä¸åŒã€‚
åœ¨æ¨¡æ‹Ÿ 10 æ¬¡ä¹‹åï¼Œå¯ä»¥çœ‹åˆ°å¹³å‡ç­‰å¾…æ—¶é—´æ˜¯ 122.092 ç§’ï¼Œå¹¶ä¸”ç­‰å¾…æ—¶é—´çš„å·®å¼‚è¾ƒå¤§ï¼Œä»æœ€çŸ­çš„ 17.27 ç§’åˆ°æœ€é•¿çš„ 376.05 ç§’ã€‚æ­¤å¤–ï¼Œåªæœ‰ 2 æ¬¡åœ¨ç»™å®šæ—¶é—´å†…å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡ã€‚
ç°åœ¨æŠŠæ‰“å°é€Ÿåº¦æ”¹æˆæ¯åˆ†é’Ÿ 10 é¡µï¼Œç„¶åå†æ¨¡æ‹Ÿ 10 æ¬¡ã€‚ç”±äºåŠ å¿«äº†æ‰“å°é€Ÿåº¦ï¼Œå› æ­¤æˆ‘ä»¬å¸Œæœ›ä¸€å°æ—¶å†…èƒ½å®Œæˆæ›´å¤šæ‰“å°ä»»åŠ¡ã€‚



**3.è®¨è®º**
åœ¨ä¹‹å‰çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬è¯•å›¾è§£ç­”è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœæé«˜æ‰“å°è´¨é‡å¹¶é™ä½æ‰“å°é€Ÿåº¦ï¼Œæ‰“å°æœºèƒ½å¦åŠæ—¶å®Œæˆæ‰€æœ‰ä»»åŠ¡ï¼Ÿæˆ‘ä»¬ç¼–å†™äº†ä¸€ä¸ªç¨‹åºæ¥æ¨¡æ‹Ÿéšæœºæäº¤çš„æ‰“å°ä»»åŠ¡ï¼Œå¾…æ‰“å°çš„é¡µæ•°ä¹Ÿæ˜¯éšæœºçš„ã€‚

ä¸Šé¢çš„è¾“å‡ºç»“æœæ˜¾ç¤ºï¼ŒæŒ‰æ¯åˆ†é’Ÿ5é¡µçš„æ‰“å°é€Ÿåº¦ï¼Œä»»åŠ¡çš„ç­‰å¾…æ—¶é—´åœ¨31.50ç§’å’Œ292.40ç§’ä¹‹é—´ï¼Œç›¸å·®çº¦6åˆ†é’Ÿã€‚æé«˜æ‰“å°é€Ÿåº¦ä¹‹åï¼Œç­‰å¾…æ—¶é—´åœ¨1.29ç§’å’Œ28.96ç§’ä¹‹é—´ã€‚æ­¤å¤–ï¼Œåœ¨æ¯åˆ†é’Ÿ5é¡µçš„é€Ÿåº¦ä¸‹ï¼Œ10æ¬¡æ¨¡æ‹Ÿä¸­æœ‰2æ¬¡æ²¡æœ‰æŒ‰æ—¶å®Œæˆæ‰€æœ‰ä»»åŠ¡ã€‚

```
Average Wait  45.88 secs   0 tasks remaining.
Average Wait  94.42 secs   0 tasks remaining.
Average Wait 292.40 secs   2 tasks remaining.
Average Wait  49.39 secs   0 tasks remaining.
Average Wait 148.27 secs   0 tasks remaining.
Average Wait 162.19 secs   0 tasks remaining.
Average Wait  71.00 secs   1 tasks remaining.
Average Wait  31.50 secs   0 tasks remaining.
Average Wait 116.74 secs   0 tasks remaining.
Average Wait  90.63 secs   0 tasks remaining.
```

å¯è§ï¼Œé™ä½æ‰“å°é€Ÿåº¦ä»¥æé«˜æ‰“å°è´¨é‡ï¼Œå¹¶ä¸æ˜¯æ˜æ™ºçš„åšæ³•ã€‚å­¦ç”Ÿä¸èƒ½ç­‰å¾…å¤ªé•¿æ—¶é—´ï¼Œå½“ä»–ä»¬è¦èµ¶å»ä¸Šè¯¾æ—¶å°¤å…¶å¦‚æ­¤ã€‚6åˆ†é’Ÿçš„ç­‰å¾…æ—¶é—´å®åœ¨æ˜¯å¤ªé•¿äº†ã€‚

è¿™ç§æ¨¡æ‹Ÿåˆ†æèƒ½å¸®åŠ©æˆ‘ä»¬å›ç­”å¾ˆå¤šâ€œå¦‚æœâ€é—®é¢˜ã€‚åªéœ€æ”¹å˜å‚æ•°ï¼Œå°±å¯ä»¥æ¨¡æ‹Ÿæ„Ÿå…´è¶£çš„ä»»æ„è¡Œä¸ºã€‚ä»¥ä¸‹æ˜¯å‡ ä¸ªä¾‹å­ã€‚
  â å¦‚æœå®éªŒå®¤é‡Œçš„å­¦ç”Ÿå¢åŠ åˆ°20ä¸ªï¼Œä¼šæ€ä¹ˆæ ·ï¼Ÿ
  â å¦‚æœæ˜¯å‘¨å…­ï¼Œå­¦ç”Ÿä¸éœ€è¦ä¸Šè¯¾ï¼Œä»–ä»¬æ˜¯å¦æ„¿æ„ç­‰å¾…ï¼Ÿ
  â å¦‚æœæ¯ä¸ªä»»åŠ¡çš„é¡µæ•°å˜å°‘äº†ï¼Œä¼šæ€ä¹ˆæ ·ï¼Ÿ

è¿™äº›é—®é¢˜éƒ½èƒ½é€šè¿‡ä¿®æ”¹æœ¬ä¾‹ä¸­çš„æ¨¡æ‹Ÿç¨‹åºæ¥è§£ç­”ã€‚ä½†æ˜¯ï¼Œæ¨¡æ‹Ÿçš„å‡†ç¡®åº¦å–å†³äºå®ƒæ‰€åŸºäºçš„å‡è®¾å’Œå‚æ•°ã€‚çœŸå®çš„æ‰“å°ä»»åŠ¡æ•°é‡å’Œå­¦ç”Ÿæ•°ç›®æ˜¯å‡†ç¡®æ„å»ºæ¨¡æ‹Ÿç¨‹åºå¿…ä¸å¯ç¼ºçš„æ•°æ®ã€‚





# 8. åŒç«¯é˜Ÿåˆ—

ä¸æ ˆå’Œé˜Ÿåˆ—ä¸åŒçš„æ˜¯ï¼ŒåŒç«¯é˜Ÿåˆ—çš„é™åˆ¶å¾ˆå°‘ã€‚åŒç«¯é˜Ÿåˆ—æ˜¯ä¸é˜Ÿåˆ—ç±»ä¼¼çš„æœ‰åºé›†åˆã€‚å®ƒæœ‰ä¸€å‰ã€ä¸€åä¸¤ç«¯ï¼Œå…ƒç´ åœ¨å…¶ä¸­ä¿æŒè‡ªå·±çš„ä½ç½®ã€‚ä¸é˜Ÿåˆ—ä¸åŒçš„æ˜¯ï¼ŒåŒç«¯é˜Ÿåˆ—å¯¹åœ¨å“ªä¸€ç«¯æ·»åŠ å’Œç§»é™¤å…ƒç´ æ²¡æœ‰ä»»ä½•é™åˆ¶ã€‚æ–°å…ƒç´ æ—¢å¯ä»¥è¢«æ·»åŠ åˆ°å‰ç«¯ï¼Œä¹Ÿå¯ä»¥è¢«æ·»åŠ åˆ°åç«¯ã€‚åŒç†ï¼Œå·²æœ‰çš„å…ƒç´ ä¹Ÿèƒ½ä»ä»»æ„ä¸€ç«¯ç§»é™¤ã€‚

The deque abstract data type is defined by the following structure and operations. A deque is structured, as described above, as an ordered collection of items where items are added and removed from either end, either front or rear. The deque operations are given below.

- `Deque()` creates a new deque that is empty. It needs no parameters and returns an empty deque.
- `addFront(item)` adds a new item to the front of the deque. It needs the item and returns nothing.
- `addRear(item)` adds a new item to the rear of the deque. It needs the item and returns nothing.
- `removeFront()` removes the front item from the deque. It needs no parameters and returns the item. The deque is modified.
- `removeRear()` removes the rear item from the deque. It needs no parameters and returns the item. The deque is modified.
- `isEmpty()` tests to see whether the deque is empty. It needs no parameters and returns a boolean value.
- `size()` returns the number of items in the deque. It needs no parameters and returns an integer.

As an example, if we assume that `d` is a deque that has been created and is currently empty, then Table {dequeoperations} shows the results of a sequence of deque operations. Note that the contents in front are listed on the right. It is very important to keep track of the front and the rear as you move items in and out of the collection as things can get a bit confusing.



| **Deque Operation** | **Deque Contents**         | **Return Value** |
| :------------------ | :------------------------- | :--------------- |
| `d.isEmpty()`       | `[]`                       | `True`           |
| `d.addRear(4)`      | `[4]`                      |                  |
| `d.addRear('dog')`  | `['dog',4,]`               |                  |
| `d.addFront('cat')` | `['dog',4,'cat']`          |                  |
| `d.addFront(True)`  | `['dog',4,'cat',True]`     |                  |
| `d.size()`          | `['dog',4,'cat',True]`     | `4`              |
| `d.isEmpty()`       | `['dog',4,'cat',True]`     | `False`          |
| `d.addRear(8.4)`    | `[8.4,'dog',4,'cat',True]` |                  |
| `d.removeRear()`    | `['dog',4,'cat',True]`     | `8.4`            |
| `d.removeFront()`   | `['dog',4,'cat']`          | `True`           |



## **åŒç«¯é˜Ÿåˆ—å®ç°**

```python
class Deque:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def add_front(self, item):
        self.items.append(item)

    def add_rear(self, item):
        self.items.insert(0, item)

    def remove_front(self):
        return self.items.pop()

    def remove_rear(self):
        return self.items.pop(0)

    def size(self):
        return len(self.items)


d = Deque()
print(d.is_empty())
d.add_rear(4)
d.add_rear('dog')
d.add_front('cat')
d.add_front(True)
print(d.size())
print(d.is_empty())
d.add_rear(8.4)
print(d.remove_rear())
print(d.remove_front())
"""
True
4
False
8.4
True
"""
```

åœ¨åŒç«¯é˜Ÿåˆ—çš„Pythonå®ç°ä¸­ï¼Œåœ¨å‰ç«¯è¿›è¡Œçš„æ·»åŠ æ“ä½œå’Œç§»é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(1)ï¼Œåœ¨åç«¯çš„åˆ™æ˜¯O( )nã€‚



## ç»ƒä¹ 05902: åŒç«¯é˜Ÿåˆ—

http://cs101.openjudge.cn/practice/05902/

å®šä¹‰ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œè¿›é˜Ÿæ“ä½œä¸æ™®é€šé˜Ÿåˆ—ä¸€æ ·ï¼Œä»é˜Ÿå°¾è¿›å…¥ã€‚å‡ºé˜Ÿæ“ä½œæ—¢å¯ä»¥ä»é˜Ÿå¤´ï¼Œä¹Ÿå¯ä»¥ä»é˜Ÿå°¾ã€‚ç¼–ç¨‹å®ç°è¿™ä¸ªæ•°æ®ç»“æ„ã€‚

**è¾“å…¥**
ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°tï¼Œä»£è¡¨æµ‹è¯•æ•°æ®çš„ç»„æ•°ã€‚
æ¯ç»„æ•°æ®çš„ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºæ“ä½œçš„æ¬¡æ•°ã€‚
æ¥ç€è¾“å…¥nè¡Œï¼Œæ¯è¡Œå¯¹åº”ä¸€ä¸ªæ“ä½œï¼Œé¦–å…ˆè¾“å…¥ä¸€ä¸ªæ•´æ•°typeã€‚
å½“type=1ï¼Œè¿›é˜Ÿæ“ä½œï¼Œæ¥ç€è¾“å…¥ä¸€ä¸ªæ•´æ•°xï¼Œè¡¨ç¤ºè¿›å…¥é˜Ÿåˆ—çš„å…ƒç´ ã€‚
å½“type=2ï¼Œå‡ºé˜Ÿæ“ä½œï¼Œæ¥ç€è¾“å…¥ä¸€ä¸ªæ•´æ•°cï¼Œc=0ä»£è¡¨ä»é˜Ÿå¤´å‡ºé˜Ÿï¼Œc=1ä»£è¡¨ä»é˜Ÿå°¾å‡ºé˜Ÿã€‚
n <= 1000

**è¾“å‡º**
å¯¹äºæ¯ç»„æµ‹è¯•æ•°æ®ï¼Œè¾“å‡ºæ‰§è¡Œå®Œæ‰€æœ‰çš„æ“ä½œåé˜Ÿåˆ—ä¸­å‰©ä½™çš„å…ƒç´ ,å…ƒç´ ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼ŒæŒ‰é˜Ÿå¤´åˆ°é˜Ÿå°¾çš„é¡ºåºè¾“å‡ºï¼Œå ä¸€è¡Œã€‚å¦‚æœé˜Ÿåˆ—ä¸­å·²ç»æ²¡æœ‰ä»»ä½•çš„å…ƒç´ ï¼Œè¾“å‡ºNULLã€‚

æ ·ä¾‹è¾“å…¥

```
2
5
1 2
1 3
1 4
2 0
2 1
6
1 1
1 2
1 3
2 0
2 1
2 0
```

æ ·ä¾‹è¾“å‡º

```
3
NULL
```



```python
from collections import deque

for _ in range(int(input())):
    n=int(input())
    q=deque([])
    for i in range(n):
        a,b=map(int,input().split())
        if a==1:
            q.append(b)
        else:
            if b==0:
                q.popleft()
            else:
                q.pop()
    if q:
        print(*q)
    else:
        print('NULL')
```





## ç»ƒä¹ 04067: å›æ–‡æ•°å­—ï¼ˆPalindrome Numberï¼‰

http://cs101.openjudge.cn/practice/04067/

ç»™å‡ºä¸€ç³»åˆ—éè´Ÿæ•´æ•°ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªå›æ–‡æ•°ã€‚å›æ–‡æ•°æŒ‡çš„æ˜¯æ­£ç€å†™å’Œå€’ç€å†™ç›¸ç­‰çš„æ•°ã€‚

**è¾“å…¥**

è‹¥å¹²è¡Œï¼Œæ¯è¡Œæ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ï¼ˆä¸è¶…è¿‡99999999ï¼‰

**è¾“å‡º**

å¯¹æ¯è¡Œè¾“å…¥ï¼Œå¦‚æœå…¶æ˜¯ä¸€ä¸ªå›æ–‡æ•°ï¼Œè¾“å‡ºYESã€‚å¦åˆ™è¾“å‡ºNOã€‚

æ ·ä¾‹è¾“å…¥

```
11
123
0
14277241
67945497
```

æ ·ä¾‹è¾“å‡º

```
YES
NO
YES
YES
NO
```



Use the deque from the collections module. The is_palindrome function checks if a number is a palindrome by converting it to a string, storing it in a deque, and then comparing the first and last elements until the deque is empty or only contains one element.

```python
from collections import deque

def is_palindrome(num):
    num_str = str(num)
    num_deque = deque(num_str)
    while len(num_deque) > 1:
        if num_deque.popleft() != num_deque.pop():
            return "NO"
    return "YES"

while True:
    try:
        num = int(input())
        print(is_palindrome(num))
    except EOFError:
        break
```





## ç»ƒä¹ 04099: é˜Ÿåˆ—å’Œæ ˆ

http://cs101.openjudge.cn/practice/04099/

```python
from collections import deque
for _ in range(int(input())):
    queue = deque()
    stack = deque()
    stop = False
    for _ in range(int(input())):
        s = input()
        if s=='pop':
            try:
                queue.popleft()
                stack.pop()
            except IndexError:
                stop = True
        else:
            a = int(s.split()[1])
            queue.append(a)
            stack.append(a)
    if not stop:
        print(' '.join(list(map(str,queue))))
        print(' '.join(list(map(str,stack))))
    elif stop:
        print('error')
        print('error')
```





# é™„å½•

cs101è®¡æ¦‚ï¼ˆè®¡ç®—æœºåŸºç¡€1/2ï¼‰æ¯æ—¥é€‰åš

https://github.com/GMyhf/2024fall-cs101/blob/main/problem_list_at_2024fall.md



Pythonæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æï¼ˆç¬¬3ç‰ˆï¼‰ï¼Œhttps://runestone.academy/ns/books/published/pythonds3/index.html



ç®—æ³•å¯¼è®º ç¬¬ä¸‰ç‰ˆ  (Thmos.H.Cormen ,Charles E. Leiserson etc.) 






